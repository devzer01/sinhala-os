<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-gb">
<head>
<title>Advanced MS-DOS Programming</title>
<meta name="msvalidate.01" content="D164E24C3D15F71B0DF99F555745B2B6" />
<META name="y_key" content="8e4cd8f05876978f" />
<meta name="robots" content="noarchive">
<script src="/cdn-cgi/apps/head/8nlVlCe8bl98fGnZyg-17H7ES5c.js"></script><link rel="stylesheet" href="/style/" type="text/css">
<link rel="icon" href="/images/favicon/" type="image/png">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        
          ga('create', 'UA-60542-26', 'meulie.net');
ga('require', 'displayfeatures');
            ga('send', 'pageview');
            
            </script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
</head>
<body>
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
        js.src = "//connect.facebook.net/en_GB/all.js#xfbml=1&appId=383401045082893";
          fjs.parentNode.insertBefore(js, fjs);
          }(document, 'script', 'facebook-jssdk'));</script>
<div id="toolbar"><div id="toolbarContent">
<div id="logo">
<a href="/"><img src="/images/toolbar/logo/" width="275" height="50" alt="Introduction"></a>
</div>
<div id="navigation">
<img src="/images/toolbar/introduction/" width="16" height="16" alt=""> <a href="/">Introduction</a>
<img src="/images/toolbar/statistics/" width="16" height="16" alt=""> <a href="/statistics/">Statistics</a>
<img src="/images/toolbar/contact/" width="16" height="16" alt=""> <a href="/contact/">Contact</a>
<img src="/images/toolbar/development/" width="16" height="16" alt=""> <a href="/development/">Development</a>
<img src="/images/toolbar/disclaimer/" width="16" height="16" alt=""> <a href="/disclaimer/">Disclaimer</a>
<img src="/images/toolbar/help/" width="16" height="16" alt=""> <a href="/help/">Help</a>
</div>
<form id="addressBar" method="POST" action="/redirect/" onsubmit="window.location.pathname = document.getElementById('address').value.replace(/^gopher:\/\//, '');return false;">
<div>
<input type="text" id="address" name="address" value="gopher://gopher.viste.fr/0/programming/PC/DOS/advdos-utf8.txt"><button type="submit" title="Go"><img src="/images/toolbar/go/" width="22" height="22" alt="Go"></button>
</div>
</form>
<form id="searchBar" method="POST" action="/gopher.floodgap.com/7/v2/vs">
<div>
<input type="text" name="query"><button type="submit" title="Search"><img src="/images/toolbar/search/" width="22" height="22" alt="Search"></button>
</div>
</form>
</div></div>
<table id="menu">
<tr>
<td><img src="/images/proxy/menu/" width="16" height="16" alt=""></td>
<td><a href="/gopher.viste.fr/">gopher.viste.fr home page</a></td>
</tr>
</table>
<div id="text">
Advanced MS-DOS Programming
<br>
<br>
<br>
════════════════════════════════════════════════════════════════════════════
<br>
<br>
<br>
Advanced MS-DOS Programming
<br>
<br>
The Microsoft(R) Guide for Assembly Language and C Programmers
<br>
<br>
By Ray Duncan
<br>
<br>
<br>
════════════════════════════════════════════════════════════════════════════
<br>
<br>
<br>
&nbsp;PUBLISHED BY
<br>
&nbsp;Microsoft Press
<br>
&nbsp;A Division of Microsoft Corporation
<br>
&nbsp;16011 NE 36th Way, Box 97017, Redmond, Washington 98073-9717
<br>
&nbsp;Copyright (C) 1986, 1988 by Ray Duncan
<br>
&nbsp;Published 1986. Second edition 1988.
<br>
&nbsp;All rights reserved. No part of the contents of this book may be
<br>
&nbsp;reproduced or transmitted in any form or by any means without the written
<br>
&nbsp;permission of the publisher.
<br>
&nbsp;Library of Congress Cataloging in Publication Data
<br>
<br>
&nbsp;Duncan, Ray, 1952-
<br>
&nbsp;Advanced MS-DOS programming.
<br>
&nbsp;Rev. ed. of: Advanced MS-DOS. (C)1986.
<br>
&nbsp;Includes index.
<br>
&nbsp;1. MS-DOS (Computer operating system) &nbsp;2. Assembler language
<br>
&nbsp;(Computer program language) &nbsp;3. C (Computer program language)
<br>
&nbsp;I. Duncan, Ray, 1952- &nbsp; &nbsp;Advanced MS-DOS. &nbsp; &nbsp;II. Title.
<br>
&nbsp;QA76.76.063D858 &nbsp; &nbsp; &nbsp;1988 &nbsp; &nbsp; &nbsp;005.4'46 &nbsp; &nbsp; &nbsp;88-1251
<br>
&nbsp;ISBN 1-55615-157-8
<br>
&nbsp;Printed and bound in the United States of America.
<br>
<br>
&nbsp;1 2 3 4 5 6 7 8 9 &nbsp; &nbsp;FGFG &nbsp; &nbsp;3 2 1 0 9 8
<br>
<br>
&nbsp;Distributed to the book trade in the United States by Harper &amp; Row.
<br>
<br>
&nbsp;Distributed to the book trade in Canada by General Publishing Company,
<br>
&nbsp;Ltd.
<br>
<br>
&nbsp;Penguin Books Ltd., Harmondworth, Middlesex, England
<br>
&nbsp;Penguin Books Australia Ltd., Ringwood, Victoria, Australia
<br>
&nbsp;Penguin Books N.Z. Ltd., 182-190 Wairu Road, Auckland 10, New Zealand
<br>
<br>
&nbsp;British Cataloging in Publication Data available
<br>
<br>
&nbsp;IBM(R), PC/AT(R), and PS/2(R) are registered trademarks of International
<br>
&nbsp;Business Machines Corporation. CodeView(R), Microsoft(R), MS-DOS(R), and
<br>
&nbsp;XENIX(R) are registered trademarks and InPort TM is a trademark of
<br>
&nbsp;Microsoft Corporation.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp;Technical Editor: Mike Halvorson &nbsp;Production Editor: Mary Ann Jones
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Dedication
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;For Carolyn
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Contents
<br>
<br>
&nbsp;Road Map to Figures and Tables
<br>
<br>
&nbsp;Acknowledgments
<br>
<br>
&nbsp;Introduction
<br>
<br>
&nbsp;SECTION 1 &nbsp; PROGRAMMING FOR MS-DOS
<br>
<br>
&nbsp;Chapter 1 &nbsp; Genealogy of MS-DOS
<br>
<br>
&nbsp;Chapter 2 &nbsp; MS-DOS in Operation
<br>
<br>
&nbsp;Chapter 3 &nbsp; Structure of MS-DOS Application Programs
<br>
<br>
&nbsp;Chapter 4 &nbsp; MS-DOS Programming Tools
<br>
<br>
&nbsp;Chapter 5 &nbsp; Keyboard and Mouse Input
<br>
<br>
&nbsp;Chapter 6 &nbsp; Video Display
<br>
<br>
&nbsp;Chapter 7 &nbsp; Printer and Serial Port
<br>
<br>
&nbsp;Chapter 8 &nbsp; File Management
<br>
<br>
&nbsp;Chapter 9 &nbsp; Volumes and Directories
<br>
<br>
&nbsp;Chapter 10 &nbsp;Disk Internals
<br>
<br>
&nbsp;Chapter 11 &nbsp;Memory Management
<br>
<br>
&nbsp;Chapter 12 &nbsp;The EXEC Function
<br>
<br>
&nbsp;Chapter 13 &nbsp;Interrupt Handlers
<br>
<br>
&nbsp;Chapter 14 &nbsp;Installable Device Drivers
<br>
<br>
&nbsp;Chapter 15 &nbsp;Filters
<br>
<br>
&nbsp;Chapter 16 &nbsp;Compatibility and Portability
<br>
<br>
&nbsp;SECTION 2 &nbsp; MS-DOS FUNCTIONS REFERENCE
<br>
<br>
&nbsp;SECTION 3 &nbsp; IBM ROM BIOS AND MOUSE FUNCTIONS REFERENCE
<br>
<br>
&nbsp;SECTION 4 &nbsp; LOTUS/INTEL/MICROSOFT EMS FUNCTIONS REFERENCE
<br>
<br>
&nbsp;Index
<br>
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Road Map to Figures and Tables
<br>
<br>
&nbsp;MS-DOS versions and release dates
<br>
<br>
&nbsp;MS-DOS memory map
<br>
<br>
&nbsp;Structure of program segment prefix (PSP)
<br>
<br>
&nbsp;Structure of .EXE load module
<br>
<br>
&nbsp;Register conditions at program entry
<br>
<br>
&nbsp;Segments, groups, and classes
<br>
<br>
&nbsp;Macro Assembler switches
<br>
<br>
&nbsp;C Compiler switches
<br>
<br>
&nbsp;Linker switches
<br>
<br>
&nbsp;MAKE switches
<br>
<br>
&nbsp;ANSI escape sequences
<br>
<br>
&nbsp;Video attributes
<br>
<br>
&nbsp;Structure of normal file control block (FCB)
<br>
<br>
&nbsp;Structure of extended file control block
<br>
<br>
&nbsp;MS-DOS error codes
<br>
<br>
&nbsp;Structure of boot sector
<br>
<br>
&nbsp;Structure of directory entry
<br>
<br>
&nbsp;Structure of fixed-disk master block
<br>
<br>
&nbsp;LIM EMS error codes
<br>
<br>
&nbsp;Intel 80x86 internal interrupts (faults)
<br>
<br>
&nbsp;Intel 80x86, MS-DOS, and ROM BIOS interrupts
<br>
<br>
&nbsp;Device-driver attribute word
<br>
<br>
&nbsp;Device-driver command codes
<br>
<br>
&nbsp;Structure of BIOS parameter block (BPB)
<br>
<br>
&nbsp;Media descriptor byte
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Acknowledgments
<br>
<br>
&nbsp;My renewed thanks to the outstanding editors and production staff at
<br>
&nbsp;Microsoft Press, who make beautiful books happen, and to the talented
<br>
&nbsp;Microsoft developers, who create great programs to write books about.
<br>
&nbsp;Special thanks to Mike Halvorson, Jeff Hinsch, Mary Ann Jones, Claudette
<br>
&nbsp;Moore, Dori Shattuck, and Mark Zbikowski; if this book has anything unique
<br>
&nbsp;to offer, these people deserve most of the credit.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Introduction
<br>
<br>
&nbsp;Advanced MS-DOS Programming is written for the experienced C or
<br>
&nbsp;assembly-language programmer. It provides all the information you need to
<br>
&nbsp;write robust, high-performance applications under the MS-DOS operating
<br>
&nbsp;system. Because I believe that working, well-documented programs are
<br>
&nbsp;unbeatable learning tools, I have included detailed programming examples
<br>
&nbsp;throughout──including complete utility programs that you can adapt to your
<br>
&nbsp;own needs.
<br>
<br>
&nbsp;This book is both a tutorial and a reference and is divided into four
<br>
&nbsp;sections, so that you can find information more easily. Section 1
<br>
&nbsp;discusses MS-DOS capabilities and services by functional group in the
<br>
&nbsp;context of common programming issues, such as user input, control of the
<br>
&nbsp;display, memory management, and file handling. Special classes of
<br>
&nbsp;programs, such as interrupt handlers, device drivers, and filters, have
<br>
&nbsp;their own chapters.
<br>
<br>
&nbsp;Section 2 provides a complete reference guide to MS-DOS function calls,
<br>
&nbsp;organized so that you can see the calling sequence, results, and version
<br>
&nbsp;dependencies of each function at a glance. I have also included notes,
<br>
&nbsp;where relevant, about quirks and special uses of functions as well as
<br>
&nbsp;cross-references to related functions. An assembly-language example is
<br>
&nbsp;included for each entry in Section 2.
<br>
<br>
&nbsp;Sections 3 and 4 are references to IBM ROM BIOS, Microsoft Mouse driver,
<br>
&nbsp;and Lotus/Intel/Microsoft Expanded Memory Specification functions. The
<br>
&nbsp;entries in these two sections have the same form as in Section 2, except
<br>
&nbsp;that individual programming examples have been omitted.
<br>
<br>
&nbsp;The programs in this book were written with the marvelous Brief editor
<br>
&nbsp;from Solution Systems and assembled or compiled with Microsoft Macro
<br>
&nbsp;Assembler version 5.1 and Microsoft C Compiler version 5.1. They have been
<br>
&nbsp;tested under MS-DOS versions 2.1, 3.1, 3.3, and 4.0 on an 8088-based IBM
<br>
&nbsp;PC, an 80286-based IBM PC/AT, and an 80386-based IBM PS/2 Model 80. As far
<br>
&nbsp;as I am aware, they do not contain any software or hardware dependencies
<br>
&nbsp;that will prevent them from running properly on any IBM PC─compatible
<br>
&nbsp;machine running MS-DOS version 2.0 or later.
<br>
<br>
Changes from the First Edition
<br>
<br>
&nbsp;Readers who are familiar with the first edition will find many changes in
<br>
&nbsp;the second edition, but the general structure of the book remains the
<br>
&nbsp;same. Most of the material comparing MS-DOS to CP/M and UNIX/XENIX has
<br>
&nbsp;been removed; although these comparisons were helpful a few years ago,
<br>
&nbsp;MS-DOS has become its own universe and deserves to be considered on its
<br>
&nbsp;own terms.
<br>
<br>
&nbsp;The previously monolithic chapter on character devices has been broken
<br>
&nbsp;into three more manageable chapters focusing on the keyboard and mouse,
<br>
&nbsp;the display, and the serial port and printer. Hardware-dependent video
<br>
&nbsp;techniques have been de-emphasized; although this topic is more important
<br>
&nbsp;than ever, it has grown so complex that it requires a book of its own. A
<br>
&nbsp;new chapter discusses compatibility and portability of MS-DOS applications
<br>
&nbsp;and also contains a brief introduction to Microsoft OS/2, the new
<br>
&nbsp;multitasking, protected-mode operating system.
<br>
<br>
&nbsp;A road map to vital figures and tables has been added, following the Table
<br>
&nbsp;of Contents, to help you quickly locate the layouts of the program segment
<br>
&nbsp;prefix, file control block, and the like.
<br>
<br>
&nbsp;The reference sections at the back of the book have been extensively
<br>
&nbsp;updated and enlarged and are now complete through MS-DOS version 4.0, the
<br>
&nbsp;IBM PS/2 Model 80 ROM BIOS and the VGA video adapter, the Microsoft Mouse
<br>
&nbsp;driver version 6.0, and the Lotus/Intel/Microsoft Expanded Memory
<br>
&nbsp;Specification version 4.0.
<br>
<br>
&nbsp;In the two years since Advanced MS-DOS Programming was first published,
<br>
&nbsp;hundreds of readers have been kind enough to send me their comments, and I
<br>
&nbsp;have tried to incorporate many of their suggestions in this new edition.
<br>
&nbsp;As before, please feel free to contact me via MCI Mail (user name LMI),
<br>
&nbsp;CompuServe (user ID 72406,1577), or BIX (user name rduncan).
<br>
<br>
&nbsp;Ray Duncan &nbsp;Los Angeles, California &nbsp;September 1988
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
SECTION 1 &nbsp;PROGRAMMING FOR MS-DOS
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 1 &nbsp;Genealogy of MS-DOS
<br>
<br>
&nbsp;In only seven years, MS-DOS has evolved from a simple program loader into
<br>
&nbsp;a sophisticated, stable operating system for personal computers that are
<br>
&nbsp;based on the Intel 8086 family of microprocessors (Figure 1-1). MS-DOS
<br>
&nbsp;supports networking, graphical user interfaces, and storage devices of
<br>
&nbsp;every description; it serves as the platform for thousands of application
<br>
&nbsp;programs; and it has over 10 million licensed users──dwarfing the combined
<br>
&nbsp;user bases of all of its competitors.
<br>
<br>
&nbsp;The progenitor of MS-DOS was an operating system called 86-DOS, which was
<br>
&nbsp;written by Tim Paterson for Seattle Computer Products in mid-1980. At that
<br>
&nbsp;time, Digital Research's CP/M-80 was the operating system most commonly
<br>
&nbsp;used on microcomputers based on the Intel 8080 and Zilog Z-80
<br>
&nbsp;microprocessors, and a wide range of application software (word
<br>
&nbsp;processors, database managers, and so forth) was available for use with
<br>
&nbsp;CP/M-80.
<br>
<br>
&nbsp;To ease the process of porting 8-bit CP/M-80 applications into the new
<br>
&nbsp;16-bit environment, 86-DOS was originally designed to mimic CP/M-80 in
<br>
&nbsp;both available functions and style of operation. Consequently, the
<br>
&nbsp;structures of 86-DOS's file control blocks, program segment prefixes, and
<br>
&nbsp;executable files were nearly identical to those of CP/M-80. Existing
<br>
&nbsp;CP/M-80 programs could be converted mechanically (by processing their
<br>
&nbsp;source-code files through a special translator program) and, after
<br>
&nbsp;conversion, would run under 86-DOS either immediately or with very little
<br>
&nbsp;hand editing.
<br>
<br>
&nbsp;Because 86-DOS was marketed as a proprietary operating system for Seattle
<br>
&nbsp;Computer Products' line of S-100 bus, 8086-based microcomputers, it made
<br>
&nbsp;very little impact on the microcomputer world in general. Other vendors of
<br>
&nbsp;8086-based microcomputers were understandably reluctant to adopt a
<br>
&nbsp;competitor's operating system and continued to wait impatiently for the
<br>
&nbsp;release of Digital Research's CP/M-86.
<br>
<br>
&nbsp;In October 1980, IBM approached the major microcomputer-software houses in
<br>
&nbsp;search of an operating system for the new line of personal computers it
<br>
&nbsp;was designing. Microsoft had no operating system of its own to offer
<br>
&nbsp;(other than a stand-alone version of Microsoft BASIC) but paid a fee to
<br>
&nbsp;Seattle Computer Products for the right to sell Paterson's 86-DOS. (At
<br>
&nbsp;that time, Seattle Computer Products received a license to use and sell
<br>
&nbsp;Microsoft's languages and all 8086 versions of Microsoft's operating
<br>
&nbsp;system.) In July 1981, Microsoft purchased all rights to 86-DOS, made
<br>
&nbsp;substantial alterations to it, and renamed it MS-DOS. When the first IBM
<br>
&nbsp;PC was released in the fall of 1981, IBM offered MS-DOS (referred to as
<br>
&nbsp;PC-DOS 1.0) as its primary operating system.
<br>
<br>
&nbsp;IBM also selected Digital Research's CP/M-86 and Softech's P-system as
<br>
&nbsp;alternative operating systems for the PC. However, they were both very
<br>
&nbsp;slow to appear at IBM PC dealers and suffered the additional disadvantages
<br>
&nbsp;of higher prices and lack of available programming languages. IBM threw
<br>
&nbsp;its considerable weight behind PC-DOS by releasing all the IBM-logo PC
<br>
&nbsp;application software and development tools to run under it. Consequently,
<br>
&nbsp;most third-party software developers targeted their products for PC-DOS
<br>
&nbsp;from the start, and CP/M-86 and P-system never became significant factors
<br>
&nbsp;in the IBM PC─compatible market.
<br>
<br>
&nbsp;In spite of some superficial similarities to its ancestor CP/M-80, MS-DOS
<br>
&nbsp;version 1.0 contained a number of improvements over CP/M-80, including the
<br>
&nbsp;following:
<br>
<br>
&nbsp;■ &nbsp;An improved disk-directory structure that included information about a
<br>
&nbsp; &nbsp; file's attributes (such as whether it was a system or a hidden file),
<br>
&nbsp; &nbsp; its exact size in bytes, and the date that the file was created or last
<br>
&nbsp; &nbsp; modified
<br>
<br>
&nbsp;■ &nbsp;A superior disk-space allocation and management method, allowing
<br>
&nbsp; &nbsp; extremely fast sequential or random record access and program loading
<br>
<br>
&nbsp;■ &nbsp;An expanded set of operating-system services, including
<br>
&nbsp; &nbsp; hardware-independent function calls to set or read the date and time, a
<br>
&nbsp; &nbsp; filename parser, multiple-block record I/O, and variable record sizes
<br>
<br>
&nbsp;■ &nbsp;An AUTOEXEC.BAT batch file to perform a user-defined series of commands
<br>
&nbsp; &nbsp; when the system was started or reset
<br>
<br>
&nbsp;IBM was the only major computer manufacturer (sometimes referred to as
<br>
&nbsp;OEM, for original equipment manufacturer) to ship MS-DOS version 1.0 (as
<br>
&nbsp;PC-DOS 1.0) with its products. MS-DOS version 1.25 (equivalent to IBM
<br>
&nbsp;PC-DOS 1.1) was released in June 1982 to fix a number of bugs and also to
<br>
&nbsp;support double-sided disks and improved hardware independence in the DOS
<br>
&nbsp;kernel. This version was shipped by several vendors besides IBM, including
<br>
&nbsp;Texas Instruments, COMPAQ, and Columbia, who all entered the personal
<br>
&nbsp;computer market early. Due to rapid decreases in the prices of RAM and
<br>
&nbsp;fixed disks, MS-DOS version 1 is no longer in common use.
<br>
<br>
&nbsp;MS-DOS version 2.0 (equivalent to PC-DOS 2.0) was first released in March
<br>
&nbsp;1983. It was, in retrospect, a new operating system (though great care was
<br>
&nbsp;taken to maintain compatibility with MS-DOS version 1). It contained many
<br>
&nbsp;significant innovations and enhanced features, including those listed on
<br>
&nbsp;the following page.
<br>
<br>
&nbsp;■ &nbsp;Support for both larger-capacity floppy disks and hard disks
<br>
<br>
&nbsp;■ &nbsp;Many UNIX/XENIX-like features, including a hierarchical file structure,
<br>
&nbsp; &nbsp; file handles, I/O redirection, pipes, and filters
<br>
<br>
&nbsp;■ &nbsp;Background printing (print spooling)
<br>
<br>
&nbsp;■ &nbsp;Volume labels, plus additional file attributes
<br>
<br>
&nbsp;■ &nbsp;Installable device drivers
<br>
<br>
&nbsp;■ &nbsp;A user-customizable system-configuration file that controlled the
<br>
&nbsp; &nbsp; loading of additional device drivers, the number of system disk
<br>
&nbsp; &nbsp; buffers, and so forth
<br>
<br>
&nbsp;■ &nbsp;Maintenance of environment blocks that could be used to pass
<br>
&nbsp; &nbsp; information between programs
<br>
<br>
&nbsp;■ &nbsp;An optional ANSI display driver that allowed programs to position the
<br>
&nbsp; &nbsp; cursor and control display characteristics in a hardware-independent
<br>
&nbsp; &nbsp; manner
<br>
<br>
&nbsp;■ &nbsp;Support for the dynamic allocation, modification, and release of memory
<br>
&nbsp; &nbsp; by application programs
<br>
<br>
&nbsp;■ &nbsp;Support for customized user command interpreters (shells)
<br>
<br>
&nbsp;■ &nbsp;System tables to assist application software in modifying its currency,
<br>
&nbsp; &nbsp; time, and date formats (known as international support)
<br>
<br>
&nbsp;MS-DOS version 2.11 was subsequently released to improve international
<br>
&nbsp;support (table-driven currency symbols, date formats, decimal-point
<br>
&nbsp;symbols, currency separators, and so forth), to add support for 16-bit
<br>
&nbsp;Kanji characters throughout, and to fix a few minor bugs. Version 2.11
<br>
&nbsp;rapidly became the base version shipped for 8086/8088-based personal
<br>
&nbsp;computers by every major OEM, including Hewlett-Packard, Wang, Digital
<br>
&nbsp;Equipment Corporation, Texas Instruments, COMPAQ, and Tandy.
<br>
<br>
&nbsp;MS-DOS version 2.25, released in October 1985, was distributed in the Far
<br>
&nbsp;East but was never shipped by OEMs in the United States and Europe. In
<br>
&nbsp;this version, the international support for Japanese and Korean character
<br>
&nbsp;sets was extended even further, additional bugs were repaired, and many of
<br>
&nbsp;the system utilities were made compatible with MS-DOS version 3.0.
<br>
<br>
&nbsp;MS-DOS version 3.0 was introduced by IBM in August 1984 with the release
<br>
&nbsp;of the 80286-based PC/AT machines. It represented another major rewrite of
<br>
&nbsp;the entire operating system and included the important new features listed
<br>
&nbsp;on the following page.
<br>
<br>
&nbsp;■ &nbsp;Direct control of the print spooler by application software
<br>
<br>
&nbsp;■ &nbsp;Further expansion of international support for currency formats
<br>
<br>
&nbsp;■ &nbsp;Extended error reporting, including a code that suggests a recovery
<br>
&nbsp; &nbsp; strategy to the application program
<br>
<br>
&nbsp;■ &nbsp;Support for file and record locking and sharing
<br>
<br>
&nbsp;■ &nbsp;Support for larger fixed disks
<br>
<br>
&nbsp;MS-DOS version 3.1, which was released in November 1984, added support for
<br>
&nbsp;the sharing of files and printers across a network. Beginning with version
<br>
&nbsp;3.1, a new operating-system module called the redirector intercepts an
<br>
&nbsp;application program's requests for I/O and filters out the requests that
<br>
&nbsp;are directed to network devices, passing these requests to another machine
<br>
&nbsp;for processing.
<br>
<br>
&nbsp;Since version 3.1, the changes to MS-DOS have been evolutionary rather
<br>
&nbsp;than revolutionary. Version 3.2, which appeared in 1986, generalized the
<br>
&nbsp;definition of device drivers so that new media types (such as 3.5-inch
<br>
&nbsp;floppy disks) could be supported more easily. Version 3.3 was released in
<br>
&nbsp;1987, concurrently with the new IBM line of PS/2 personal computers, and
<br>
&nbsp;drastically expanded MS-DOS's multilanguage support for keyboard mappings,
<br>
&nbsp;printer character sets, and display fonts. Version 4.0, delivered in 1988,
<br>
&nbsp;was enhanced with a visual shell as well as support for very large file
<br>
&nbsp;systems.
<br>
<br>
&nbsp;While MS-DOS has been evolving, Microsoft has also put intense efforts
<br>
&nbsp;into the areas of user interfaces and multitasking operating systems.
<br>
&nbsp;Microsoft Windows, first shipped in 1985, provides a multitasking,
<br>
&nbsp;graphical user &quot;desktop&quot; for MS-DOS systems. Windows has won widespread
<br>
&nbsp;support among developers of complex graphics applications such as desktop
<br>
&nbsp;publishing and computer-aided design because it allows their programs to
<br>
&nbsp;take full advantage of whatever output devices are available without
<br>
&nbsp;introducing any hardware dependence.
<br>
<br>
&nbsp;Microsoft Operating System/2 (MS OS/2), released in 1987, represents a new
<br>
&nbsp;standard for application developers: a protected-mode, multitasking,
<br>
&nbsp;virtual-memory system specifically designed for applications requiring
<br>
&nbsp;high-performance graphics, networking, and interprocess communications.
<br>
&nbsp;Although MS OS/2 is a new product and is not a derivative of MS-DOS, its
<br>
&nbsp;user interface and file system are compatible with MS-DOS and Microsoft
<br>
&nbsp;Windows, and it offers the ability to run one real-mode (MS-DOS)
<br>
&nbsp;application alongside MS OS/2 protected-mode applications. This
<br>
&nbsp;compatibility allows users to move between the MS-DOS and OS/2
<br>
&nbsp;environments with a minimum of difficulty.
<br>
<br>
&nbsp;┌─────────────┐
<br>
&nbsp;│ MS-DOS 1.0 &nbsp;│ 1981: First operating system on IBM PC
<br>
&nbsp;│ PC-DOS 1.0 &nbsp;│
<br>
&nbsp;└──────┬──────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;┌────────────┐
<br>
&nbsp;│ MS-DOS 1.25 │ Double-sided disk support and bug fixes added:
<br>
&nbsp;│ PC-DOS 1.1 &nbsp;│ widely distributed by OEMs other than IBM
<br>
&nbsp;└──────┬──────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;┌────────────┐ 1983: Introduced with IBM PC/XT;
<br>
&nbsp;│ MS-DOS 2.0 &nbsp;│ support for UNIX/XENIX-like hierarchical
<br>
&nbsp;│ PC-DOS 2.0 &nbsp;│ file structure and hard disks added
<br>
&nbsp;└──────┬──────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├──────────────────────────────────────┐
<br>
&nbsp;┌────────────┐ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;┌────────────┐
<br>
&nbsp;│ MS-DOS 2.01 │ 2.0 with international │ PC-DOS 2.1 &nbsp;│ Introduced with PCjr;
<br>
&nbsp;└──────┬──────┘ support &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;└─────────────┘ 2.0 with bug fixes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;┌────────────┐
<br>
&nbsp;│ MS-DOS 2.11 │ 2.01 with bug fixes
<br>
&nbsp;└──────┬──────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├──────────────────────────────────────┐
<br>
&nbsp;┌────────────┐ 1984: Introduced with &nbsp;┌────────────┐ 1985: Far East OEMs;
<br>
&nbsp;│ MS-DOS 3.0 &nbsp;│ PC/AT; support for &nbsp; &nbsp; │ MS-DOS 2.25 │ support for extended
<br>
&nbsp;│ PC-DOS 3.0 &nbsp;│ 1.2 MB floppy disk, &nbsp; &nbsp;└─────────────┘ character sets
<br>
&nbsp;└──────┬──────┘ larger hard disk added
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;┌────────────┐
<br>
&nbsp;│ MS-DOS 3.1 &nbsp;│ Support for Microsoft &nbsp;┌─────────────┐ 1985: Graphical
<br>
&nbsp;│ PC-DOS 3.1 &nbsp;│ Networks added &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; Windows &nbsp; │ user interface
<br>
&nbsp;└──────┬──────┘ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; 1.0 &nbsp; &nbsp; │ for MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; └──────┬──────┘
<br>
&nbsp;┌────────────┐ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;│ MS-DOS 3.2 &nbsp;│ 1986: Support for 3.5- &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;│ PC-DOS 3.2 &nbsp;│ inch disks added &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;└──────┬──────┘ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ┌────────────┐ 1987: Compatibility
<br>
&nbsp;┌────────────┐ 1987: Introduced with &nbsp;│ &nbsp; Windows &nbsp; │ with OS/2
<br>
&nbsp;│ MS-DOS 3.3 &nbsp;│ IBM PS/2; generalized &nbsp;│ &nbsp; &nbsp; 2.0 &nbsp; &nbsp; │ Presentation Manager
<br>
&nbsp;│ PC-DOS 3.3 &nbsp;│ code-page (font) &nbsp; &nbsp; &nbsp; └─────────────┘
<br>
&nbsp;└──────┬──────┘ support
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;┌────────────┐ 1988: Support for
<br>
&nbsp;│ MS-DOS 4.0 &nbsp;│ logical volumes larger
<br>
&nbsp;│ PC-DOS 4.0 &nbsp;│ than 32 MB; visual shell
<br>
&nbsp;└─────────────┘
<br>
<br>
&nbsp;Figure 1-1. &nbsp;The evolution of MS-DOS.
<br>
<br>
&nbsp;What does the future hold for MS-DOS? Only the long-range planning teams
<br>
&nbsp;at Microsoft and IBM know for sure. But it seems safe to assume that
<br>
&nbsp;MS-DOS, with its relatively small memory requirements, adaptability to
<br>
&nbsp;diverse hardware configurations, and enormous base of users, will remain
<br>
&nbsp;important to programmers and software publishers for years to come.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 2 &nbsp;MS-DOS in Operation
<br>
<br>
&nbsp;It is unlikely that you will ever be called upon to configure the MS-DOS
<br>
&nbsp;software for a new model of computer. Still, an acquaintance with the
<br>
&nbsp;general structure of MS-DOS can often be very helpful in understanding the
<br>
&nbsp;behavior of the system as a whole. In this chapter, we will discuss how
<br>
&nbsp;MS-DOS is organized and how it is loaded into memory when the computer is
<br>
&nbsp;turned on.
<br>
<br>
<br>
The Structure of MS-DOS
<br>
<br>
&nbsp;MS-DOS is partitioned into several layers that serve to isolate the kernel
<br>
&nbsp;logic of the operating system, and the user's perception of the system,
<br>
&nbsp;from the hardware it is running on. These layers are
<br>
<br>
&nbsp;■ &nbsp;The BIOS (Basic Input/Output System)
<br>
<br>
&nbsp;■ &nbsp;The DOS kernel
<br>
<br>
&nbsp;■ &nbsp;The command processor (shell)
<br>
<br>
&nbsp;We'll discuss the functions of each of these layers separately.
<br>
<br>
The BIOS Module
<br>
<br>
&nbsp;The BIOS is specific to the individual computer system and is provided by
<br>
&nbsp;the manufacturer of the system. It contains the default resident
<br>
&nbsp;hardware-dependent drivers for the following devices:
<br>
<br>
&nbsp;■ &nbsp;Console display and keyboard (CON)
<br>
<br>
&nbsp;■ &nbsp;Line printer (PRN)
<br>
<br>
&nbsp;■ &nbsp;Auxiliary device (AUX)
<br>
<br>
&nbsp;■ &nbsp;Date and time (CLOCK$)
<br>
<br>
&nbsp;■ &nbsp;Boot disk device (block device)
<br>
<br>
&nbsp;The MS-DOS kernel communicates with these device drivers through I/O
<br>
&nbsp;request packets; the drivers then translate these requests into the proper
<br>
&nbsp;commands for the various hardware controllers. In many MS-DOS systems,
<br>
&nbsp;including the IBM PC, the most primitive parts of the hardware drivers are
<br>
&nbsp;located in read-only memory (ROM) so that they can be used by stand-alone
<br>
&nbsp;applications, diagnostics, and the system startup program.
<br>
<br>
&nbsp;The terms resident and installable are used to distinguish between the
<br>
&nbsp;drivers built into the BIOS and the drivers installed during system
<br>
&nbsp;initialization by DEVICE commands in the CONFIG.SYS file. (Installable
<br>
&nbsp;drivers will be discussed in more detail later in this chapter and in
<br>
&nbsp;Chapter 14.)
<br>
<br>
&nbsp;The BIOS is read into random-access memory (RAM) during system
<br>
&nbsp;initialization as part of a file named IO.SYS. (In PC-DOS, the file is
<br>
&nbsp;called IBMBIO.COM.) This file is marked with the special attributes hidden
<br>
&nbsp;and system.
<br>
<br>
The DOS Kernel
<br>
<br>
&nbsp;The DOS kernel implements MS-DOS as it is seen by application programs.
<br>
&nbsp;The kernel is a proprietary program supplied by Microsoft Corporation and
<br>
&nbsp;provides a collection of hardware-independent services called system
<br>
&nbsp;functions. These functions include the following:
<br>
<br>
&nbsp;■ &nbsp;File and record management
<br>
<br>
&nbsp;■ &nbsp;Memory management
<br>
<br>
&nbsp;■ &nbsp;Character-device input/output
<br>
<br>
&nbsp;■ &nbsp;Spawning of other programs
<br>
<br>
&nbsp;■ &nbsp;Access to the real-time clock
<br>
<br>
&nbsp;Programs can access system functions by loading registers with
<br>
&nbsp;function-specific parameters and then transferring to the operating system
<br>
&nbsp;by means of a software interrupt.
<br>
<br>
&nbsp;The DOS kernel is read into memory during system initialization from the
<br>
&nbsp;MSDOS.SYS file on the boot disk. (The file is called IBMDOS.COM in
<br>
&nbsp;PC-DOS.) This file is marked with the attributes hidden and system.
<br>
<br>
The Command Processor
<br>
<br>
&nbsp;The command processor, or shell, is the user's interface to the operating
<br>
&nbsp;system. It is responsible for parsing and carrying out user commands,
<br>
&nbsp;including the loading and execution of other programs from a disk or other
<br>
&nbsp;mass-storage device.
<br>
<br>
&nbsp;The default shell that is provided with MS-DOS is found in a file called
<br>
&nbsp;COMMAND.COM. Although COMMAND.COM prompts and responses constitute the
<br>
&nbsp;ordinary user's complete perception of MS-DOS, it is important to realize
<br>
&nbsp;that COMMAND.COM is not the operating system, but simply a special class
<br>
&nbsp;of program running under the control of MS-DOS.
<br>
<br>
&nbsp;COMMAND.COM can be replaced with a shell of the programmer's own design by
<br>
&nbsp;simply adding a SHELL directive to the system-configuration file
<br>
&nbsp;(CONFIG.SYS) on the system startup disk. The product COMMAND-PLUS from ESP
<br>
&nbsp;Systems is an example of such an alternative shell.
<br>
<br>
&nbsp;More about COMMAND.COM
<br>
<br>
&nbsp;The default MS-DOS shell, COMMAND.COM, is divided into three parts:
<br>
<br>
&nbsp;■ &nbsp;A resident portion
<br>
<br>
&nbsp;■ &nbsp;An initialization section
<br>
<br>
&nbsp;■ &nbsp;A transient module
<br>
<br>
&nbsp;The resident portion is loaded in lower memory, above the DOS kernel and
<br>
&nbsp;its buffers and tables. It contains the routines to process Ctrl-C and
<br>
&nbsp;Ctrl-Break, critical errors, and the termination (final exit) of other
<br>
&nbsp;transient programs. This part of COMMAND.COM issues error messages and is
<br>
&nbsp;responsible for the familiar prompt
<br>
<br>
&nbsp;Abort, Retry, Ignore?
<br>
<br>
&nbsp;The resident portion also contains the code required to reload the
<br>
&nbsp;transient portion of COMMAND.COM when necessary.
<br>
<br>
&nbsp;The initialization section of COMMAND.COM is loaded above the resident
<br>
&nbsp;portion when the system is started. It processes the AUTOEXEC.BAT batch
<br>
&nbsp;file (the user's list of commands to execute at system startup), if one is
<br>
&nbsp;present, and is then discarded.
<br>
<br>
&nbsp;The transient portion of COMMAND.COM is loaded at the high end of memory,
<br>
&nbsp;and its memory can also be used for other purposes by application
<br>
&nbsp;programs. The transient module issues the user prompt, reads the commands
<br>
&nbsp;from the keyboard or batch file, and causes them to be executed. When an
<br>
&nbsp;application program terminates, the resident portion of COMMAND.COM does a
<br>
&nbsp;checksum of the transient module to determine whether it has been
<br>
&nbsp;destroyed and fetches a fresh copy from the disk if necessary.
<br>
<br>
&nbsp;The user commands that are accepted by COMMAND.COM fall into three
<br>
&nbsp;categories:
<br>
<br>
&nbsp;■ &nbsp;Internal commands
<br>
<br>
&nbsp;■ &nbsp;External commands
<br>
<br>
&nbsp;■ &nbsp;Batch files
<br>
<br>
&nbsp;Internal commands, sometimes called intrinsic commands, are those carried
<br>
&nbsp;out by code embedded in COMMAND.COM itself. Commands in this category
<br>
&nbsp;include COPY, REN(AME), DIR(ECTORY), and DEL(ETE). The routines for the
<br>
&nbsp;internal commands are included in the transient part of COMMAND.COM.
<br>
<br>
&nbsp;External commands, sometimes called extrinsic commands or transient
<br>
&nbsp;programs, are the names of programs stored in disk files. Before these
<br>
&nbsp;programs can be executed, they must be loaded from the disk into the
<br>
&nbsp;transient program area (TPA) of memory. (See &quot;How MS-DOS Is Loaded&quot; in
<br>
&nbsp;this chapter.) Familiar examples of external commands are CHKDSK, BACKUP,
<br>
&nbsp;and RESTORE. As soon as an external command has completed its work, it is
<br>
&nbsp;discarded from memory; hence, it must be reloaded from disk each time it
<br>
&nbsp;is invoked.
<br>
<br>
&nbsp;Batch files are text files that contain lists of other intrinsic,
<br>
&nbsp;extrinsic, or batch commands. These files are processed by a special
<br>
&nbsp;interpreter that is built into the transient portion of COMMAND.COM. The
<br>
&nbsp;interpreter reads the batch file one line at a time and carries out each
<br>
&nbsp;of the specified operations in order.
<br>
<br>
&nbsp;In order to interpret a user's command, COMMAND.COM first looks to see if
<br>
&nbsp;the user typed the name of a built-in (intrinsic) command that it can
<br>
&nbsp;carry out directly. If not, it searches for an external command
<br>
&nbsp;(executable program file) or batch file by the same name. The search is
<br>
&nbsp;carried out first in the current directory of the current disk drive and
<br>
&nbsp;then in each of the directories specified in the most recent PATH command.
<br>
&nbsp;In each directory inspected, COMMAND.COM first tries to find a file with
<br>
&nbsp;the extension .COM, then .EXE, and finally .BAT. If the search fails for
<br>
&nbsp;all three file types in all of the possible locations, COMMAND.COM
<br>
&nbsp;displays the familiar message
<br>
<br>
&nbsp;Bad command or file name
<br>
<br>
&nbsp;If a .COM file or a .EXE file is found, COMMAND.COM uses the MS-DOS EXEC
<br>
&nbsp;function to load and execute it. The EXEC function builds a special data
<br>
&nbsp;structure called a program segment prefix (PSP) above the resident portion
<br>
&nbsp;of COMMAND.COM in the transient program area. The PSP contains various
<br>
&nbsp;linkages and pointers needed by the application program. Next, the EXEC
<br>
&nbsp;function loads the program itself, just above the PSP, and performs any
<br>
&nbsp;relocation that may be necessary. Finally, it sets up the registers
<br>
&nbsp;appropriately and transfers control to the entry point for the program.
<br>
&nbsp;(Both the PSP and the EXEC function will be discussed in more detail in
<br>
&nbsp;Chapters 3 and 12.) When the transient program has finished its job, it
<br>
&nbsp;calls a special MS-DOS termination function that releases the transient
<br>
&nbsp;program's memory and returns control to the program that caused the
<br>
&nbsp;transient program to be loaded (COMMAND.COM, in this case).
<br>
<br>
&nbsp;A transient program has nearly complete control of the system's resources
<br>
&nbsp;while it is executing. The only other tasks that are accomplished are
<br>
&nbsp;those performed by interrupt handlers (such as the keyboard input driver
<br>
&nbsp;and the real-time clock) and operations that the transient program
<br>
&nbsp;requests from the operating system. MS-DOS does not support sharing of the
<br>
&nbsp;central processor among several tasks executing concurrently, nor can it
<br>
&nbsp;wrest control away from a program when it crashes or executes for too
<br>
&nbsp;long. Such capabilities are the province of MS OS/2, which is a
<br>
&nbsp;protected-mode system with preemptive multitasking (time-slicing).
<br>
<br>
<br>
How MS-DOS Is Loaded
<br>
<br>
&nbsp;When the system is started or reset, program execution begins at address
<br>
&nbsp;0FFFF0H. This is a feature of the 8086/8088 family of microprocessors and
<br>
&nbsp;has nothing to do with MS-DOS. Systems based on these processors are
<br>
&nbsp;designed so that address 0FFFF0H lies within an area of ROM and contains a
<br>
&nbsp;jump machine instruction to transfer control to system test code and the
<br>
&nbsp;ROM bootstrap routine (Figure 2-1).
<br>
<br>
&nbsp;The ROM bootstrap routine reads the disk bootstrap routine from the first
<br>
&nbsp;sector of the system startup disk (the boot sector) into memory at some
<br>
&nbsp;arbitrary address and then transfers control to it (Figure 2-2). (The
<br>
&nbsp;boot sector also contains a table of information about the disk format.)
<br>
<br>
&nbsp;The disk bootstrap routine checks to see if the disk contains a copy of
<br>
&nbsp;MS-DOS. It does this by reading the first sector of the root directory and
<br>
&nbsp;determining whether the first two files are IO.SYS and MSDOS.SYS (or
<br>
&nbsp;IBMBIO.COM and IBMDOS.COM), in that order. If these files are not present,
<br>
&nbsp;the user is prompted to change disks and strike any key to try again.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌───────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM bootstrap routine &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤  Top of RAM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; └──────────────────────┐ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌────────────────────┐ └────────────────────────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;└──────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00400H ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Interrupt vectors &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00000H └───────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 2-1. &nbsp;A typical 8086/8088-based computer system immediately after
<br>
&nbsp;system startup or reset. Execution begins at location 0FFFF0H, which
<br>
&nbsp;contains a jump instruction that directs program control to the ROM
<br>
&nbsp;bootstrap routine.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌───────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM bootstrap routine &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤  Top of RAM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Disk bootstrap routine &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤  Arbitrary
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; load location
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; └──────────────────────┐ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌────────────────────┐ └────────────────────────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;└──────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00400H ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Interrupt vectors &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00000H └───────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 2-2. &nbsp;The ROM bootstrap routine loads the disk bootstrap routine
<br>
&nbsp;into memory from the first sector of the system startup disk and then
<br>
&nbsp;transfers control to it.
<br>
<br>
&nbsp;If the two system files are found, the disk bootstrap reads them into
<br>
&nbsp;memory and transfers control to the initial entry point of IO.SYS (Figure
<br>
&nbsp;2-3). (In some implementations, the disk bootstrap reads only IO.SYS into
<br>
&nbsp;memory, and IO.SYS in turn loads the MSDOS.SYS file.)
<br>
<br>
&nbsp;The IO.SYS file that is loaded from the disk actually consists of two
<br>
&nbsp;separate modules. The first is the BIOS, which contains the linked set of
<br>
&nbsp;resident device drivers for the console, auxiliary port, printer, block,
<br>
&nbsp;and clock devices, plus some hardware-specific initialization code that is
<br>
&nbsp;run only at system startup. The second module, SYSINIT, is supplied by
<br>
&nbsp;Microsoft and linked into the IO.SYS file, along with the BIOS, by the
<br>
&nbsp;computer manufacturer.
<br>
<br>
&nbsp;SYSINIT is called by the manufacturer's BIOS initialization code. It
<br>
&nbsp;determines the amount of contiguous memory present in the system and then
<br>
&nbsp;relocates itself to high memory. Then it moves the DOS kernel, MSDOS.SYS,
<br>
&nbsp;from its original load location to its final memory location, overlaying
<br>
&nbsp;the original SYSINIT code and any other expendable initialization code
<br>
&nbsp;that was contained in the IO.SYS file (Figure 2-4).
<br>
<br>
&nbsp;Next, SYSINIT calls the initialization code in MSDOS.SYS. The DOS kernel
<br>
&nbsp;initializes its internal tables and work areas, sets up the interrupt
<br>
&nbsp;vectors 20H through 2FH, and traces through the linked list of resident
<br>
&nbsp;device drivers, calling the initialization function for each. (See Chapter
<br>
&nbsp;14.)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌───────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ROM bootstrap routine &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤  Top of RAM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Disk bootstrap routine &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; └──────────────────────┐ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌────────────────────┐ └────────────────────────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;└──────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DOS kernel (from MSDOS.SYS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤  In temporary
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SYSINIT (from IO.SYS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; location
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BIOS (from IO.SYS) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00400H ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Interrupt vectors &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00000H └───────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 2-3. &nbsp;The disk bootstrap reads the file IO.SYS into memory. This
<br>
&nbsp;file contains the MS-DOS BIOS (resident device drivers) and the SYSINIT
<br>
&nbsp;module. Either the disk bootstrap or the BIOS (depending upon the
<br>
&nbsp;manufacturer's implementation) then reads the DOS kernel into memory from
<br>
&nbsp;the MSDOS.SYS file.
<br>
<br>
&nbsp;These driver functions determine the equipment status, perform any
<br>
&nbsp;necessary hardware initialization, and set up the vectors for any external
<br>
&nbsp;hardware interrupts the drivers will service.
<br>
<br>
&nbsp;As part of the initialization sequence, the DOS kernel examines the
<br>
&nbsp;disk-parameter blocks returned by the resident block-device drivers,
<br>
&nbsp;determines the largest sector size that will be used in the system, builds
<br>
&nbsp;some drive-parameter blocks, and allocates a disk sector buffer. Control
<br>
&nbsp;then returns to SYSINIT.
<br>
<br>
&nbsp;When the DOS kernel has been initialized and all resident device drivers
<br>
&nbsp;are available, SYSINIT can call on the normal MS-DOS file services to open
<br>
&nbsp;the CONFIG.SYS file. This optional file can contain a variety of commands
<br>
&nbsp;that enable the user to customize the MS-DOS environment. For instance,
<br>
&nbsp;the user can specify additional hardware device drivers, the number of
<br>
&nbsp;disk buffers, the maximum number of files that can be open at one time,
<br>
&nbsp;and the filename of the command processor (shell).
<br>
<br>
&nbsp;If it is found, the entire CONFIG.SYS file is loaded into memory for
<br>
&nbsp;processing. All lowercase characters are converted to uppercase, and the
<br>
&nbsp;file is interpreted one line at a time to process the commands. Memory is
<br>
&nbsp;allocated for the disk buffer cache and the internal file control blocks
<br>
&nbsp;used by the handle file and record system functions. (See Chapter 8.) Any
<br>
&nbsp;device drivers indicated in the CONFIG.SYS file are sequentially loaded
<br>
&nbsp;into memory, initialized by calls to their init modules, and linked into
<br>
&nbsp;the device-driver list. The init function of each driver tells SYSINIT how
<br>
&nbsp;much memory to reserve for that driver.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌───────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM bootstrap routine &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤  Top of RAM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SYSINIT module &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; └──────────────────────┐ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌────────────────────┐ └────────────────────────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;└──────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Installable drivers &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;File control blocks &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Disk buffer cache &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DOS kernel &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤  In final
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BIOS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; location
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp;00400H ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Interrupt vectors &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00000H └───────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 2-4. &nbsp;SYSINIT moves itself to high memory and relocates the DOS
<br>
&nbsp;kernel, MSDOS.SYS, downward to its final address. The MS-DOS disk buffer
<br>
&nbsp;cache and file control block areas are allocated, and then the installable
<br>
&nbsp;device drivers specified in the CONFIG.SYS file are loaded and linked into
<br>
&nbsp;the system.
<br>
<br>
&nbsp;After all installable device drivers have been loaded, SYSINIT closes all
<br>
&nbsp;file handles and reopens the console (CON), printer (PRN), and auxiliary
<br>
&nbsp;(AUX) devices as the standard input, standard output, standard error,
<br>
&nbsp;standard list, and standard auxiliary devices. This allows a
<br>
&nbsp;user-installed character-device driver to override the BIOS's resident
<br>
&nbsp;drivers for the standard devices.
<br>
<br>
&nbsp;Finally, SYSINIT calls the MS-DOS EXEC function to load the command
<br>
&nbsp;interpreter, or shell. (The default shell is COMMAND.COM, but another
<br>
&nbsp;shell can be substituted by means of the CONFIG.SYS file.) Once the shell
<br>
&nbsp;is loaded, it displays a prompt and waits for the user to enter a command.
<br>
&nbsp;MS-DOS is now ready for business, and the SYSINIT module is discarded
<br>
&nbsp;(Figure 2-5).
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌───────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM bootstrap routine &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤  Top of RAM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; Transient part of COMMAND.COM &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; └──────────────────────┐ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌────────────────────┐ └────────────────────────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;└──────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Transient program area &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; Resident part of COMMAND.COM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Installable drivers &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;File control blocks &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Disk buffer cache &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DOS kernel &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BIOS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00400H ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Interrupt vectors &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00000H └───────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 2-5. &nbsp;The final result of the MS-DOS startup process for a typical
<br>
&nbsp;system. The resident portion of COMMAND.COM lies in low memory, above the
<br>
&nbsp;DOS kernel. The transient portion containing the batch-file interpreter
<br>
&nbsp;and intrinsic commands is placed in high memory, where it can be overlaid
<br>
&nbsp;by extrinsic commands and application programs running in the transient
<br>
&nbsp;program area.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 3 &nbsp;Structure of MS-DOS Application Programs
<br>
<br>
&nbsp;Programs that run under MS-DOS come in two basic flavors: .COM programs,
<br>
&nbsp;which have a maximum size of approximately 64 KB, and .EXE programs, which
<br>
&nbsp;can be as large as available memory. In Intel 8086 parlance, .COM programs
<br>
&nbsp;fit the tiny model, in which all segment registers contain the same value;
<br>
&nbsp;that is, the code and data are mixed together. In contrast, .EXE programs
<br>
&nbsp;fit the small, medium, or large model, in which the segment registers
<br>
&nbsp;contain different values; that is, the code, data, and stack reside in
<br>
&nbsp;separate segments. .EXE programs can have multiple code and data segments,
<br>
&nbsp;which are respectively addressed by long calls and by manipulation of the
<br>
&nbsp;data segment (DS) register.
<br>
<br>
&nbsp;A .COM-type program resides on the disk as an absolute memory image, in a
<br>
&nbsp;file with the extension .COM. The file does not have a header or any other
<br>
&nbsp;internal identifying information. A .EXE program, on the other hand,
<br>
&nbsp;resides on the disk in a special type of file with a unique header, a
<br>
&nbsp;relocation map, a checksum, and other information that is (or can be) used
<br>
&nbsp;by MS-DOS.
<br>
<br>
&nbsp;Both .COM and .EXE programs are brought into memory for execution by the
<br>
&nbsp;same mechanism: the EXEC function, which constitutes the MS-DOS loader.
<br>
&nbsp;EXEC can be called with the filename of a program to be loaded by
<br>
&nbsp;COMMAND.COM (the normal MS-DOS command interpreter), by other shells or
<br>
&nbsp;user interfaces, or by another program that was previously loaded by EXEC.
<br>
&nbsp;If there is sufficient free memory in the transient program area, EXEC
<br>
&nbsp;allocates a block of memory to hold the new program, builds the program
<br>
&nbsp;segment prefix (PSP) at its base, and then reads the program into memory
<br>
&nbsp;immediately above the PSP. Finally, EXEC sets up the segment registers and
<br>
&nbsp;the stack and transfers control to the program.
<br>
<br>
&nbsp;When it is invoked, EXEC can be given the addresses of additional
<br>
&nbsp;information, such as a command tail, file control blocks, and an
<br>
&nbsp;environment block; if supplied, this information will be passed on to the
<br>
&nbsp;new program. (The exact procedure for using the EXEC function in your own
<br>
&nbsp;programs is discussed, with examples, in Chapter 12.)
<br>
<br>
&nbsp;.COM and .EXE programs are often referred to as transient programs. A
<br>
&nbsp;transient program &quot;owns&quot; the memory block it has been allocated and has
<br>
&nbsp;nearly total control of the system's resources while it is executing. When
<br>
&nbsp;the program terminates, either because it is aborted by the operating
<br>
&nbsp;system or because it has completed its work and systematically performed a
<br>
&nbsp;final exit back to MS-DOS, the memory block is then freed (hence the term
<br>
&nbsp;transient) and can be used by the next program in line to be loaded.
<br>
<br>
<br>
The Program Segment Prefix
<br>
<br>
&nbsp;A thorough understanding of the program segment prefix is vital to
<br>
&nbsp;successful programming under MS-DOS. It is a reserved area, 256 bytes
<br>
&nbsp;long, that is set up by MS-DOS at the base of the memory block allocated
<br>
&nbsp;to a transient program. The PSP contains some linkages to MS-DOS that can
<br>
&nbsp;be used by the transient program, some information MS-DOS saves for its
<br>
&nbsp;own purposes, and some information MS-DOS passes to the transient
<br>
&nbsp;program──to be used or not, as the program requires (Figure 3-1).
<br>
<br>
&nbsp;Offset
<br>
&nbsp;0000H ┌────────────────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Int 20H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;0002H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Segment, end of allocation block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;0004H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;0005H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp;Long call to MS-DOS function dispatcher &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;000AH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp;Previous contents of termination handler &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interrupt vector (Int 22H) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;000EH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ Previous contents of Ctrl-C interrupt vector (Int 23H) │
<br>
&nbsp;0012H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;Previous contents of critical-error handler &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interrupt vector (Int 24H) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;0016H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;002CH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Segment address of environment block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;002EH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;005CH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Default file control block #1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;006CH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Default file control block #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(overlaid if FCB #1 opened) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;008OH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;└──────────────────────────┐ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp;┌────────────────────────┐ └─────────────────────────────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;└───────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp;Command tail and default disk transfer area (buffer) &nbsp;│
<br>
&nbsp;OOFFH └────────────────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 3-1. &nbsp;The structure of the program segment prefix.
<br>
<br>
&nbsp;In the first versions of MS-DOS, the PSP was designed to be compatible
<br>
&nbsp;with a control area that was built beneath transient programs under
<br>
&nbsp;Digital Research's venerable CP/M operating system, so that programs could
<br>
&nbsp;be ported to MS-DOS without extensive logical changes. Although MS-DOS has
<br>
&nbsp;evolved considerably since those early days, the structure of the PSP is
<br>
&nbsp;still recognizably similar to its CP/M equivalent. For example, offset
<br>
&nbsp;0000H in the PSP contains a linkage to the MS-DOS process-termination
<br>
&nbsp;handler, which cleans up after the program has finished its job and
<br>
&nbsp;performs a final exit. Similarly, offset 0005H in the PSP contains a
<br>
&nbsp;linkage to the MS-DOS function dispatcher, which performs disk operations,
<br>
&nbsp;console input/output, and other such services at the request of the
<br>
&nbsp;transient program. Thus, calls to PSP:0000 and PSP:0005 have the same
<br>
&nbsp;effect as CALL 0000 and CALL 0005 under CP/M. (These linkages are not the
<br>
&nbsp;&quot;approved&quot; means of obtaining these services, however.)
<br>
<br>
&nbsp;The word at offset 0002H in the PSP contains the segment address of the
<br>
&nbsp;top of the transient program's allocated memory block. The program can use
<br>
&nbsp;this value to determine whether it should request more memory to do its
<br>
&nbsp;job or whether it has extra memory that it can release for use by other
<br>
&nbsp;processes.
<br>
<br>
&nbsp;Offsets 000AH through 0015H in the PSP contain the previous contents of
<br>
&nbsp;the interrupt vectors for the termination, Ctrl-C, and critical-error
<br>
&nbsp;handlers. If the transient program alters these vectors for its own
<br>
&nbsp;purposes, MS-DOS restores the original values saved in the PSP when the
<br>
&nbsp;program terminates.
<br>
<br>
&nbsp;The word at PSP offset 002CH holds the segment address of the environment
<br>
&nbsp;block, which contains a series of ASCIIZ strings (sequences of ASCII
<br>
&nbsp;characters terminated by a null, or zero, byte). The environment block is
<br>
&nbsp;inherited from the program that called the EXEC function to load the
<br>
&nbsp;currently executing program. It contains such information as the current
<br>
&nbsp;search path used by COMMAND.COM to find executable programs, the location
<br>
&nbsp;on the disk of COMMAND.COM itself, and the format of the user prompt used
<br>
&nbsp;by COMMAND.COM.
<br>
<br>
&nbsp;The command tail──the remainder of the command line that invoked the
<br>
&nbsp;transient program, after the program's name──is copied into the PSP
<br>
&nbsp;starting at offset 0081H. The length of the command tail, not including
<br>
&nbsp;the return character at its end, is placed in the byte at offset 0080H.
<br>
&nbsp;Redirection or piping parameters and their associated filenames do not
<br>
&nbsp;appear in the portion of the command line (the command tail) that is
<br>
&nbsp;passed to the transient program, because redirection is transparent to
<br>
&nbsp;applications.
<br>
<br>
&nbsp;To provide compatibility with CP/M, MS-DOS parses the first two parameters
<br>
&nbsp;in the command tail into two default file control blocks (FCBs) at
<br>
&nbsp;PSP:005CH and PSP:006CH, under the assumption that they may be filenames.
<br>
&nbsp;However, if the parameters are filenames that include a path
<br>
&nbsp;specification, only the drive code will be valid in these default FCBs,
<br>
&nbsp;because FCB-type file- and record-access functions do not support
<br>
&nbsp;hierarchical file structures. Although the default FCBs were an aid in
<br>
&nbsp;earlier years, when compatibility with CP/M was more of a concern, they
<br>
&nbsp;are essentially useless in modern MS-DOS application programs that must
<br>
&nbsp;provide full path support. (File control blocks are discussed in detail in
<br>
&nbsp;Chapter 8 and hierarchical file structures are discussed in Chapter 9.)
<br>
<br>
&nbsp;The 128-byte area from 0080H through 00FFH in the PSP also serves as the
<br>
&nbsp;default disk transfer area (DTA), which is set by MS-DOS before passing
<br>
&nbsp;control to the transient program. If the program does not explicitly
<br>
&nbsp;change the DTA, any file read or write operations requested with the FCB
<br>
&nbsp;group of function calls automatically use this area as a data buffer. This
<br>
&nbsp;is rarely useful and is another facet of MS-DOS's handling of the PSP that
<br>
&nbsp;is present only for compatibility with CP/M.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;WARNING
<br>
&nbsp; &nbsp;Programs must not alter any part of the PSP below offset 005CH.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
Introduction to .COM Programs
<br>
<br>
&nbsp;Programs of the .COM persuasion are stored in disk files that hold an
<br>
&nbsp;absolute image of the machine instructions to be executed. Because the
<br>
&nbsp;files contain no relocation information, they are more compact, and are
<br>
&nbsp;loaded for execution slightly faster, than equivalent .EXE files. Note
<br>
&nbsp;that MS-DOS does not attempt to ascertain whether a .COM file actually
<br>
&nbsp;contains executable code (there is no signature or checksum, as in the
<br>
&nbsp;case of a .EXE file); it simply brings any file with the .COM extension
<br>
&nbsp;into memory and jumps to it.
<br>
<br>
&nbsp;Because .COM programs are loaded immediately above the program segment
<br>
&nbsp;prefix and do not have a header that can specify another entry point, they
<br>
&nbsp;must always have an origin of 0100H, which is the length of the PSP.
<br>
&nbsp;Location 0100H must contain an executable instruction. The maximum length
<br>
&nbsp;of a .COM program is 65,536 bytes, minus the length of the PSP (256 bytes)
<br>
&nbsp;and a mandatory word of stack (2 bytes).
<br>
<br>
&nbsp;When control is transferred to the .COM program from MS-DOS, all of the
<br>
&nbsp;segment registers point to the PSP (Figure 3-2). The stack pointer
<br>
&nbsp;register contains 0FFFEH if memory allows; otherwise, it is set as high as
<br>
&nbsp;possible in memory minus 2 bytes. (MS-DOS pushes a zero word on the stack
<br>
&nbsp;before entry.)
<br>
<br>
&nbsp; &nbsp; SS:SP &nbsp;┌────────────────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; Stack grows downward from top of segment &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Program code and data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;CS:0100H &nbsp;├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Program segment prefix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;CS:0000H &nbsp;└────────────────────────────────────────────────────────┘
<br>
&nbsp;DS:0000H
<br>
&nbsp;ES:0000H
<br>
&nbsp;SS:0000H
<br>
<br>
&nbsp;Figure 3-2. &nbsp;A memory image of a typical .COM-type program after loading.
<br>
&nbsp;The contents of the .COM file are brought into memory just above the
<br>
&nbsp;program segment prefix. Program, code, and data are mixed together in the
<br>
&nbsp;same segment, and all segment registers contain the same value.
<br>
<br>
&nbsp;Although the size of an executable .COM file can't exceed 64 KB, the
<br>
&nbsp;current versions of MS-DOS allocate all of the transient program area to
<br>
&nbsp;.COM programs when they are loaded. Because many such programs date from
<br>
&nbsp;the early days of MS-DOS and are not necessarily &quot;well-behaved&quot; in their
<br>
&nbsp;approach to memory management, the operating system simply makes the
<br>
&nbsp;worst-case assumption and gives .COM programs everything that is
<br>
&nbsp;available. If a .COM program wants to use the EXEC function to invoke
<br>
&nbsp;another process, it must first shrink down its memory allocation to the
<br>
&nbsp;minimum memory it needs in order to continue, taking care to protect its
<br>
&nbsp;stack. (This is discussed in more detail in Chapter 12.)
<br>
<br>
&nbsp;When a .COM program finishes executing, it can return control to MS-DOS by
<br>
&nbsp;several means. The preferred method is Int 21H Function 4CH, which allows
<br>
&nbsp;the program to pass a return code back to the program, shell, or batch
<br>
&nbsp;file that invoked it. However, if the program is running under MS-DOS
<br>
&nbsp;version 1, it must exit by means of Int 20H, Int 21H Function 0, or a
<br>
&nbsp;NEAR RETURN. (Because a word of zero was pushed onto the stack at entry, a
<br>
&nbsp;NEAR RETURN causes a transfer to PSP:0000, which contains an Int 20H
<br>
&nbsp;instruction.)
<br>
<br>
&nbsp;A .COM-type application can be linked together from many separate object
<br>
&nbsp;modules. All of the modules must use the same code-segment name and class
<br>
&nbsp;name, and the module with the entry point at offset 0100H within the
<br>
&nbsp;segment must be linked first. In addition, all of the procedures within a
<br>
&nbsp;.COM program should have the NEAR attribute, because all executable code
<br>
&nbsp;resides in one segment.
<br>
<br>
&nbsp;When linking a .COM program, the linker will display the message
<br>
<br>
&nbsp;Warning: no stack segment
<br>
<br>
&nbsp;This message can be ignored. The linker output is a .EXE file, which must
<br>
&nbsp;be converted into a .COM file with the MS-DOS EXE2BIN utility before
<br>
&nbsp;execution. You can then delete the .EXE file. (An example of this process
<br>
&nbsp;is provided in Chapter 4.)
<br>
<br>
An Example .COM Program
<br>
<br>
&nbsp;The HELLO.COM program listed in Figure 3-3 demonstrates the structure of
<br>
&nbsp;a simple assembly-language program that is destined to become a .COM file.
<br>
&nbsp;(You may find it helpful to compare this listing with the HELLO.EXE
<br>
&nbsp;program later in this chapter.) Because this program is so short and
<br>
&nbsp;simple, a relatively high proportion of the source code is actually
<br>
&nbsp;assembler directives that do not result in any executable code.
<br>
<br>
&nbsp;The NAME statement simply provides a module name for use during the
<br>
&nbsp;linkage process. This aids understanding of the map that the linker
<br>
&nbsp;produces. In MASM versions 5.0 and later, the module name is always the
<br>
&nbsp;same as the filename, and the NAME statement is ignored.
<br>
<br>
&nbsp;The PAGE command, when used with two operands, as in line 2, defines the
<br>
&nbsp;length and width of the page. These default respectively to 66 lines and
<br>
&nbsp;80 characters. If you use the PAGE command without any operands, a
<br>
&nbsp;formfeed is sent to the printer and a heading is printed. In larger
<br>
&nbsp;programs, use the PAGE command liberally to place each of your subroutines
<br>
&nbsp;on separate pages for easy reading.
<br>
<br>
&nbsp;The TITLE command, in line 3, specifies the text string (limited to 60
<br>
&nbsp;characters) that is to be printed at the upper left corner of each page.
<br>
&nbsp;The TITLE command is optional and cannot be used more than once in each
<br>
&nbsp;assembly-language source file.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; 1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;hello
<br>
&nbsp; 2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page &nbsp; &nbsp;55,132
<br>
&nbsp; 3: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;title &nbsp; HELLO.COM--print hello on terminal
<br>
&nbsp; 4:
<br>
&nbsp; 5: &nbsp;;
<br>
&nbsp; 6: &nbsp;; HELLO.COM: &nbsp; &nbsp;demonstrates various components
<br>
&nbsp; 7: &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of a functional .COM-type assembly-
<br>
&nbsp; 8: &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; language program, and an MS-DOS
<br>
&nbsp; 9: &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function call.
<br>
&nbsp;10: &nbsp;;
<br>
&nbsp;11: &nbsp;; Ray Duncan, May 1988
<br>
&nbsp;12: &nbsp;;
<br>
&nbsp;13:
<br>
&nbsp;14: &nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard input handle
<br>
&nbsp;15: &nbsp;stdout &nbsp;equ &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp;16: &nbsp;stderr &nbsp;equ &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard error handle
<br>
&nbsp;17:
<br>
&nbsp;18: &nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;19: &nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII linefeed
<br>
&nbsp;20:
<br>
&nbsp;21:
<br>
&nbsp;22: &nbsp;_TEXT &nbsp; segment word public 'CODE'
<br>
&nbsp;23:
<br>
&nbsp;24: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;org &nbsp; &nbsp; 100h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; .COM files always have
<br>
&nbsp;25: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; an origin of 100h
<br>
&nbsp;26:
<br>
&nbsp;27: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assume &nbsp;cs:_TEXT,ds:_TEXT,es:_TEXT,ss:_TEXT
<br>
&nbsp;28:
<br>
&nbsp;29: &nbsp;print &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; entry point from MS-DOS
<br>
&nbsp;30:
<br>
&nbsp;31: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp;32: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; handle for standard output
<br>
&nbsp;33: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp; &nbsp; &nbsp;; length of message
<br>
&nbsp;34: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg &nbsp; ; address of message
<br>
&nbsp;35: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp;36:
<br>
&nbsp;37: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp;; exit, return code = 0
<br>
&nbsp;38: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp;39:
<br>
&nbsp;40: &nbsp;print &nbsp; endp
<br>
&nbsp;41:
<br>
&nbsp;42:
<br>
&nbsp;43: &nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;cr,lf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; message to display
<br>
&nbsp;44: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Hello World!',cr,lf
<br>
&nbsp;45:
<br>
&nbsp;46: &nbsp;msg_len equ &nbsp; &nbsp; $-msg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; length of message
<br>
&nbsp;47:
<br>
&nbsp;48:
<br>
&nbsp;49: &nbsp;_TEXT &nbsp; ends
<br>
&nbsp;50:
<br>
&nbsp;51: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end &nbsp; &nbsp; print &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; defines entry point
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 3-3. &nbsp;The HELLO.COM program listing.
<br>
<br>
&nbsp;Dropping down past a few comments and EQU statements, we come to a
<br>
&nbsp;declaration of a code segment that begins in line 22 with a SEGMENT
<br>
&nbsp;command and ends in line 49 with an ENDS command. The label in the
<br>
&nbsp;leftmost field of line 22 gives the code segment the name _TEXT. The
<br>
&nbsp;operand fields at the right end of the line give the segment the
<br>
&nbsp;attributes WORD, PUBLIC, and `CODE'. (You might find it helpful to read
<br>
&nbsp;the Microsoft Macro Assembler manual for detailed explanations of each
<br>
&nbsp;possible segment attribute.)
<br>
<br>
&nbsp;Because this program is going to be converted into a .COM file, all of its
<br>
&nbsp;executable code and data areas must lie within one code segment. The
<br>
&nbsp;program must also have its origin at offset 0100H (immediately above the
<br>
&nbsp;program segment prefix), which is taken care of by the ORG statement
<br>
&nbsp;in line 24.
<br>
<br>
&nbsp;Following the ORG instruction, we encounter an ASSUME statement on line
<br>
&nbsp;27. The concept of ASSUME often baffles new assembly-language programmers.
<br>
&nbsp;In a way, ASSUME doesn't &quot;do&quot; anything; it simply tells the assembler
<br>
&nbsp;which segment registers you are going to use to point to the various
<br>
&nbsp;segments of your program, so that the assembler can provide segment
<br>
&nbsp;overrides when they are necessary. It's important to notice that the
<br>
&nbsp;ASSUME statement doesn't take care of loading the segment registers with
<br>
&nbsp;the proper values; it merely notifies the assembler of your intent to do
<br>
&nbsp;that within the program. (Remember that, in the case of a .COM program,
<br>
&nbsp;MS-DOS initializes all the segment registers before entry to point to the
<br>
&nbsp;PSP.)
<br>
<br>
&nbsp;Within the code segment, we come to another type of block declaration that
<br>
&nbsp;begins with the PROC command on line 29 and closes with ENDP on line 40.
<br>
&nbsp;These two instructions declare the beginning and end of a procedure, a
<br>
&nbsp;block of executable code that performs a single distinct function. The
<br>
&nbsp;label in the leftmost field of the PROC statement (in this case, print)
<br>
&nbsp;gives the procedure a name. The operand field gives it an attribute. If
<br>
&nbsp;the procedure carries the NEAR attribute, only other code in the same
<br>
&nbsp;segment can call it, whereas if it carries the FAR attribute, code located
<br>
&nbsp;anywhere in the CPU's memory-addressing space can call it. In .COM
<br>
&nbsp;programs, all procedures carry the NEAR attribute.
<br>
<br>
&nbsp;For the purposes of this example program, I have kept the print procedure
<br>
&nbsp;ridiculously simple. It calls MS-DOS Int 21H Function 40H to send the
<br>
&nbsp;message Hello World! to the video screen, and calls Int 21H Function 4CH
<br>
&nbsp;to terminate the program.
<br>
<br>
&nbsp;The END statement in line 51 tells the assembler that it has reached the
<br>
&nbsp;end of the source file and also specifies the entry point for the program.
<br>
&nbsp;If the entry point is not a label located at offset 0100H, the .EXE file
<br>
&nbsp;resulting from the assembly and linkage of this source program cannot be
<br>
&nbsp;converted into a .COM file.
<br>
<br>
<br>
Introduction to .EXE Programs
<br>
<br>
&nbsp;We have just discussed a program that was written in such a way that it
<br>
&nbsp;could be assembled into a .COM file. Such a program is simple in
<br>
&nbsp;structure, so a programmer who needs to put together this kind of quick
<br>
&nbsp;utility can concentrate on the program logic and do a minimum amount of
<br>
&nbsp;worrying about control of the assembler. However, .COM-type programs have
<br>
&nbsp;some definite disadvantages, and so most serious assembly-language efforts
<br>
&nbsp;for MS-DOS are written to be converted into .EXE files.
<br>
<br>
&nbsp;Although .COM programs are effectively restricted to a total size of 64 KB
<br>
&nbsp;for machine code, data, and stack combined, .EXE programs can be
<br>
&nbsp;practically unlimited in size (up to the limit of the computer's available
<br>
&nbsp;memory). .EXE programs also place the code, data, and stack in separate
<br>
&nbsp;parts of the file. Although the normal MS-DOS program loader does not take
<br>
&nbsp;advantage of this feature of .EXE files, the ability to load different
<br>
&nbsp;parts of large programs into several separate memory fragments, as well as
<br>
&nbsp;the opportunity to designate a &quot;pure&quot; code portion of your program that
<br>
&nbsp;can be shared by several tasks, is very significant in multitasking
<br>
&nbsp;environments such as Microsoft Windows.
<br>
<br>
&nbsp;The MS-DOS loader always brings a .EXE program into memory immediately
<br>
&nbsp;above the program segment prefix, although the order of the code, data,
<br>
&nbsp;and stack segments may vary (Figure 3-4). The .EXE file has a header, or
<br>
&nbsp;block of control information, with a characteristic format (Figures 3-5
<br>
&nbsp;and 3-6). The size of this header varies according to the number of
<br>
&nbsp;program instructions that need to be relocated at load time, but it is
<br>
&nbsp;always a multiple of 512 bytes.
<br>
<br>
&nbsp;Before MS-DOS transfers control to the program, the initial values of the
<br>
&nbsp;code segment (CS) register and instruction pointer (IP) register are
<br>
&nbsp;calculated from the entry-point information in the .EXE file header and
<br>
&nbsp;the program's load address. This information derives from an END statement
<br>
&nbsp;in the source code for one of the program's modules. The data segment (DS)
<br>
&nbsp;and extra segment (ES) registers are made to point to the PSP so that the
<br>
&nbsp;program can access the environment-block pointer, command tail, and other
<br>
&nbsp;useful information contained there.
<br>
<br>
&nbsp; &nbsp; SS:SP ┌────────────────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Stack segment: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp;stack grows downward from top of segment &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;SS:0000H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Data segment &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Program code &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;CS:0000H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Program segment prefix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;DS:0000H └────────────────────────────────────────────────────────┘
<br>
&nbsp;ES:0000H
<br>
<br>
&nbsp;Figure 3-4. &nbsp;A memory image of a typical .EXE-type program immediately
<br>
&nbsp;after loading. The contents of the .EXE file are relocated and brought
<br>
&nbsp;into memory above the program segment prefix. Code, data, and stack reside
<br>
&nbsp;in separate segments and need not be in the order shown here. The entry
<br>
&nbsp;point can be anywhere in the code segment and is specified by the END
<br>
&nbsp;statement in the main module of the program. When the program receives
<br>
&nbsp;control, the DS (data segment) and ES (extra segment) registers point to
<br>
&nbsp;the program segment prefix; the program usually saves this value and then
<br>
&nbsp;resets the DS and ES registers to point to its data area.
<br>
<br>
&nbsp;The initial contents of the stack segment (SS) and stack pointer (SP)
<br>
&nbsp;registers come from the header. This information derives from the
<br>
&nbsp;declaration of a segment with the attribute STACK somewhere in the
<br>
&nbsp;program's source code. The memory space allocated for the stack may be
<br>
&nbsp;initialized or uninitialized, depending on the stack-segment definition;
<br>
&nbsp;many programmers like to initialize the stack memory with a recognizable
<br>
&nbsp;data pattern so that they can inspect memory dumps and determine how much
<br>
&nbsp;stack space is actually used by the program.
<br>
<br>
&nbsp;When a .EXE program finishes processing, it should return control to
<br>
&nbsp;MS-DOS through Int 21H Function 4CH. Other methods are available, but
<br>
&nbsp;they offer no advantages and are considerably less convenient (because
<br>
&nbsp;they usually require the CS register to point to the PSP).
<br>
<br>
&nbsp;Byte
<br>
&nbsp;offset
<br>
&nbsp;0000H ┌────────────────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; First of .EXE file signature (4DH) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;0001H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp;Second part of .EXE file signature (5AH) &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;0002H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Length of file MOD 512 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;0004H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp;Size of file in 512-byte pages, including header &nbsp; &nbsp;│
<br>
&nbsp;0006H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of relocation-table items &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;0008H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;Size of header in paragraphs (16-byte units) &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;000AH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; Minimum number of paragraphs needed above program &nbsp; &nbsp;│
<br>
&nbsp;000CH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; Maximum number of paragraphs desired above program &nbsp; │
<br>
&nbsp;000EH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Segment displacement of stack module &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;0010H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contents of SP register at entry &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;0012H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Word checksum &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;0014H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contents of IP register at entry &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;0016H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Segment displacement of code module &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;0018H ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp;Offset of first relocation item in file &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;001AH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp;Overlay number (0 for resident part of program) &nbsp; &nbsp; │
<br>
&nbsp;001BH ├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Variable reserved space &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp;├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Relocation table &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp;├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Variable reserved space &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp;├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Program and data segments &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp;├────────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Stack segment &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp;└────────────────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 3-5. &nbsp;The format of a .EXE load module.
<br>
<br>
&nbsp;The input to the linker for a .EXE-type program can be many separate
<br>
&nbsp;object modules. Each module can use a unique code-segment name, and the
<br>
&nbsp;procedures can carry either the NEAR or the FAR attribute, depending on
<br>
&nbsp;naming conventions and the size of the executable code. The programmer
<br>
&nbsp;must take care that the modules linked together contain only one segment
<br>
&nbsp;with the STACK attribute and only one entry point defined with an END
<br>
&nbsp;assembler directive. The output from the linker is a file with a .EXE
<br>
&nbsp;extension. This file can be executed immediately.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;C&gt;DUMP HELLO.EXE
<br>
&nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;8 &nbsp;9 &nbsp;A &nbsp;B &nbsp;C &nbsp;D &nbsp;E &nbsp;F
<br>
&nbsp;0000 &nbsp;4D 5A 28 00 02 00 01 00 20 00 09 00 FF FF 03 00 &nbsp;MZ(..... .......
<br>
&nbsp;0010 &nbsp;80 00 20 05 00 00 00 00 1E 00 00 00 01 00 01 00 &nbsp;.. .............
<br>
&nbsp;0020 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &nbsp;................
<br>
&nbsp;0030 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &nbsp;................
<br>
&nbsp;0040 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &nbsp;................
<br>
&nbsp;0050 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &nbsp;................
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;0200 &nbsp;B8 01 00 8E D8 B4 40 BB 01 00 B9 10 00 90 BA 08 &nbsp;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b9979797979797f9979797979797979797">[email&#160;protected]</a>
<br>
&nbsp;0210 &nbsp;00 CD 21 B8 00 4C CD 21 0D 0A 48 65 6C 6C 6F 20 &nbsp;..!..L.!..Hello
<br>
&nbsp;0220 &nbsp;57 6F 72 6C 64 21 0D 0A &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;World!..
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 3-6. &nbsp;A hex dump of the HELLO.EXE program, demonstrating the
<br>
&nbsp;contents of a simple .EXE load module. Note the following interesting
<br>
&nbsp;values: the .EXE signature in bytes 0000H and 0001H, the number of
<br>
&nbsp;relocation-table items in bytes 0006H and 0007H, the minimum extra memory
<br>
&nbsp;allocation (MIN_ALLOC) in bytes 000AH and 000BH, the maximum extra memory
<br>
&nbsp;allocation (MAX_ALLOC) in bytes 000CH and 000DH, and the initial IP
<br>
&nbsp;(instruction pointer) register value in bytes 0014H and 0015H. See also
<br>
&nbsp;Figure 3-5.
<br>
<br>
An Example .EXE Program
<br>
<br>
&nbsp;The HELLO.EXE program in Figure 3-7 demonstrates the fundamental
<br>
&nbsp;structure of an assembly-language program that is destined to become a
<br>
&nbsp;.EXE file. At minimum, it should have a module name, a code segment, a
<br>
&nbsp;stack segment, and a primary procedure that receives control of the
<br>
&nbsp;computer from MS-DOS after the program is loaded. The HELLO.EXE program
<br>
&nbsp;also contains a data segment to provide a more complete example.
<br>
<br>
&nbsp;The NAME, TITLE, and PAGE directives were covered in the HELLO.COM example
<br>
&nbsp;program and are used in the same manner here, so we'll move to the first
<br>
&nbsp;new item of interest. After a few comments and EQU statements, we come to
<br>
&nbsp;a declaration of a code segment that begins on line 21 with a SEGMENT
<br>
&nbsp;command and ends on line 41 with an ENDS command. As in the HELLO.COM
<br>
&nbsp;example program, the label in the leftmost field of the line gives the
<br>
&nbsp;code segment the name _TEXT. The operand fields at the right end of the
<br>
&nbsp;line give the attributes WORD, PUBLIC, and `CODE'.
<br>
<br>
&nbsp;Following the code-segment instruction, we find an ASSUME statement on
<br>
&nbsp;line 23. Notice that, unlike the equivalent statement in the HELLO.COM
<br>
&nbsp;program, the ASSUME statement in this program specifies several different
<br>
&nbsp;segment names. Again, remember that this statement has no direct effect on
<br>
&nbsp;the contents of the segment registers but affects only the operation of
<br>
&nbsp;the assembler itself.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; 1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;hello
<br>
&nbsp; 2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page &nbsp; &nbsp;55,132
<br>
&nbsp; 3: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;title &nbsp; HELLO.EXE--print Hello on terminal
<br>
&nbsp; 4: &nbsp;;
<br>
&nbsp; 5: &nbsp;; HELLO.EXE: &nbsp; &nbsp;demonstrates various components
<br>
&nbsp; 6: &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of a functional .EXE-type assembly-
<br>
&nbsp; 7: &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; language program, use of segments,
<br>
&nbsp; 8: &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and an MS-DOS function call.
<br>
&nbsp; 9: &nbsp;;
<br>
&nbsp;10: &nbsp;; Ray Duncan, May 1988
<br>
&nbsp;11: &nbsp;;
<br>
&nbsp;12:
<br>
&nbsp;13: &nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard input handle
<br>
&nbsp;14: &nbsp;stdout &nbsp;equ &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp;15: &nbsp;stderr &nbsp;equ &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard error handle
<br>
&nbsp;16:
<br>
&nbsp;17: &nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;18: &nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII linefeed
<br>
&nbsp;19:
<br>
&nbsp;20:
<br>
&nbsp;21: &nbsp;_TEXT &nbsp; segment word public 'CODE'
<br>
&nbsp;22:
<br>
&nbsp;23: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assume &nbsp;cs:_TEXT,ds:_DATA,ss:STACK
<br>
&nbsp;24:
<br>
&nbsp;25: &nbsp;print &nbsp; proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; entry point from MS-DOS
<br>
&nbsp;26:
<br>
&nbsp;27: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp;; make our data segment
<br>
&nbsp;28: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; addressable...
<br>
&nbsp;29:
<br>
&nbsp;30: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp;31: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp;32: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp; &nbsp; &nbsp;; length of message
<br>
&nbsp;33: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg &nbsp; ; address of message
<br>
&nbsp;34: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp;35:
<br>
&nbsp;36: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp;; exit, return code = 0
<br>
&nbsp;37: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp;38:
<br>
&nbsp;39: &nbsp;print &nbsp; endp
<br>
&nbsp;40:
<br>
&nbsp;41: &nbsp;_TEXT &nbsp; ends
<br>
&nbsp;42:
<br>
&nbsp;43:
<br>
&nbsp;44: &nbsp;_DATA &nbsp; segment word public 'DATA'
<br>
&nbsp;45:
<br>
&nbsp;46: &nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;cr,lf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; message to display
<br>
&nbsp;47: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Hello World!',cr,lf
<br>
&nbsp;48:
<br>
&nbsp;49: &nbsp;msg_len equ &nbsp; &nbsp; $-msg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; length of message
<br>
&nbsp;50:
<br>
&nbsp;51: &nbsp;_DATA &nbsp; ends
<br>
&nbsp;52:
<br>
&nbsp;53:
<br>
&nbsp;54: &nbsp;STACK &nbsp; segment para stack `STACK'
<br>
&nbsp;55:
<br>
&nbsp;56: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;128 dup (?)
<br>
&nbsp;57:
<br>
&nbsp;58: &nbsp;STACK &nbsp; ends
<br>
&nbsp;59:
<br>
&nbsp;60: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end &nbsp; &nbsp; print &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; defines entry point
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 3-7. &nbsp;The HELLO.EXE program listing.
<br>
<br>
&nbsp;Within the code segment, the main print procedure is declared by the PROC
<br>
&nbsp;command on line 25 and closed with ENDP on line 39. Because the procedure
<br>
&nbsp;resides in a .EXE file, we have given it the FAR attribute as an example,
<br>
&nbsp;but the attribute is really irrelevant because the program is so small and
<br>
 &nbsp;the procedure is not called by anything else in the same program.
<br>
<br>
&nbsp;The print procedure first initializes the DS register, as indicated in the
<br>
&nbsp;earlier ASSUME statement, loading it with a value that causes it to point
<br>
&nbsp;to the base of the data area. (MS-DOS automatically sets up the CS and SS
<br>
&nbsp;registers.) Next, the procedure uses MS-DOS Int 21H Function 40H to
<br>
&nbsp;display the message Hello World! on the screen, just as in the HELLO.COM
<br>
&nbsp;program. Finally, the procedure exits back to MS-DOS with an Int 21H
<br>
&nbsp;Function 4CH on lines 36 and 37, passing a return code of zero (which by
<br>
&nbsp;convention means a success).
<br>
<br>
&nbsp;Lines 44 through 51 declare a data segment named _DATA, which contains the
<br>
&nbsp;variables and constants the program will use. If the various modules of a
<br>
&nbsp;program contain multiple data segments with the same name, the linker will
<br>
&nbsp;collect them and place them in the same physical memory segment.
<br>
<br>
&nbsp;Lines 54 through 58 establish a stack segment; PUSH and POP instructions
<br>
&nbsp;will access this area of scratch memory. Before MS-DOS transfers control
<br>
&nbsp;to a .EXE program, it sets up the SS and SP registers according to the
<br>
&nbsp;declared size and location of the stack segment. Be sure to allow enough
<br>
&nbsp;room for the maximum stack depth that can occur at runtime, plus a safe
<br>
&nbsp;number of extra words for registers pushed onto the stack during an MS-DOS
<br>
&nbsp;service call. If the stack overflows, it may damage your other code and
<br>
&nbsp;data segments and cause your program to behave strangely or even to crash
<br>
&nbsp;altogether!
<br>
<br>
&nbsp;The END statement on line 60 winds up our brief HELLO.EXE program, telling
<br>
&nbsp;the assembler that it has reached the end of the source file and providing
<br>
&nbsp;the label of the program's point of entry from MS-DOS.
<br>
<br>
&nbsp;The differences between .COM and .EXE programs are summarized in Figure
<br>
&nbsp;3-8.
<br>
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .COM program &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .EXE program
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Maximum size &nbsp; &nbsp; &nbsp; 65,536 bytes minus 256 &nbsp; &nbsp; No limit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes for PSP and 2 bytes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for stack
<br>
<br>
&nbsp;Entry point &nbsp; &nbsp; &nbsp; &nbsp;PSP:0100H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Defined by END statement
<br>
<br>
&nbsp;AL at entry &nbsp; &nbsp; &nbsp; &nbsp;00H if default FCB #1 has &nbsp;Same
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid drive, 0FFH if
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invalid drive
<br>
<br>
&nbsp;AH at entry &nbsp; &nbsp; &nbsp; &nbsp;00H if default FCB #2 has &nbsp;Same
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid drive, 0FFH if
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invalid drive
<br>
<br>
&nbsp;CS at entry &nbsp; &nbsp; &nbsp; &nbsp;PSP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Segment containing module
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;with entry point
<br>
<br>
&nbsp;IP at entry &nbsp; &nbsp; &nbsp; &nbsp;0100H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Offset of entry point within
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;its segment
<br>
<br>
&nbsp;DS at entry &nbsp; &nbsp; &nbsp; &nbsp;PSP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PSP
<br>
<br>
&nbsp;ES at entry &nbsp; &nbsp; &nbsp; &nbsp;PSP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PSP
<br>
<br>
&nbsp;SS at entry &nbsp; &nbsp; &nbsp; &nbsp;PSP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Segment with STACK attribute
<br>
<br>
&nbsp;SP at entry &nbsp; &nbsp; &nbsp; &nbsp;0FFFEH or top word in &nbsp; &nbsp; &nbsp;Size of segment defined with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; available memory, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STACK attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; whichever is lower
<br>
<br>
&nbsp;Stack at entry &nbsp; &nbsp; Zero word &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Initialized or uninitialized
<br>
<br>
&nbsp;Stack size &nbsp; &nbsp; &nbsp; &nbsp; 65,536 bytes minus 256 &nbsp; &nbsp; Defined in segment with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes for PSP and size of &nbsp;STACK attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; executable code and data
<br>
<br>
&nbsp;Subroutine calls &nbsp; Usually NEAR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NEAR or FAR
<br>
<br>
&nbsp;Exit method &nbsp; &nbsp; &nbsp; &nbsp;Int 21H Function 4CH &nbsp; &nbsp; &nbsp;Int 21H Function 4CH
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; preferred, NEAR RET if &nbsp; &nbsp; preferred
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MS-DOS version 1
<br>
<br>
&nbsp;Size of file &nbsp; &nbsp; &nbsp; Exact size of program &nbsp; &nbsp; &nbsp;Size of program plus header
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(multiple of 512 bytes)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 3-8. &nbsp;Summary of the differences between .COM and .EXE programs,
<br>
&nbsp;including their entry conditions.
<br>
<br>
<br>
More About Assembly-Language Programs
<br>
<br>
&nbsp;Now that we've looked at working examples of .COM and .EXE
<br>
&nbsp;assembly-language programs, let's backtrack and discuss their elements a
<br>
&nbsp;little more formally. The following discussion is based on the Microsoft
<br>
&nbsp;Macro Assembler, hereafter referred to as MASM. If you are familiar with
<br>
&nbsp;MASM and are an experienced assembly-language programmer, you may want to
<br>
&nbsp;skip this section.
<br>
<br>
&nbsp;MASM programs can be thought of as having three structural levels:
<br>
<br>
&nbsp;■ &nbsp;The module level
<br>
<br>
&nbsp;■ &nbsp;The segment level
<br>
<br>
&nbsp;■ &nbsp;The procedure level
<br>
<br>
&nbsp;Modules are simply chunks of source code that can be independently
<br>
&nbsp;maintained and assembled. Segments are physical groupings of like items
<br>
&nbsp;(machine code or data) within a program and a corresponding segregation of
<br>
&nbsp;dissimilar items. Procedures are functional subdivisions of an executable
<br>
&nbsp;program──routines that carry out a particular task.
<br>
<br>
Program Modules
<br>
<br>
&nbsp;Under MS-DOS, the module-level structure consists of files containing the
<br>
&nbsp;source code for individual routines. Each source file is translated by the
<br>
&nbsp;assembler into a relocatable object module. An object module can reside
<br>
&nbsp;alone in an individual file or with many other object modules in an
<br>
&nbsp;object-module library of frequently used or related routines. The
<br>
&nbsp;Microsoft Object Linker (LINK) combines object-module files, often with
<br>
&nbsp;additional object modules extracted from libraries, into an executable
<br>
&nbsp;program file.
<br>
<br>
&nbsp;Using modules and object-module libraries reduces the size of your
<br>
&nbsp;application source files (and vastly increases your productivity), because
<br>
&nbsp;these files need not contain the source code for routines they have in
<br>
&nbsp;common with other programs. This technique also allows you to maintain the
<br>
&nbsp;routines more easily, because you need to alter only one copy of their
<br>
&nbsp;source code stored in one place, instead of many copies stored in
<br>
&nbsp;different applications. When you improve (or fix) one of these routines,
<br>
&nbsp;you can simply reassemble it, put its object module back into the library,
<br>
&nbsp;relink all of the programs that use the routine, and voilga: instant
<br>
&nbsp;upgrade.
<br>
<br>
Program Segments
<br>
<br>
&nbsp;The term segments refers to two discrete programming concepts: physical
<br>
&nbsp;segments and logical segments.
<br>
<br>
&nbsp;Physical segments are 64 KB blocks of memory. The Intel 8086/8088 and
<br>
&nbsp;80286 microprocessors have four segment registers, which are essentially
<br>
&nbsp;used as pointers to these blocks. (The 80386 has six segment registers,
<br>
&nbsp;which are a superset of those found on the 8086/8088 and 80286.) Each
<br>
&nbsp;segment register can point to the bottom of a different 64 KB area of
<br>
&nbsp;memory. Thus, a program can address any location in memory by appropriate
<br>
&nbsp;manipulation of the segment registers, but the maximum amount of memory
<br>
&nbsp;that it can address simultaneously is 256 KB.
<br>
<br>
&nbsp;As we discussed earlier in the chapter, .COM programs assume that all four
<br>
&nbsp;segment registers always point to the same place──the bottom of the
<br>
&nbsp;program. Thus, they are limited to a maximum size of 64 KB. .EXE programs,
<br>
&nbsp;on the other hand, can address many different physical segments and can
<br>
&nbsp;reset the segment registers to point to each segment as it is needed.
<br>
&nbsp;Consequently, the only practical limit on the size of a .EXE program is
<br>
&nbsp;the amount of available memory. The example programs throughout the
<br>
&nbsp;remainder of this book focus on .EXE programs.
<br>
<br>
&nbsp;Logical segments are the program components. A minimum of three logical
<br>
&nbsp;segments must be declared in any .EXE program: a code segment, a data
<br>
&nbsp;segment, and a stack segment. Programs with more than 64 KB of code or
<br>
&nbsp;data have more than one code or data segment. The routines or data that
<br>
&nbsp;are used most frequently are put into the primary code and data segments
<br>
&nbsp;for speed, and routines or data that are used less frequently are put into
<br>
&nbsp;secondary code and data segments.
<br>
<br>
&nbsp;Segments are declared with the SEGMENT and ENDS directives in the
<br>
&nbsp;following form:
<br>
<br>
&nbsp;name &nbsp; SEGMENT attributes
<br>
&nbsp;.
<br>
&nbsp;.
<br>
&nbsp;.
<br>
&nbsp;name &nbsp; ENDS
<br>
<br>
&nbsp;The attributes of a segment include its align type (BYTE, WORD, or PARA),
<br>
&nbsp;combine type (PUBLIC, PRIVATE, COMMON, or STACK), and class type. The
<br>
&nbsp;segment attributes are used by the linker when it is combining logical
<br>
&nbsp;segments to create the physical segments of an executable program. Most of
<br>
&nbsp;the time, you can get by just fine using a small selection of attributes
<br>
&nbsp;in a rather stereotypical way. However, if you want to use the full range
<br>
&nbsp;of attributes, you might want to read the detailed explanation in the MASM
<br>
&nbsp;manual.
<br>
<br>
&nbsp;Programs are classified into one memory model or another based on the
<br>
&nbsp;number of their code and data segments. The most commonly used memory
<br>
&nbsp;model for assembly-language programs is the small model, which has one
<br>
&nbsp;code and one data segment, but you can also use the medium, compact, and
<br>
&nbsp;large models (Figure 3-9). (Two additional models exist with which we
<br>
&nbsp;will not be concerning ourselves further: the tiny model, which consists
<br>
&nbsp;of intermixed code and data in a single segment── for example, a .COM file
<br>
&nbsp;under MS-DOS; and the huge model, which is supported by the Microsoft C
<br>
&nbsp;Optimizing Compiler and which allows use of data structures larger than 64
<br>
&nbsp;KB.)
<br>
<br>
&nbsp;Model &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Code segments &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Data segments
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Small &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;One &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; One
<br>
&nbsp;Medium &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Multiple &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;One
<br>
&nbsp;Compact &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;One &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Multiple
<br>
&nbsp;Large &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Multiple &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Multiple
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 3-9. &nbsp;Memory models commonly used in assembly-language and C
<br>
&nbsp;programs.
<br>
<br>
&nbsp;For each memory model, Microsoft has established certain segment and class
<br>
&nbsp;names that are used by all its high-level-language compilers (Figure
<br>
&nbsp;3-10). Because segment names are arbitrary, you may as well adopt the
<br>
&nbsp;Microsoft conventions. Their use will make it easier for you to integrate
<br>
&nbsp;your assembly-language routines into programs written in languages such as
<br>
&nbsp;C, or to use routines from high-level-language libraries in your
<br>
&nbsp;assembly-language programs.
<br>
<br>
&nbsp;Another important Microsoft high-level-language convention is to use the
<br>
&nbsp;GROUP directive to name the near data segment (the segment the program
<br>
&nbsp;expects to address with offsets from the DS register) and the stack
<br>
&nbsp;segment as members of DGROUP (the automatic data group), a special name
<br>
&nbsp;recognized by the linker and also by the program loaders in Microsoft
<br>
&nbsp;Windows and Microsoft OS/2. The GROUP directive causes logical segments
<br>
&nbsp;with different names to be combined into a single physical segment so that
<br>
&nbsp;they can be addressed using the same segment base address. In C programs,
<br>
&nbsp;DGROUP also contains the local heap, which is used by the C runtime
<br>
&nbsp;library for dynamic allocation of small amounts of memory.
<br>
<br>
<br>
&nbsp;Memory &nbsp; &nbsp; &nbsp;Segment &nbsp; &nbsp; &nbsp;Align &nbsp; &nbsp; &nbsp; Combine &nbsp; &nbsp; Class &nbsp; &nbsp; &nbsp; &nbsp;Group
<br>
&nbsp;model &nbsp; &nbsp; &nbsp; name &nbsp; &nbsp; &nbsp; &nbsp; type &nbsp; &nbsp; &nbsp; &nbsp;type &nbsp; &nbsp; &nbsp; &nbsp;type
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Small &nbsp; &nbsp; &nbsp; _TEXT &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp;PUBLIC &nbsp; &nbsp; &nbsp;CODE
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_DATA &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp;PUBLIC &nbsp; &nbsp; &nbsp;DATA &nbsp; &nbsp; &nbsp; &nbsp; DGROUP
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STACK &nbsp; &nbsp; &nbsp; &nbsp;PARA &nbsp; &nbsp; &nbsp; &nbsp;STACK &nbsp; &nbsp; &nbsp; STACK &nbsp; &nbsp; &nbsp; &nbsp;DGROUP
<br>
<br>
&nbsp;Medium &nbsp; &nbsp; &nbsp;module_TEXT &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp;PUBLIC &nbsp; &nbsp; &nbsp;CODE
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp;PUBLIC &nbsp; &nbsp; &nbsp;DATA &nbsp; &nbsp; &nbsp; &nbsp; DGROUP
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_DATA
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STACK &nbsp; &nbsp; &nbsp; &nbsp;PARA &nbsp; &nbsp; &nbsp; &nbsp;STACK &nbsp; &nbsp; &nbsp; STACK &nbsp; &nbsp; &nbsp; &nbsp;DGROUP
<br>
<br>
&nbsp;Compact &nbsp; &nbsp; _TEXT &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp;PUBLIC &nbsp; &nbsp; &nbsp;CODE
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data &nbsp; &nbsp; &nbsp; &nbsp; PARA &nbsp; &nbsp; &nbsp; &nbsp;PRIVATE &nbsp; &nbsp; FAR_DATA
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp;PUBLIC &nbsp; &nbsp; &nbsp;DATA &nbsp; &nbsp; &nbsp; &nbsp; DGROUP
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_DATA
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STACK &nbsp; &nbsp; &nbsp; &nbsp;PARA &nbsp; &nbsp; &nbsp; &nbsp;STACK &nbsp; &nbsp; &nbsp; STACK &nbsp; &nbsp; &nbsp; &nbsp;DGROUP
<br>
<br>
&nbsp;Large &nbsp; &nbsp; &nbsp; module_TEXT &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp;PUBLIC &nbsp; &nbsp; &nbsp;CODE
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data &nbsp; &nbsp; &nbsp; &nbsp; PARA &nbsp; &nbsp; &nbsp; &nbsp;PRIVATE &nbsp; &nbsp; FAR_DATA
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_DATA &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp;PUBLIC &nbsp; &nbsp; &nbsp;DATA &nbsp; &nbsp; &nbsp; &nbsp; DGROUP
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STACK &nbsp; &nbsp; &nbsp; &nbsp;PARA &nbsp; &nbsp; &nbsp; &nbsp;STACK &nbsp; &nbsp; &nbsp; STACK &nbsp; &nbsp; &nbsp; &nbsp;DGROUP
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 3-10. &nbsp;Segments, groups, and classes for the standard memory models
<br>
&nbsp;as used with assembly-language programs. The Microsoft C Optimizing
<br>
&nbsp;Compiler and other high-level-language compilers use a superset of these
<br>
&nbsp;segments and classes.
<br>
<br>
&nbsp;For pure assembly-language programs that will run under MS-DOS, you can
<br>
&nbsp;ignore DGROUP. However, if you plan to integrate assembly-language
<br>
&nbsp;routines and programs written in high-level languages, you'll want to
<br>
&nbsp;follow the Microsoft DGROUP convention. For example, if you are planning
<br>
&nbsp;to link routines from a C library into an assembly-language program, you
<br>
&nbsp;should include the line
<br>
<br>
&nbsp;DGROUP group _DATA,STACK
<br>
<br>
&nbsp;near the beginning of the program.
<br>
<br>
&nbsp;The final Microsoft convention of interest in creating .EXE programs is
<br>
&nbsp;segment order. The high-level compilers assume that code segments always
<br>
&nbsp;come first, followed by far data segments, followed by the near data
<br>
&nbsp;segment, with the stack and heap last. This order won't concern you much
<br>
&nbsp;until you begin integrating assembly-language code with routines from
<br>
&nbsp;high-level-language libraries, but it is easiest to learn to use the
<br>
&nbsp;convention right from the start.
<br>
<br>
Program Procedures
<br>
<br>
&nbsp;The procedure level of program structure is partly real and partly
<br>
&nbsp;conceptual. Procedures are basically just a fancy guise for subroutines.
<br>
<br>
&nbsp;Procedures within a program are declared with the PROC and ENDP directives
<br>
&nbsp;in the following form:
<br>
<br>
&nbsp;name &nbsp; PROC attribute
<br>
&nbsp;.
<br>
&nbsp;.
<br>
&nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; RET
<br>
&nbsp;name &nbsp; ENDP
<br>
<br>
&nbsp;The attribute carried by a PROC declaration, which is either NEAR or FAR,
<br>
&nbsp;tells the assembler what type of call you expect to use to enter the
<br>
&nbsp;procedure──that is, whether the procedure will be called from other
<br>
&nbsp;routines in the same segment or from routines in other segments. When the
<br>
&nbsp;assembler encounters a RET instruction within the procedure, it uses the
<br>
&nbsp;attribute information to generate the correct opcode for either a near
<br>
&nbsp;(intra-segment) or far (inter-segment) return.
<br>
<br>
&nbsp;Each program should have a main procedure that receives control from
<br>
&nbsp;MS-DOS. You specify the entry point for the program by including the name
<br>
&nbsp;of the main procedure in the END statement in one of the program's source
<br>
&nbsp;files. The main procedure's attribute (NEAR or FAR) is really not too
<br>
&nbsp;important, because the program returns control to MS-DOS with a function
<br>
&nbsp;call rather than a RET instruction. However, by convention, most
<br>
&nbsp;programmers assign the main procedure the FAR attribute anyway.
<br>
<br>
&nbsp;You should break the remainder of the program into procedures in an
<br>
&nbsp;orderly way, with each procedure performing a well-defined single
<br>
&nbsp;function, returning its results to its caller, and avoiding actions that
<br>
&nbsp;have global effects within the program. Ideally procedures invoke each
<br>
&nbsp;other only by CALL instructions, have only one entry point and one exit
<br>
&nbsp;point, and always exit by means of a RET instruction, never by jumping to
<br>
&nbsp;some other location within the program.
<br>
<br>
&nbsp;For ease of understanding and maintenance, a procedure should not exceed
<br>
&nbsp;one page (about 60 lines); if it is longer than a page, it is probably too
<br>
&nbsp;complex and you should delegate some of its function to one or more
<br>
&nbsp;subsidiary procedures. You should preface the source code for each
<br>
&nbsp;procedure with a detailed comment that states the procedure's calling
<br>
&nbsp;sequence, results returned, registers affected, and any data items
<br>
&nbsp;accessed or modified. The effort invested in making your procedures
<br>
&nbsp;compact, clean, flexible, and well-documented will be repaid many times
<br>
&nbsp;over when you reuse the procedures in other programs.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 4 &nbsp;MS-DOS Programming Tools
<br>
<br>
&nbsp;Preparing a new program to run under MS-DOS is an iterative process with
<br>
&nbsp;four basic steps:
<br>
<br>
&nbsp;■ &nbsp;Use of a text editor to create or modify an ASCII source-code file
<br>
<br>
&nbsp;■ &nbsp;Use of an assembler or high-level-language compiler (such as the
<br>
&nbsp; &nbsp; Microsoft Macro Assembler or the Microsoft C Optimizing Compiler) to
<br>
&nbsp; &nbsp; translate the source file into relocatable object code
<br>
<br>
&nbsp;■ &nbsp;Use of a linker to transform the relocatable object code into an
<br>
&nbsp; &nbsp; executable MS-DOS load module
<br>
<br>
&nbsp;■ &nbsp;Use of a debugger to methodically test and debug the program
<br>
<br>
&nbsp;Additional utilities the MS-DOS software developer may find necessary or
<br>
&nbsp;helpful include the following:
<br>
<br>
&nbsp;■ &nbsp;LIB, which creates and maintains object-module libraries
<br>
<br>
&nbsp;■ &nbsp;CREF, which generates a cross-reference listing
<br>
<br>
&nbsp;■ &nbsp;EXE2BIN, which converts .EXE files to .COM files
<br>
<br>
&nbsp;■ &nbsp;MAKE, which compares dates of files and carries out operations based on
<br>
&nbsp; &nbsp; the result of the comparison
<br>
<br>
&nbsp;This chapter gives an operational overview of the Microsoft programming
<br>
&nbsp;tools for MS-DOS, including the assembler, the C compiler, the linker, and
<br>
&nbsp;the librarian. In general, the information provided here also applies to
<br>
&nbsp;the IBM programming tools for MS-DOS, which are really the Microsoft
<br>
&nbsp;products with minor variations and different version numbers. Even if your
<br>
&nbsp;preferred programming language is not C or assembly language, you will
<br>
&nbsp;need at least a passing familiarity with these tools because all of the
<br>
&nbsp;examples in the IBM and Microsoft DOS reference manuals are written in one
<br>
&nbsp;of these languages.
<br>
<br>
&nbsp;The survey in this chapter, together with the example programs and
<br>
&nbsp;reference section elsewhere in the book, should provide the experienced
<br>
&nbsp;programmer with sufficient information to immediately begin writing useful
<br>
&nbsp;programs. Readers who do not have a background in C, assembly language, or
<br>
&nbsp;the Intel 80x86 microprocessor architecture should refer to the tutorial
<br>
&nbsp;and reference works listed at the end of this chapter.
<br>
<br>
<br>
File Types
<br>
<br>
&nbsp;The MS-DOS programming tools can create and process many different file
<br>
&nbsp;types. The following extensions are used by convention for these files:
<br>
<br>
<br>
&nbsp;Extension &nbsp;File type
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;.ASM &nbsp; &nbsp; &nbsp; Assembly-language source file
<br>
<br>
&nbsp;.C &nbsp; &nbsp; &nbsp; &nbsp; C source file
<br>
<br>
&nbsp;.COM &nbsp; &nbsp; &nbsp; MS-DOS executable load module that does not require relocation
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; at runtime
<br>
<br>
&nbsp;.CRF &nbsp; &nbsp; &nbsp; Cross-reference information file produced by the assembler for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; processing by CREF.EXE
<br>
<br>
&nbsp;.DEF &nbsp; &nbsp; &nbsp; Module-definition file describing a program's segment behavior
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MS OS/2 and Microsoft Windows programs only; not relevant to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; normal MS-DOS applications)
<br>
<br>
&nbsp;.EXE &nbsp; &nbsp; &nbsp; MS-DOS executable load module that requires relocation at
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runtime
<br>
<br>
&nbsp;.H &nbsp; &nbsp; &nbsp; &nbsp; C header file containing C source code for constants, macros,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and functions; merged into another C program with the #include
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; directive
<br>
<br>
&nbsp;.INC &nbsp; &nbsp; &nbsp; Include file for assembly-language programs, typically
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; containing macros and/or equates for systemwide values such as
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error codes
<br>
<br>
&nbsp;.LIB &nbsp; &nbsp; &nbsp; Object-module library file made up of one or more .OBJ files;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexed and manipulated by LIB.EXE
<br>
<br>
&nbsp;.LST &nbsp; &nbsp; &nbsp; Program listing, produced by the assembler, that includes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memory locations, machine code, the original program text, and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error messages
<br>
<br>
&nbsp;.MAP &nbsp; &nbsp; &nbsp; Listing of symbols and their locations within a load module;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; produced by the linker
<br>
<br>
&nbsp;.OBJ &nbsp; &nbsp; &nbsp; Relocatable-object-code file produced by an assembler or
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compiler
<br>
<br>
&nbsp;.REF &nbsp; &nbsp; &nbsp; Cross-reference listing produced by CREF.EXE from the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; information in a .CRF file
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
<br>
The Microsoft Macro Assembler
<br>
<br>
&nbsp;The Microsoft Macro Assembler (MASM) is distributed as the file MASM.EXE.
<br>
&nbsp;When beginning a program translation, MASM needs the following
<br>
&nbsp;information:
<br>
<br>
&nbsp;■ &nbsp;The name of the file containing the source program
<br>
<br>
&nbsp;■ &nbsp;The filename for the object program to be created
<br>
<br>
&nbsp;■ &nbsp;The destination of the program listing
<br>
<br>
&nbsp;■ &nbsp;The filename for the information that is later processed by the
<br>
&nbsp; &nbsp; cross-reference utility (CREF.EXE)
<br>
<br>
&nbsp;You can invoke MASM in two ways. If you enter the name of the assembler
<br>
&nbsp;alone, it prompts you for the names of each of the various input and
<br>
&nbsp;output files. The assembler supplies reasonable defaults for all the
<br>
&nbsp;responses except the source filename, as shown in the following example:
<br>
<br>
&nbsp;C&gt;MASM &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;Microsoft (R) Macro Assembler Version 5.10
<br>
&nbsp;Copyright (C) Microsoft Corp 1981, 1988. All rights reserved.
<br>
<br>
&nbsp;Source filename [.ASM]: HELLO &nbsp;&lt;Enter&gt;
<br>
&nbsp;Object filename [HELLO.OBJ]: &nbsp;&lt;Enter&gt;
<br>
&nbsp;Source listing &nbsp;[NUL.LST]: &nbsp;&lt;Enter&gt;
<br>
&nbsp;Cross-reference [NUL.CRF]: &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp; &nbsp;49006 Bytes symbol space free
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp;0 Warning Errors
<br>
&nbsp; &nbsp; &nbsp; &nbsp;0 Severe Errors
<br>
<br>
&nbsp;C&gt;
<br>
<br>
&nbsp;You can use a logical device name (such as PRN or COM1) at any of the MASM
<br>
&nbsp;prompts to send that output of the assembler to a character device rather
<br>
&nbsp;than a file. Note that the default for the listing and cross-reference
<br>
&nbsp;files is the NUL device──that is, no file is created. If you end any
<br>
&nbsp;response with a semicolon, MASM assumes that the remaining responses are
<br>
&nbsp;all to be the default.
<br>
<br>
&nbsp;A more efficient way to use MASM is to supply all parameters in the
<br>
&nbsp;command line, as follows:
<br>
<br>
&nbsp; &nbsp;MASM [options] source,[object],[listing],[crossref]
<br>
<br>
&nbsp;For example, the following command lines are equivalent to the preceding
<br>
&nbsp;interactive session:
<br>
<br>
&nbsp;C&gt;MASM HELLO,,NUL,NUL &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;or
<br>
<br>
&nbsp;C&gt;MASM HELLO; &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;These commands use the file HELLO.ASM as the source, generate the
<br>
&nbsp;object-code file HELLO.OBJ, and send the listing and cross-reference files
<br>
&nbsp;to the bit bucket.
<br>
<br>
&nbsp;MASM accepts several optional switches in the command line, to control
<br>
&nbsp;code generation and output files. Figure 4-1 lists the switches accepted
<br>
&nbsp;by MASM version 5.1. As shown in the following example, you can put
<br>
&nbsp;frequently used options in a MASM environment variable, where they will be
<br>
&nbsp;found automatically by the assembler:
<br>
<br>
&nbsp;C&gt;SET MASM=/T /Zi &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;The switches in the environment variable will be overridden by any that
<br>
&nbsp;you enter in the command line.
<br>
<br>
&nbsp;In other versions of the Microsoft Macro Assembler, additional or fewer
<br>
&nbsp;switches may be available. For exact instructions, see the manual for the
<br>
&nbsp;version of MASM that you are using.
<br>
<br>
<br>
&nbsp;Switch &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;/A &nbsp; &nbsp; &nbsp; &nbsp; Arrange segments in alphabetic order.
<br>
&nbsp;/Bn &nbsp; &nbsp; &nbsp; &nbsp;Set size of source-file buffer (in KB).
<br>
&nbsp;/C &nbsp; &nbsp; &nbsp; &nbsp; Force creation of a cross-reference (.CRF) file.
<br>
&nbsp;/D &nbsp; &nbsp; &nbsp; &nbsp; Produce listing on both passes (to find phase errors).
<br>
&nbsp;/Dsymbol &nbsp; Define symbol as a null text string (symbol can be referenced
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; by conditional assembly directives in file).
<br>
&nbsp;/E &nbsp; &nbsp; &nbsp; &nbsp; Assemble for 80x87 numeric coprocessor emulator using IEEE
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; real-number format.
<br>
&nbsp;/Ipath &nbsp; &nbsp; Set search path for include files.
<br>
&nbsp;/L &nbsp; &nbsp; &nbsp; &nbsp; Force creation of a program-listing file.
<br>
&nbsp;/LA &nbsp; &nbsp; &nbsp; &nbsp;Force listing of all generated code.
<br>
&nbsp;/ML &nbsp; &nbsp; &nbsp; &nbsp;Preserve case sensitivity in all names (uppercase names
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distinct from their lowercase equivalents).
<br>
&nbsp;/MX &nbsp; &nbsp; &nbsp; &nbsp;Preserve lowercase in external names only (names defined with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUBLIC or EXTRN directives).
<br>
&nbsp;/MU &nbsp; &nbsp; &nbsp; &nbsp;Convert all lowercase names to uppercase.
<br>
&nbsp;/N &nbsp; &nbsp; &nbsp; &nbsp; Suppress generation of tables of macros, structures, records,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segments, groups, and symbols at the end of the listing.
<br>
&nbsp;/P &nbsp; &nbsp; &nbsp; &nbsp; Check for impure code in 80286/80386 protected mode.
<br>
&nbsp;/S &nbsp; &nbsp; &nbsp; &nbsp; Arrange segments in order of occurrence (default).
<br>
&nbsp;/T &nbsp; &nbsp; &nbsp; &nbsp; &quot;Terse&quot; mode; suppress all messages unless errors are
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encountered during the assembly.
<br>
&nbsp;/V &nbsp; &nbsp; &nbsp; &nbsp; &quot;Verbose&quot; mode; report number of lines and symbols at end of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assembly.
<br>
&nbsp;/Wn &nbsp; &nbsp; &nbsp; &nbsp;Set error display (warning) level; n=0─2.
<br>
&nbsp;/X &nbsp; &nbsp; &nbsp; &nbsp; Force listing of false conditionals.
<br>
&nbsp;/Z &nbsp; &nbsp; &nbsp; &nbsp; Display source lines containing errors on the screen.
<br>
&nbsp;/Zd &nbsp; &nbsp; &nbsp; &nbsp;Include line-number information in .OBJ file.
<br>
&nbsp;/Zi &nbsp; &nbsp; &nbsp; &nbsp;Include line-number and symbol information in .OBJ file.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 4-1. &nbsp;Microsoft Macro Assembler version 5.1 switches.
<br>
<br>
&nbsp;MASM allows you to override the default extensions on any file──a feature
<br>
&nbsp;that can be rather dangerous. For example, if in the preceding example you
<br>
&nbsp;had responded to the Object filename prompt with HELLO.ASM, the assembler
<br>
&nbsp;would have accepted the entry without comment and destroyed your source
<br>
&nbsp;file. This is not too likely to happen in the interactive command mode,
<br>
&nbsp;but you must be very careful with file extensions when MASM is used in a
<br>
&nbsp;batch file.
<br>
<br>
<br>
The Microsoft C Optimizing Compiler
<br>
<br>
&nbsp;The Microsoft C Optimizing Compiler consists of three executable files──
<br>
&nbsp;C1.EXE, C2.EXE, and C3.EXE──that implement the C preprocessor, language
<br>
&nbsp;translator, code generator, and code optimizer. An additional control
<br>
&nbsp;program, CL.EXE, executes the three compiler files in order, passing each
<br>
&nbsp;the necessary information about filenames and compilation options.
<br>
<br>
&nbsp;Before using the C compiler and the linker, you need to set up four
<br>
&nbsp;environment variables:
<br>
<br>
&nbsp;Variable &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;PATH=path &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Specifies the location of the three executable C
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compiler files (C1, C2, and C3) if they are not
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in the current directory; used by CL.EXE.
<br>
<br>
&nbsp;INCLUDE=path &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the location of #include files (default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extension .H) that are not found in the current
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; directory.
<br>
<br>
&nbsp;LIB=path &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the location(s) for object-code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; libraries that are not found in the current
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; directory.
<br>
<br>
&nbsp;TMP=path &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specifies the location for temporary working
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; files created by the C compiler and linker.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;CL.EXE does not support an interactive mode or response files. You always
<br>
&nbsp;invoke it with a command line of the following form:
<br>
<br>
&nbsp; &nbsp;CL [options] file [file ...]
<br>
<br>
&nbsp;You may list any number of files──if a file has a .C extension, it will be
<br>
&nbsp;compiled into a relocatable-object-module (.OBJ) file. Ordinarily, if the
<br>
&nbsp;compiler encounters no errors, it automatically passes all resulting .OBJ
<br>
&nbsp;files and any additional .OBJ files specified in the command line to the
<br>
&nbsp;linker, along with the names of the appropriate runtime libraries.
<br>
<br>
&nbsp;The C compiler has many optional switches controlling its memory models,
<br>
&nbsp;output files, code generation, and code optimization. These are summarized
<br>
&nbsp;in Figure 4-2. The C compiler's arcane switch syntax is derived largely
<br>
&nbsp;from UNIX/XENIX, so don't expect it to make any sense.
<br>
<br>
<br>
&nbsp;Switch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;/Ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select memory model:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C = compact model
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; H = huge model
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L = large model
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; M = medium model
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; S = small model (default)
<br>
&nbsp;/c &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Compile only; do not invoke linker.
<br>
&nbsp;/C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Do not strip comments.
<br>
&nbsp;/D&lt;name&gt;[=text] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Define macro.
<br>
&nbsp;/E &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Send preprocessor output to standard output.
<br>
&nbsp;/EP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Send preprocessor output to standard output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; without line numbers.
<br>
&nbsp;/F&lt;n&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set stack size (in hexadecimal bytes).
<br>
&nbsp;/Fa [filename] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Generate assembly listing.
<br>
&nbsp;/Fc [filename] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Generate mixed source/object listing.
<br>
&nbsp;/Fe [filename] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Force executable filename.
<br>
&nbsp;/Fl [filename] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Generate object listing.
<br>
&nbsp;/Fm [filename] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Generate map file.
<br>
&nbsp;/Fo [filename] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Force object-module filename.
<br>
&nbsp;/FPx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Select floating-point control:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = calls with alternate math library
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = calls with emulator library
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c87 = calls with 8087 library
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = in-line with emulator (default)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i87 = in-line with 8087
<br>
&nbsp;/Fs [filename] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Generate source listing.
<br>
&nbsp;/Gx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select code generation:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 = 8086 instructions (default)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 = 186 instructions
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 = 286 instructions
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = Pascal style function calls
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = no stack checking
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t[n] = data size threshold
<br>
&nbsp;/H&lt;n&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Specify external name length.
<br>
&nbsp;/I&lt;path&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specify additional #include path.
<br>
&nbsp;/J &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Specify default char type as unsigned.
<br>
&nbsp;/link [options] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Pass switches and library names to linker.
<br>
&nbsp;/Ox &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select optimization:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = ignore aliasing
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d = disable optimizations
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = enable intrinsic functions
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = enable loop optimizations
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = disable &quot;unsafe&quot; optimizations
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = enable precision optimizations
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = disable in-line return
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = optimize for space
<br>
&nbsp;/Ox &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t = optimize for speed (default)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = ignore aliasing except across function
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; calls
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = enable maximum optimization (equivalent to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /Oailt /Gs)
<br>
&nbsp;/P &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Send preprocessor output to file.
<br>
&nbsp;/Sx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select source-listing control:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l&lt;columns&gt; = set line width
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p&lt;lines&gt; = set page length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s&lt;string&gt; = set subtitle string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t&lt;string&gt; = set title string
<br>
&nbsp;/Tc&lt;file&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Compile file without .C extension.
<br>
&nbsp;/u &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remove all predefined macros.
<br>
&nbsp;/U&lt;name&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remove specified predefined macro.
<br>
&nbsp;/V&lt;string&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set version string.
<br>
&nbsp;/W&lt;n&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set warning level (0─3).
<br>
&nbsp;/X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ignore &quot;standard places&quot; for include files.
<br>
&nbsp;/Zx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select miscellaneous compilation control:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = disable extensions
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = make Pascal functions case-insensitive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d = include line-number information
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = enable extensions (default)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g = generate declarations
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = include symbolic debugging information
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = remove default library info
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p&lt;n&gt; = pack structures on n-byte boundary
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = check syntax only
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 4-2. &nbsp;Microsoft C Optimizing Compiler version 5.1 switches.
<br>
<br>
<br>
The Microsoft Object Linker
<br>
<br>
&nbsp;The object module produced by MASM from a source file is in a form that
<br>
&nbsp;contains relocation information and may also contain unresolved references
<br>
&nbsp;to external locations or subroutines. It is written in a common format
<br>
&nbsp;that is also produced by the various high-level compilers (such as FORTRAN
<br>
&nbsp;and C) that run under MS-DOS. The computer cannot execute object modules
<br>
&nbsp;without further processing.
<br>
<br>
&nbsp;The Microsoft Object Linker (LINK), distributed as the file LINK.EXE,
<br>
&nbsp;accepts one or more of these object modules, resolves external references,
<br>
&nbsp;includes any necessary routines from designated libraries, performs any
<br>
&nbsp;necessary offset relocations, and writes a file that can be loaded and
<br>
&nbsp;executed by MS-DOS. The output of LINK is always in .EXE load-module
<br>
&nbsp;format. (See Chapter 3.)
<br>
<br>
&nbsp;As with MASM, you can give LINK its parameters interactively or by
<br>
&nbsp;entering all the required information in a single command line. If you
<br>
&nbsp;enter the name of the linker alone, the following type of dialog ensues:
<br>
<br>
&nbsp;C&gt;LINK &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;Microsoft (R) Overlay Linker &nbsp;Version 3.61
<br>
&nbsp;Copyright (C) Microsoft Corp 1983-1987. All rights reserved.
<br>
<br>
&nbsp;Object Modules [.OBJ]: HELLO &nbsp;&lt;Enter&gt;
<br>
&nbsp;Run File [HELLO.EXE]: &nbsp;&lt;Enter&gt;
<br>
&nbsp;List File [NUL.MAP]: HELLO &nbsp;&lt;Enter&gt;
<br>
&nbsp;Libraries [.LIB]: &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;C&gt;
<br>
<br>
&nbsp;If you are using LINK version 4.0 or later, the linker also asks for the
<br>
&nbsp;name of a module-definition (.DEF) file. Simply press the Enter key in
<br>
&nbsp;response to such a prompt. Module-definition files are used when building
<br>
&nbsp;Microsoft Windows or MS OS/2 &quot;new .EXE&quot; executable files but are not
<br>
&nbsp;relevant in normal MS-DOS applications.
<br>
<br>
&nbsp;The input file for this example was HELLO.OBJ; the output files were
<br>
&nbsp;HELLO.EXE (the executable program) and HELLO.MAP (the load map produced by
<br>
&nbsp;the linker after all references and addresses were resolved). Figure 4-3
<br>
&nbsp;shows the load map.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; Start &nbsp;Stop &nbsp; Length Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class
<br>
&nbsp; 00000H 00017H 00018H _TEXT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CODE
<br>
&nbsp; 00018H 00027H 00010H _DATA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DATA
<br>
&nbsp; 00030H 000AFH 00080H STACK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STACK
<br>
&nbsp; 000B0H 000BBH 0000CH $$TYPES &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DEBTYP
<br>
&nbsp; 000C0H 000D6H 00017H $$SYMBOLS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DEBSYM
<br>
<br>
&nbsp; &nbsp;Address &nbsp; &nbsp; &nbsp; &nbsp; Publics by Name
<br>
<br>
&nbsp; &nbsp;Address &nbsp; &nbsp; &nbsp; &nbsp; Publics by Value
<br>
<br>
&nbsp;Program entry point at 0000:0000
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 4-3. &nbsp;Map produced by the Microsoft Object Linker (LINK) during the
<br>
&nbsp;generation of the HELLO.EXE program from Chapter 3. The program contains
<br>
&nbsp;one CODE, one DATA, and one STACK segment. The first instruction to be
<br>
&nbsp;executed lies in the first byte of the CODE segment. The $$TYPES and
<br>
&nbsp;$$SYMBOLS segments contain information for the CodeView debugger and are
<br>
&nbsp;not part of the program; these segments are ignored by the normal MS-DOS
<br>
&nbsp;loader.
<br>
<br>
&nbsp;You can obtain the same result more quickly by entering all parameters in
<br>
&nbsp;the command line, in the following form:
<br>
<br>
&nbsp; &nbsp;LINK options objectfile, [exefile], [mapfile], [libraries]
<br>
<br>
&nbsp;Thus, the command-line equivalent to the preceding interactive session is
<br>
<br>
&nbsp;C&gt;LINK HELLO,HELLO,HELLO,, &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;or
<br>
<br>
&nbsp;C&gt;LINK HELLO,,HELLO; &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;If you enter a semicolon as the last character in the command line, LINK
<br>
&nbsp;assumes the default values for all further parameters.
<br>
<br>
&nbsp;A third method of commanding LINK is with a response file. A response file
<br>
&nbsp;contains lines of text that correspond to the responses you would give the
<br>
&nbsp;linker interactively. You specify the name of the response file in the
<br>
&nbsp;command line with a leading @ character, as follows:
<br>
<br>
&nbsp; &nbsp;LINK @filename
<br>
<br>
&nbsp;You can also enter the name of a response file at any prompt. If the
<br>
&nbsp;response file is not complete, LINK will prompt you for the missing
<br>
&nbsp;information.
<br>
<br>
&nbsp;When entering linker commands, you can specify multiple object files with
<br>
&nbsp;the + operator or with spaces, as in the following example:
<br>
<br>
&nbsp;C&gt;LINK HELLO+VMODE+DOSINT,MYPROG,,GRAPHICS; &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;This command would link the files HELLO.OBJ, VMODE.OBJ, and DOSINT.OBJ,
<br>
&nbsp;searching the library file GRAPHICS.LIB to resolve any references to
<br>
&nbsp;symbols not defined in the specified object files, and would produce a
<br>
&nbsp;file named MYPROG.EXE. LINK uses the current drive and directory when they
<br>
&nbsp;are not explicitly included in a filename; it will not automatically use
<br>
&nbsp;the same drive and directory you specified for a previous file in the same
<br>
&nbsp;command line.
<br>
<br>
&nbsp;By using the + operator or space characters in the libraries field, you
<br>
&nbsp;can specify up to 32 library files to be searched. Each high-level-
<br>
&nbsp;language compiler provides default libraries that are searched
<br>
&nbsp;automatically during the linkage process if the linker can find them
<br>
&nbsp;(unless they are explicitly excluded with the /NOD switch). LINK looks for
<br>
&nbsp;libraries first in the current directory of the default disk drive, then
<br>
&nbsp;along any paths that were provided in the command line, and finally along
<br>
&nbsp;the path(s) specified by the LIB variable if it is present in the
<br>
&nbsp;environment.
<br>
<br>
&nbsp;LINK accepts several optional switches as part of the command line or at
<br>
&nbsp;the end of any interactive prompt. Figure 4-4 lists these switches. The
<br>
&nbsp;number of switches available and their actions vary among different
<br>
&nbsp;versions of LINK. See your Microsoft Object Linker instruction manual for
<br>
&nbsp;detailed information about your particular version.
<br>
<br>
<br>
&nbsp;Switch &nbsp; Full form &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;/A:n &nbsp; &nbsp; /ALIGNMENT:n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set segment sector alignment factor.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N must be a power of 2 (default =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 512). Not related to logical-segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alignment (BYTE, WORD, PARA, PAGE,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and so forth). Relevant to segmented
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; executable files (Microsoft Windows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and MS OS/2) only.
<br>
<br>
&nbsp;/B &nbsp; &nbsp; &nbsp; /BATCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Suppress linker prompt if a library
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cannot be found in the current
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; directory or in the locations
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specified by the LIB environment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; variable.
<br>
<br>
&nbsp;/CO &nbsp; &nbsp; &nbsp;/CODEVIEW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Include symbolic debugging
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; information in the .EXE file for use
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; by CodeView.
<br>
<br>
&nbsp;/CP &nbsp; &nbsp; &nbsp;/CPARMAXALLOC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set the field in the .EXE file header
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; controlling the amount of memory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocated to the program in addition
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to the memory required for the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; program's code, stack, and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initialized data.
<br>
<br>
&nbsp;/DO &nbsp; &nbsp; &nbsp;/DOSSEG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use standard Microsoft segment naming
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and ordering conventions.
<br>
<br>
&nbsp;/DS &nbsp; &nbsp; &nbsp;/DSALLOCATE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Load data at high end of the data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment. Relevant to real-mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; programs only.
<br>
<br>
&nbsp;/E &nbsp; &nbsp; &nbsp; /EXEPACK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Pack executable file by removing
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sequences of repeated bytes and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optimizing relocation table.
<br>
<br>
&nbsp;/F &nbsp; &nbsp; &nbsp; /FARCALLTRANSLATION &nbsp; &nbsp; &nbsp; &nbsp; Optimize far calls to labels within
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the same physical segment for speed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; by replacing them with near calls and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NOPs.
<br>
<br>
&nbsp;/HE &nbsp; &nbsp; &nbsp;/HELP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Display information about available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options.
<br>
<br>
&nbsp;/HI &nbsp; &nbsp; &nbsp;/HIGH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Load program as high in memory as
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; possible.
<br>
<br>
&nbsp;/I &nbsp; &nbsp; &nbsp; /INFORMATION &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Display information about progress of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linking, including pass numbers and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the names of object files being
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linked.
<br>
<br>
&nbsp;/INC &nbsp; &nbsp; /INCREMENTAL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Force production of .SYM and .ILK
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; files for subsequent use by ILINK
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (incremental linker). May not be used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with /EXEPACK. Relevant to segmented
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; executable files (Microsoft Windows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and MS OS/2) only.
<br>
<br>
&nbsp;/LI &nbsp; &nbsp; &nbsp;/LINENUMBERS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write address of the first
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instruction that corresponds to each
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; source-code line to the map file. Has
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no effect if the compiler does not
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; include line-number information in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the object module. Force creation of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a map file.
<br>
<br>
&nbsp;/M[:n] &nbsp; /MAP[:n] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Force creation of a .MAP file listing
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all public symbols, sorted by name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and by location. The optional value n
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is the maximum number of symbols that
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can be sorted (default = 2048); when
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n is supplied, the alphabetically
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sorted list is omitted.
<br>
<br>
&nbsp;/NOD &nbsp; &nbsp; /NODEFAULTLIBRARYSEARCH &nbsp; &nbsp; Skip search of any default compiler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; libraries specified in the .OBJ file.
<br>
<br>
&nbsp;/NOE &nbsp; &nbsp; /NOEXTENDEDDICTSEARCH &nbsp; &nbsp; &nbsp; Ignore extended library dictionary
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if it is present). The extended
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dictionary ordinarily provides the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linker with information about
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inter-module dependencies, to speed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; up linking.
<br>
<br>
&nbsp;/NOF &nbsp; &nbsp; /NOFARCALLTRANSLATION &nbsp; &nbsp; &nbsp; Disable optimization of far calls to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; labels within the same segment.
<br>
<br>
&nbsp;/NOG &nbsp; &nbsp; /NOGROUPASSOCIATION &nbsp; &nbsp; &nbsp; &nbsp; Ignore group associations when
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assigning addresses to data and code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items.
<br>
<br>
&nbsp;/NOI &nbsp; &nbsp; /NOIGNORECASE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Do not ignore case in names during
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linking.
<br>
<br>
&nbsp;/NON &nbsp; &nbsp; /NONULLSDOSSEG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Arrange segments as for /DOSSEG but
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do not insert 16 null bytes at start
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of _TEXT segment.
<br>
<br>
&nbsp;/NOP &nbsp; &nbsp; /NOPACKCODE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Do not pack contiguous logical code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segments into a single physical
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment.
<br>
<br>
&nbsp;/O:n &nbsp; &nbsp; /OVERLAYINTERRUPT:n &nbsp; &nbsp; &nbsp; &nbsp; Use interrupt number n with the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overlay manager supplied with some
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Microsoft high-level languages.
<br>
<br>
&nbsp;/PAC[:n] /PACKCODE[:n] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pack contiguous logical code segments
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; into a single physical code segment.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The optional value n is the maximum
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size for each packed physical code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment (default = 65,536 bytes).
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Segments in different groups are not
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; packed.
<br>
<br>
&nbsp;/PADC:n &nbsp;/PADCODE:n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Add n filler bytes to end of each
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; code module so that a larger module
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can be inserted later with ILINK.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relevant to segmented executable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; files (Windows and MS OS/2) only.
<br>
<br>
&nbsp;/PADD:n &nbsp;/PADDATA:n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Add n filler bytes to end of each
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data module so that a larger module
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can be inserted later with ILINK.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relevant to segmented executable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; files (Microsoft Windows and MS OS/2)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; only.
<br>
<br>
&nbsp;/PAU &nbsp; &nbsp; /PAUSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Pause during linking, allowing a
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change of disks before .EXE file is
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written.
<br>
<br>
&nbsp;/SE:n &nbsp; &nbsp;/SEGMENTS:n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set maximum number of segments in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linked program (default = 128).
<br>
<br>
&nbsp;/ST:n &nbsp; &nbsp;/STACK:n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set stack size of program in bytes;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignore stack segment size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; declarations within object modules
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and definition file.
<br>
<br>
&nbsp;/W &nbsp; &nbsp; &nbsp; /WARNFIXUP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Display warning messages for offsets
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relative to a segment base that is
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not the same as the group base.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relevant to segmented executable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; files (Microsoft Windows and MS OS/2)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; only.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 4-4. &nbsp;Switches accepted by the Microsoft Object Linker (LINK)
<br>
&nbsp;version 5.0. Earlier versions use a subset of these switches. Note that
<br>
&nbsp;any abbreviation for a switch is acceptable as long as it is sufficient to
<br>
&nbsp;specify the switch uniquely.
<br>
<br>
<br>
The EXE2BIN Utility
<br>
<br>
&nbsp;The EXE2BIN utility (EXE2BIN.EXE) transforms a .EXE file created by LINK
<br>
&nbsp;into an executable .COM file, if the program meets the following
<br>
&nbsp;prerequisites:
<br>
<br>
&nbsp;■ &nbsp;It cannot contain more than one declared segment and cannot
<br>
&nbsp; &nbsp; define a stack.
<br>
<br>
&nbsp;■ &nbsp;It must be less than 64 KB in length.
<br>
<br>
&nbsp;■ &nbsp;It must have an origin at 0100H.
<br>
<br>
&nbsp;■ &nbsp;The first location in the file must be specified as the entry point
<br>
&nbsp; &nbsp; in the source code's END directive.
<br>
<br>
&nbsp;Although .COM files are somewhat more compact than .EXE files, you should
<br>
&nbsp;avoid using them. Programs that use separate segments for code, data, and
<br>
&nbsp;stack are much easier to port to protected-mode environments such as MS
<br>
&nbsp;OS/2; in addition, .COM files do not support the symbolic debugging
<br>
&nbsp;information used by CodeView.
<br>
<br>
&nbsp;Another use for the EXE2BIN utility is to convert an installable device
<br>
&nbsp;driver──after it is assembled and linked into a .EXE file──into a
<br>
&nbsp;memory-image .BIN or .SYS file with an origin of zero. This conversion is
<br>
&nbsp;required in MS-DOS version 2, which cannot load device drivers as .EXE
<br>
&nbsp;files. The process of writing an installable device driver is discussed in
<br>
&nbsp;more detail in Chapter 14.
<br>
<br>
&nbsp;Unlike most of the other programming utilities, EXE2BIN does not have an
<br>
&nbsp;interactive mode. It always takes its source and destination filenames,
<br>
&nbsp;separated by spaces, from the MS-DOS command line, as follows:
<br>
<br>
&nbsp; &nbsp;EXE2BIN sourcefile [destinationfile]
<br>
<br>
&nbsp;If you do not supply the source-file extension, it defaults to .EXE; the
<br>
&nbsp;destination-file extension defaults to .BIN. If you do not specify a name
<br>
&nbsp;for the destination file, EXE2BIN gives it the same name as the source
<br>
&nbsp;file, with a .BIN extension.
<br>
<br>
&nbsp;For example, to convert the file HELLO.EXE into HELLO.COM, you would use
<br>
&nbsp;the following command line:
<br>
<br>
&nbsp;C&gt;EXE2BIN HELLO.EXE HELLO.COM &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;The EXE2BIN program also has other capabilities, such as pure binary
<br>
&nbsp;conversion with segment fixup for creating program images to be placed in
<br>
&nbsp;ROM; but because these features are rarely used during MS-DOS application
<br>
&nbsp;development, they will not be discussed here.
<br>
<br>
<br>
The CREF Utility
<br>
<br>
&nbsp;The CREF cross-reference utility CREF.EXE processes a .CRF file produced
<br>
&nbsp;by MASM, creating an ASCII text file with the default extension .REF. The
<br>
&nbsp;file contains a cross-reference listing of all symbols declared in the
<br>
&nbsp;program and the line numbers in which they are referenced. (See Figure
<br>
&nbsp;4-5.) Such a listing is very useful when debugging large
<br>
&nbsp;assembly-language programs with many interdependent procedures and
<br>
&nbsp;variables.
<br>
<br>
&nbsp;CREF may be supplied with its parameters interactively or in a single
<br>
&nbsp;command line. If you enter the utility name alone, CREF prompts you for
<br>
&nbsp;the input and output filenames, as shown in the following example:
<br>
<br>
&nbsp;C&gt;CREF &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;Microsoft (R) Cross-Reference Utility &nbsp;Version 5.10
<br>
&nbsp;Copyright (C) Microsoft Corp 1981-1985, 1987. All rights reserved.
<br>
<br>
&nbsp;Cross-reference [.CRF]: HELLO &nbsp;&lt;Enter&gt;
<br>
&nbsp;Listing [HELLO.REF]:
<br>
<br>
&nbsp;15 Symbols
<br>
<br>
&nbsp;C&gt;
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Microsoft Cross-Reference &nbsp;Version 5.10 &nbsp; &nbsp; &nbsp; Thu May 26 11:09:34 1988
<br>
&nbsp;HELLO.EXE --- print Hello on terminal
<br>
<br>
&nbsp; &nbsp;Symbol Cross-Reference &nbsp; &nbsp;(# definition, + modification)Cref-1
<br>
<br>
&nbsp;@CPU . . . . . . . . . . . . . . &nbsp; 1#
<br>
&nbsp;@VERSION . . . . . . . . . . . . &nbsp; 1#
<br>
<br>
&nbsp;CODE . . . . . . . . . . . . . . &nbsp;21
<br>
&nbsp;CR . . . . . . . . . . . . . . . &nbsp;17# &nbsp; &nbsp;46 &nbsp; &nbsp; 47
<br>
<br>
&nbsp;DATA . . . . . . . . . . . . . . &nbsp;44
<br>
<br>
&nbsp;LF . . . . . . . . . . . . . . . &nbsp;18# &nbsp; &nbsp;46 &nbsp; &nbsp; 47
<br>
<br>
&nbsp;MSG. . . . . . . . . . . . . . . &nbsp;33 &nbsp; &nbsp; 46#
<br>
&nbsp;MSG_LEN. . . . . . . . . . . . . &nbsp;32 &nbsp; &nbsp; 49#
<br>
<br>
&nbsp;PRINT. . . . . . . . . . . . . . &nbsp;25# &nbsp; &nbsp;39 &nbsp; &nbsp; 60
<br>
<br>
&nbsp;STACK. . . . . . . . . . . . . . &nbsp;23 &nbsp; &nbsp; 54# &nbsp; &nbsp;54 &nbsp; &nbsp; 58
<br>
&nbsp;STDERR . . . . . . . . . . . . . &nbsp;15#
<br>
&nbsp;STDIN. . . . . . . . . . . . . . &nbsp;13#
<br>
&nbsp;STDOUT . . . . . . . . . . . . . &nbsp;14# &nbsp; &nbsp;31
<br>
<br>
&nbsp;_DATA. . . . . . . . . . . . . . &nbsp;23 &nbsp; &nbsp; 27 &nbsp; &nbsp; 44# &nbsp; &nbsp;51
<br>
&nbsp;_TEXT. . . . . . . . . . . . . . &nbsp;21# &nbsp; &nbsp;23 &nbsp; &nbsp; 41
<br>
<br>
&nbsp; 15 Symbols
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 4-5. &nbsp;Cross-reference listing HELLO.REF produced by the CREF
<br>
&nbsp;utility from the file HELLO.CRF, for the HELLO.EXE program example from
<br>
&nbsp;Chapter 3. The symbols declared in the program are listed on the left in
<br>
&nbsp;alphabetic order. To the right of each symbol is a list of all the lines
<br>
&nbsp;where that symbol is referenced. The number with a # sign after it denotes
<br>
&nbsp;the line where the symbol is declared. Numbers followed by a + sign
<br>
&nbsp;indicate that the symbol is modified at the specified line. The line
<br>
&nbsp;numbers given in the cross-reference listing correspond to the line
<br>
&nbsp;numbers generated by the assembler in the program-listing (.LST) file, not
<br>
&nbsp;to any physical line count in the original source file.
<br>
<br>
&nbsp;The parameters may also be entered in the command line in the following
<br>
&nbsp;form:
<br>
<br>
&nbsp; &nbsp;CREF CRF_file, listing_file
<br>
<br>
&nbsp;For example, the command-line equivalent to the preceding interactive
<br>
&nbsp;session is:
<br>
<br>
&nbsp;C&gt;CREF HELLO,HELLO &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;If CREF cannot find the specified .CRF file, it displays an error message.
<br>
&nbsp;Otherwise, it leaves the cross-reference listing in the specified file on
<br>
&nbsp;the disk. You can send the file to the printer with the COPY command, in
<br>
&nbsp;the following form:
<br>
<br>
&nbsp; &nbsp;COPY listing_file PRN:
<br>
<br>
&nbsp;You can also send the cross-reference listing directly to a character
<br>
&nbsp;device as it is generated by responding to the Listing prompt with the
<br>
&nbsp;name of the device.
<br>
<br>
<br>
The Microsoft Library Manager
<br>
<br>
&nbsp;Although the object modules that are produced by MASM or by high-level-
<br>
&nbsp;language compilers can be linked directly into executable load modules,
<br>
&nbsp;they can also be collected into special files called object-module
<br>
&nbsp;libraries. The modules in a library are indexed by name and by the public
<br>
&nbsp;symbols they contain, so that they can be extracted by the linker to
<br>
&nbsp;satisfy external references in a program.
<br>
<br>
&nbsp;The Microsoft Library Manager (LIB) is distributed as the file LIB.EXE.
<br>
&nbsp;LIB creates and maintains program libraries, adding, updating, and
<br>
&nbsp;deleting object files as necessary. LIB can also check a library file for
<br>
&nbsp;internal consistency or print a table of its contents (Figure 4-6).
<br>
<br>
&nbsp;LIB follows the command conventions of most other Microsoft programming
<br>
&nbsp;tools. You must supply it with the name of a library file to work on, one
<br>
&nbsp;or more operations to perform, the name of a listing file or device, and
<br>
&nbsp;(optionally) the name of the output library. If you do not specify a name
<br>
&nbsp;for the output library, LIB gives it the same name as the input library
<br>
&nbsp;and changes the extension of the input library to .BAK.
<br>
<br>
&nbsp;The LIB operations are simply the names of object files, with a prefix
<br>
&nbsp;character that specifies the action to be taken:
<br>
<br>
&nbsp;Prefix &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Delete an object module from the library.
<br>
&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Extract a module and place it in a separate .OBJ file.
<br>
&nbsp;+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Add an object module or the entire contents of another library
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to the library.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;You can combine command prefixes. For example, -+ replaces a module, and
<br>
&nbsp;*- extracts a module into a new file and then deletes it from the library.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;_abort............abort &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _abs..............abs
<br>
&nbsp;_access...........access &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_asctime..........asctime
<br>
&nbsp;_atof.............atof &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_atoi.............atoi
<br>
&nbsp;_atol.............atol &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_bdos.............bdos
<br>
&nbsp;_brk..............brk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _brkctl...........brkctl
<br>
&nbsp;_bsearch..........bsearch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _calloc...........calloc
<br>
&nbsp;_cgets............cgets &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _chdir............dir
<br>
&nbsp;_chmod............chmod &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _chsize...........chsize
<br>
&nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; .
<br>
&nbsp;_exit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Offset: 00000010H &nbsp;Code and data size: 44H
<br>
&nbsp; &nbsp;__exit
<br>
<br>
&nbsp;_filbuf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Offset: 00000160H &nbsp;Code and data size: BBH
<br>
&nbsp; &nbsp;__filbuf
<br>
<br>
&nbsp;_file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Offset: 00000300H &nbsp;Code and data size: CAH
<br>
&nbsp; &nbsp;__iob &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __iob2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__lastiob
<br>
&nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; .
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 4-6. &nbsp;Extract from the table-of-contents listing produced by the
<br>
&nbsp;Microsoft Library Manager (LIB) for the Microsoft C library SLIBC.LIB. The
<br>
&nbsp;first part of the listing is an alphabetic list of all public names
<br>
&nbsp;declared in all of the modules in the library. Each name is associated
<br>
&nbsp;with the object module to which it belongs. The second part of the listing
<br>
&nbsp;is an alphabetic list of the object-module names in the library, each
<br>
&nbsp;followed by its offset within the library file and the actual size of the
<br>
&nbsp;module in bytes. The entry for each module is followed by a summary of the
<br>
&nbsp;public names that are declared within it.
<br>
<br>
&nbsp;When you invoke LIB with its name alone, it requests the other information
<br>
&nbsp;it needs interactively, as shown in the following example:
<br>
<br>
&nbsp;C&gt;LIB &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;Microsoft (R) Library Manager &nbsp;Version 3.08
<br>
&nbsp;Copyright (C) Microsoft Corp 1983-1987. All rights reserved.
<br>
<br>
&nbsp;Library name: &nbsp;SLIBC &nbsp;&lt;Enter&gt;
<br>
&nbsp;Operations: +VIDEO &nbsp;&lt;Enter&gt;
<br>
&nbsp;List file: &nbsp;SLIBC.LST &nbsp;&lt;Enter&gt;
<br>
&nbsp;Output library: &nbsp;SLIBC2 &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;C&gt;
<br>
<br>
&nbsp;In this example, LIB added the object module VIDEO.OBJ to the library
<br>
&nbsp;SLIBC.LIB, wrote a library table of contents into the file SLIBC.LST, and
<br>
&nbsp;named the resulting new library SLIBC2.LIB.
<br>
<br>
&nbsp;The Library Manager can also be run with a command line of the following
<br>
&nbsp;form:
<br>
<br>
&nbsp; &nbsp;LIB library [commands],[list],[newlibrary]
<br>
<br>
&nbsp;For example, the following command line is equivalent to the preceding
<br>
&nbsp;interactive session:
<br>
<br>
&nbsp;C&gt;LIB SLIBC +VIDEO,SLIBC.LST,SLIBC2; &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;As with the other Microsoft utilities, a semicolon at the end of the
<br>
&nbsp;command line causes LIB to use the default responses for any parameters
<br>
&nbsp;that are omitted.
<br>
<br>
&nbsp;Like LINK, LIB can also accept its commands from a response file. The
<br>
&nbsp;contents of the file are lines of text that correspond exactly to the
<br>
&nbsp;responses you would give LIB interactively. You specify the name of the
<br>
&nbsp;response file in the command line with a leading @ character, as follows:
<br>
<br>
&nbsp; &nbsp;LIB @filename
<br>
<br>
&nbsp;LIB has only three switches: /I (/IGNORECASE), /N (/NOIGNORECASE), and
<br>
&nbsp;/PAGESIZE:number. The /IGNORECASE switch is the default. The /NOIGNORECASE
<br>
&nbsp;switch causes LIB to regard as distinct any symbols that differ only in
<br>
&nbsp;the case of their component letters. You should place the /PAGESIZE
<br>
&nbsp;switch, which defines the size of a unit of allocation space for a given
<br>
&nbsp;library, immediately after the library filename. The library page size is
<br>
&nbsp;in bytes and must be a power of 2 between 16 and 32,768 (16, 32, 64, and
<br>
&nbsp;so forth); the default is 16 bytes. Because the index to a library is
<br>
&nbsp;always a fixed number of pages, setting a larger page size allows you to
<br>
&nbsp;store more object modules in that library; on the other hand, it will
<br>
&nbsp;result in more wasted space within the file.
<br>
<br>
<br>
The MAKE Utility
<br>
<br>
&nbsp;The MAKE utility (MAKE.EXE) compares dates of files and carries out
<br>
&nbsp;commands based on the result of that comparison. Because of this single,
<br>
&nbsp;rather basic capability, MAKE can be used to maintain complex programs
<br>
&nbsp;built from many modules. The dates of source, object, and executable files
<br>
&nbsp;are simply compared in a logical sequence; the assembler, compiler,
<br>
&nbsp;linker, and other programming tools are invoked as appropriate.
<br>
<br>
&nbsp;The MAKE utility processes a plain ASCII text file called, as you might
<br>
&nbsp;expect, a make file. You start the utility with a command-line entry in
<br>
&nbsp;the following form:
<br>
<br>
&nbsp; &nbsp;MAKE makefile [options]
<br>
<br>
&nbsp;By convention, a make file has the same name as the executable file that
<br>
&nbsp;is being maintained, but without an extension. The available MAKE switches
<br>
&nbsp;are listed in Figure 4-7.
<br>
<br>
&nbsp;A simple make file contains one or more dependency statements separated by
<br>
&nbsp;blank lines. Each dependency statement can be followed by a list of MS-DOS
<br>
&nbsp;commands, in the following form:
<br>
<br>
&nbsp; &nbsp;targetfile : sourcefile ...
<br>
<br>
&nbsp; &nbsp; &nbsp;command
<br>
<br>
&nbsp; &nbsp; &nbsp;command
<br>
<br>
&nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;If the date and time of any source file are later than those of the target
<br>
&nbsp;file, the accompanying list of commands is carried out. You may use
<br>
&nbsp;comment lines, which begin with a # character, freely in a make file. MAKE
<br>
&nbsp;can also process inference rules and macro definitions. For further
<br>
&nbsp;details on these advanced capabilities, see the Microsoft or IBM
<br>
&nbsp;documentation.
<br>
<br>
&nbsp;Switch &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;/D &nbsp; &nbsp; &nbsp; &nbsp; Display last modification date of each file as it is processed.
<br>
&nbsp;/I &nbsp; &nbsp; &nbsp; &nbsp; Ignore exit (return) codes returned by commands and programs
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; executed as a result of dependency statements.
<br>
&nbsp;/N &nbsp; &nbsp; &nbsp; &nbsp; Display commands that would be executed as a result of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dependency statements but do not execute those commands.
<br>
&nbsp;/S &nbsp; &nbsp; &nbsp; &nbsp; Do not display commands as they are executed.
<br>
&nbsp;/X &nbsp; &nbsp; &nbsp; &nbsp; Direct error messages from MAKE, or any program that MAKE runs,
<br>
&nbsp;&lt;filename&gt; to the specified file. If filename is a hyphen (-), direct
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error messages to the standard output.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 4-7. &nbsp;Switches for the MAKE utility.
<br>
<br>
<br>
A Complete Example
<br>
<br>
&nbsp;Let's put together everything we've learned about using the MS-DOS
<br>
&nbsp;programming tools so far. Figure 4-8 shows a sketch of the overall
<br>
&nbsp;process of building an executable program.
<br>
<br>
&nbsp;Assume that we have the source code for the HELLO.EXE program from Chapter
<br>
&nbsp;3 in the file HELLO.ASM. To assemble the source program into the
<br>
&nbsp;relocatable object module HELLO.OBJ with symbolic debugging information
<br>
&nbsp;included, also producing a program listing in the file HELLO.LST and a
<br>
&nbsp;cross-reference data file HELLO.CRF, we would enter
<br>
<br>
&nbsp;C&gt;MASM /C /L /Zi /T HELLO; &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;To convert the cross-reference raw-data file HELLO.CRF into a
<br>
&nbsp;cross-reference listing in the file HELLO.REF, we would enter
<br>
<br>
&nbsp;C&gt;CREF HELLO,HELLO &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;┌───────────────┐ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ┌───────────────┐
<br>
&nbsp;│ &nbsp; &nbsp; MASM &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp;C or other &nbsp; │
<br>
&nbsp;│ &nbsp;source-code &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp;HLL source- &nbsp;│
<br>
&nbsp;│ &nbsp; &nbsp; file &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; code file &nbsp; │
<br>
&nbsp;└───┬───────────┘ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; └───┬───────────┘
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; ┌─────────────────────┘ &nbsp;Compiler
<br>
&nbsp;┌─────────────┐
<br>
&nbsp;│ &nbsp;Relocatable &nbsp;│
<br>
&nbsp;│ object-module ├────┐
<br>
&nbsp;│ &nbsp;file (.OBJ) &nbsp;│ &nbsp; &nbsp;│
<br>
&nbsp;└───┬───────────┘ &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp;│ LIB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;┌──────────────┐ &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp;┌───────────────┐
<br>
&nbsp;│ Object-module │ &nbsp; &nbsp; &nbsp;LINK &nbsp;│ &nbsp;Executable &nbsp; │
<br>
&nbsp;│ &nbsp; libraries &nbsp; ├───────────── &nbsp; program &nbsp; &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp;(.LIB) &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp;(.EXE) &nbsp; &nbsp; │
<br>
&nbsp;└───────────────┘ &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;└───┬───────────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ EXE2BIN
<br>
&nbsp;┌───────────────┐ &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;┌──────────────┐
<br>
&nbsp;│ &nbsp; &nbsp; HLL &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;│ &nbsp; Executable &nbsp;│
<br>
&nbsp;│ &nbsp; runtime &nbsp; &nbsp; ├──────┘ &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp;program &nbsp; &nbsp;│
<br>
&nbsp;│ &nbsp;libraries &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; (.COM) &nbsp; &nbsp;│
<br>
&nbsp;└───────────────┘ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; └───────────────┘
<br>
<br>
&nbsp;Figure 4-8. &nbsp;Creation of an MS-DOS application program, from source code
<br>
&nbsp;to executable file.
<br>
<br>
&nbsp;To convert the relocatable object file HELLO.OBJ into the executable file
<br>
&nbsp;HELLO.EXE, creating a load map in the file HELLO.MAP and appending
<br>
&nbsp;symbolic debugging information to the executable file, we would enter
<br>
<br>
&nbsp;C&gt;LINK /MAP /CODEVIEW HELLO; &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;We could also automate the entire process just described by creating a
<br>
&nbsp;make file named HELLO (with no extension) and including the following
<br>
&nbsp;instructions:
<br>
<br>
&nbsp;hello.obj : hello.asm
<br>
&nbsp; masm /C /L /Zi /T hello;
<br>
&nbsp; cref hello,hello
<br>
<br>
&nbsp;hello.exe : hello.obj
<br>
&nbsp; link /MAP /CODEVIEW hello;
<br>
<br>
&nbsp;Then, when we have made some change to HELLO.ASM and want to rebuild the
<br>
&nbsp;executable HELLO.EXE file, we need only enter
<br>
<br>
&nbsp;C&gt;MAKE HELLO &nbsp;&lt;Enter&gt;
<br>
<br>
<br>
Programming Resources and References
<br>
<br>
&nbsp;The literature on IBM PC─compatible personal computers, the Intel 80x86
<br>
&nbsp;microprocessor family, and assembly-language and C programming is vast.
<br>
&nbsp;The list below contains a selection of those books that I have found to be
<br>
&nbsp;useful and reliable. The list should not be construed as an endorsement by
<br>
&nbsp;Microsoft Corporation.
<br>
<br>
MASM Tutorials
<br>
<br>
&nbsp;Assembly Language Primer for the IBM PC and XT, by Robert Lafore. New
<br>
&nbsp;American Library, New York, NY, 1984. ISBN 0-452-25711-5.
<br>
<br>
&nbsp;8086/8088/80286 Assembly Language, by Leo Scanlon. Brady Books, Simon and
<br>
&nbsp;Schuster, New York, NY, 1988. ISBN 0-13-246919-7.
<br>
<br>
C Tutorials
<br>
<br>
&nbsp;Microsoft C Programming for the IBM, by Robert Lafore. Howard K. Sams &amp;
<br>
&nbsp;Co., Indianapolis, IN, 1987. ISBN 0-672-22515-8.
<br>
<br>
&nbsp;Proficient C, by Augie Hansen. Microsoft Press, Redmond, WA, 1987. ISBN
<br>
&nbsp;1-55615-007-5.
<br>
<br>
Intel 80x86 Microprocessor References
<br>
<br>
&nbsp;iAPX 88 Book. Intel Corporation, Literature Department SV3-3, 3065 Bowers
<br>
&nbsp;Ave., Santa Clara, CA 95051. Order no. 210200.
<br>
<br>
&nbsp;iAPX 286 Programmer's Reference Manual. Intel Corporation, Literature
<br>
&nbsp;Department SV3-3, 3065 Bowers Ave., Santa Clara, CA 95051. Order no.
<br>
&nbsp;210498.
<br>
<br>
&nbsp;iAPX 386 Programmer's Reference Manual. Intel Corporation, Literature
<br>
&nbsp;Department SV3-3, 3065 Bowers Ave., Santa Clara, CA 95051. Order no.
<br>
&nbsp;230985.
<br>
<br>
PC, PC/AT, and PS/2 Architecture
<br>
<br>
&nbsp;The IBM Personal Computer from the Inside Out (Revised Edition), by Murray
<br>
&nbsp;Sargent and Richard L. Shoemaker. Addison-Wesley Publishing Company,
<br>
&nbsp;Reading, MA, 1986. ISBN 0-201-06918-0.
<br>
<br>
&nbsp;Programmer's Guide to PC &amp; PS/2 Video Systems, by Richard Wilton.
<br>
&nbsp;Microsoft Press, Redmond, WA, 1987. ISBN 1-55615-103-9.
<br>
<br>
&nbsp;Personal Computer Technical Reference. IBM Corporation, IBM Technical
<br>
&nbsp;Directory, P. O. Box 2009, Racine, WI 53404. Part no. 6322507.
<br>
<br>
&nbsp;Personal Computer AT Technical Reference. IBM Corporation, IBM Technical
<br>
&nbsp;Directory, P. O. Box 2009, Racine, WI 53404. Part no. 6280070.
<br>
<br>
&nbsp;Options and Adapters Technical Reference. IBM Corporation, IBM Technical
<br>
&nbsp;Directory, P. O. Box 2009, Racine, WI 53404. Part no. 6322509.
<br>
<br>
&nbsp;Personal System/2 Model 30 Technical Reference. IBM Corporation, IBM
<br>
&nbsp;Technical Directory, P. O. Box 2009, Racine, WI 53404. Part no. 68X2201.
<br>
<br>
&nbsp;Personal System/2 Model 50/60 Technical Reference. IBM Corporation, IBM
<br>
&nbsp;Technical Directory, P. O. Box 2009, Racine, WI 53404. Part no. 68X2224.
<br>
<br>
&nbsp;Personal System/2 Model 80 Technical Reference. IBM Corporation, IBM
<br>
&nbsp;Technical Directory, P. O. Box 2009, Racine, WI 53404. Part no. 68X2256.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 5 &nbsp;Keyboard and Mouse Input
<br>
<br>
&nbsp;The fundamental means of user input under MS-DOS is the keyboard. This
<br>
&nbsp;follows naturally from the MS-DOS command-line interface, whose lineage
<br>
&nbsp;can be traced directly to minicomputer operating systems with Teletype
<br>
&nbsp;consoles. During the first few years of MS-DOS's existence, when
<br>
&nbsp;8088/8086-based machines were the norm, nearly every popular application
<br>
&nbsp;program used key-driven menus and text-mode displays.
<br>
<br>
&nbsp;However, as high-resolution graphics adapters (and 80286/80386-based
<br>
&nbsp;machines with enough power to drive them) have become less expensive,
<br>
&nbsp;programs that support windows and a graphical user interface have steadily
<br>
&nbsp;grown more popular. Such programs typically rely on a pointing device such
<br>
&nbsp;as a mouse, stylus, joystick, or light pen to let the user navigate in a
<br>
&nbsp;&quot;point-and-shoot&quot; manner, reducing keyboard entry to a minimum. As a
<br>
&nbsp;result, support for pointing devices has become an important consideration
<br>
&nbsp;for all software developers.
<br>
<br>
<br>
Keyboard Input Methods
<br>
<br>
&nbsp;Applications running under MS-DOS on IBM PC─compatible machines can use
<br>
&nbsp;several methods to obtain keyboard input:
<br>
<br>
&nbsp;■ &nbsp;MS-DOS handle-oriented functions
<br>
<br>
&nbsp;■ &nbsp;MS-DOS traditional character functions
<br>
<br>
&nbsp;■ &nbsp;IBM ROM BIOS keyboard-driver functions
<br>
<br>
&nbsp;These methods offer different degrees of flexibility, portability, and
<br>
&nbsp;hardware independence.
<br>
<br>
&nbsp;The handle, or stream-oriented, functions are philosophically derived from
<br>
&nbsp;UNIX/XENIX and were first introduced in MS-DOS version 2.0. A program uses
<br>
&nbsp;these functions by supplying a handle, or token, for the desired device,
<br>
&nbsp;plus the address and length of a buffer.
<br>
<br>
&nbsp;When a program begins executing, MS-DOS supplies it with predefined
<br>
&nbsp;handles for certain commonly used character devices, including the
<br>
&nbsp;keyboard:
<br>
<br>
&nbsp;Handle &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Device name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Opened to
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Standard input (stdin) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CON
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Standard output (stdout) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CON
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Standard error (stderr) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CON
<br>
&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Standard auxiliary (stdaux) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AUX
<br>
&nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Standard printer (stdprn) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PRN
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;These handles can be used for read and write operations without further
<br>
&nbsp;preliminaries. A program can also obtain a handle for a character device
<br>
&nbsp;by explicitly opening the device for input or output using its logical
<br>
&nbsp;name (as though it were a file). The handle functions support I/O
<br>
&nbsp;redirection, allowing a program to take its input from another device or
<br>
&nbsp;file instead of the keyboard, for example. Redirection is discussed in
<br>
&nbsp;detail in Chapter 15.
<br>
<br>
&nbsp;The traditional character-input functions are a superset of the character
<br>
&nbsp;I/O functions that were present in CP/M. Originally included in MS-DOS
<br>
&nbsp;simply to facilitate the porting of existing applications from CP/M, they
<br>
&nbsp;are still widely used. In MS-DOS versions 2.0 and later, most of the
<br>
&nbsp;traditional functions also support I/O redirection (although not as well
<br>
&nbsp;as the handle functions do).
<br>
<br>
&nbsp;Use of the IBM ROM BIOS keyboard functions presupposes that the program is
<br>
&nbsp;running on an IBM PC─compatible machine. The ROM BIOS keyboard driver
<br>
&nbsp;operates at a much more primitive level than the MS-DOS functions and
<br>
&nbsp;allows a program to circumvent I/O redirection or MS-DOS's special
<br>
&nbsp;handling of certain control characters. Programs that use the ROM BIOS
<br>
&nbsp;keyboard driver are inherently less portable than those that use the
<br>
&nbsp;MS-DOS functions and may interfere with the proper operation of other
<br>
&nbsp;programs; many of the popular terminate-and-stay-resident (TSR) utilities
<br>
&nbsp;fall into this category.
<br>
<br>
Keyboard Input with Handles
<br>
<br>
&nbsp;The principal MS-DOS function for keyboard input using handles is Int 21H
<br>
&nbsp;Function 3FH (Read File or Device). The parameters for this function are
<br>
&nbsp;a handle, the segment and offset of a buffer, and the length of the
<br>
&nbsp;buffer. (For a more detailed explanation of this function, see Section
<br>
&nbsp;II of this book, &quot;MS-DOS Functions Reference.&quot;)
<br>
<br>
&nbsp;As an example, let's use the predefined standard input handle (0) and Int
<br>
&nbsp;21H Function 3FH to read a line from the keyboard:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;buffer &nbsp;db &nbsp; 80 dup (?) &nbsp; &nbsp; ; keyboard input buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,3fh &nbsp; &nbsp; &nbsp; &nbsp; ; function 3fh = read file or device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;bx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; handle for standard input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;cx,80 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; maximum bytes to read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;dx,seg buffer &nbsp;; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;dx,offset buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;When control returns from Int 21H Function 3FH, the carry flag is clear if
<br>
&nbsp;the function was successful, and AX contains the number of characters
<br>
&nbsp;read. If there was an error, the carry flag is set and AX contains an
<br>
&nbsp;error code; however, this should never occur when reading the keyboard.
<br>
<br>
&nbsp;The standard input is redirectable, so the code just shown is not a
<br>
&nbsp;foolproof way of obtaining input from the keyboard. Depending upon whether
<br>
&nbsp;a redirection parameter was included in the command line by the user,
<br>
&nbsp;program input might be coming from the keyboard, a file, another character
<br>
&nbsp;device, or even the bit bucket (NUL device). To bypass redirection and be
<br>
&nbsp;absolutely certain where your input is coming from, you can ignore the
<br>
&nbsp;predefined standard input handle and open the console as though it were a
<br>
&nbsp;file, using the handle obtained from that open operation to perform your
<br>
&nbsp;keyboard input, as in the following example:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;buffer &nbsp;db &nbsp; &nbsp; 80 dup (?) &nbsp; ; keyboard input buffer
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; 'CON',0 &nbsp; &nbsp; &nbsp;; keyboard device name
<br>
&nbsp;handle &nbsp;dw &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; keyboard device handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;ah,3dh &nbsp; &nbsp; &nbsp; ; function 3dh = open
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;al,0 &nbsp; &nbsp; &nbsp; &nbsp; ; mode = read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;dx,seg fname ; DS:DX = device name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;dx,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp;21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp;; jump if open failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;handle,ax &nbsp; &nbsp;; save handle for CON
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;ah,3fh &nbsp; &nbsp; &nbsp; ; function 3fh = read file or device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;bx,handle &nbsp; &nbsp;; BX = handle for CON
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;cx,80 &nbsp; &nbsp; &nbsp; &nbsp;; maximum bytes to read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;dx,offset buffer ; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp;21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp;; jump if error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;When a programmer uses Int 21H Function 3FH to read from the keyboard, the
<br>
&nbsp;exact result depends on whether MS-DOS regards the handle to be in ASCII
<br>
&nbsp;mode or binary mode (sometimes known as cooked mode and raw mode). ASCII
<br>
&nbsp;mode is the default, although binary mode can be selected with Int 21H
<br>
&nbsp;Function 44H (IOCTL) when necessary.
<br>
<br>
&nbsp;In ASCII mode, MS-DOS initially places characters obtained from the
<br>
&nbsp;keyboard in a 128-byte internal buffer, and the user can edit the input
<br>
&nbsp;with the Backspace key and the special function keys. MS-DOS automatically
<br>
&nbsp;echoes the characters to the standard output, expanding tab characters to
<br>
&nbsp;spaces (although they are left as the ASCII code 09H in the buffer). The
<br>
&nbsp;Ctrl-C, Ctrl-S, and Ctrl-P key combinations receive special handling, and
<br>
&nbsp;the Enter key is translated to a carriage return─linefeed pair. When the
<br>
&nbsp;user presses Enter or Ctrl-Z, MS-DOS copies the requested number of
<br>
&nbsp;characters (or the actual number of characters entered, if less than the
<br>
&nbsp;number requested) out of the internal buffer into the calling program's
<br>
&nbsp;buffer.
<br>
<br>
&nbsp;In binary mode, MS-DOS never echoes input characters. It passes the
<br>
&nbsp;Ctrl-C, Ctrl-S, Ctrl-P, and Ctrl-Z key combinations and the Enter key
<br>
&nbsp;through to the application unchanged, and Int 21H Function 3FH does not
<br>
&nbsp;return control to the application until the exact number of characters
<br>
&nbsp;requested has been received.
<br>
<br>
&nbsp;Ctrl-C checking is discussed in more detail at the end of this chapter.
<br>
&nbsp;For now, simply note that the application programmer can substitute a
<br>
&nbsp;custom handler for the default MS-DOS Ctrl-C handler and thereby avoid
<br>
&nbsp;having the application program lose control of the machine when the user
<br>
&nbsp;enters a Ctrl-C or Ctrl-Break.
<br>
<br>
Keyboard Input with Traditional Calls
<br>
<br>
&nbsp;The MS-DOS traditional keyboard functions offer a variety of character and
<br>
&nbsp;line-oriented services with or without echo and Ctrl-C detection. These
<br>
&nbsp;functions are summarized on the following page.
<br>
<br>
&nbsp;Int 21H Function &nbsp; Action &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ctrl-C checking
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Keyboard input with echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Yes
<br>
&nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Direct console I/O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; No
<br>
&nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Keyboard input without echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;No
<br>
&nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Keyboard input without echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Yes
<br>
&nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffered keyboard input &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Yes
<br>
&nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Input-status check &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Yes
<br>
&nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Input-buffer reset and input &nbsp; &nbsp; &nbsp; &nbsp; Varies
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;In MS-DOS versions 2.0 and later, redirection of the standard input
<br>
&nbsp;affects all these functions. In other words, they act as though they were
<br>
&nbsp;special cases of an Int 21H Function 3FH call using the predefined
<br>
&nbsp;standard input handle (0).
<br>
<br>
&nbsp;The character-input functions (01H, 06H, 07H, and 08H) all return a
<br>
&nbsp;character in the AL register. For example, the following sequence waits
<br>
&nbsp;until a key is pressed and then returns it in AL:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1 &nbsp; &nbsp; &nbsp; &nbsp;; function 01h = read keyboard
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The character-input functions differ in whether the input is echoed to the
<br>
&nbsp;screen and whether they are sensitive to Ctrl-C interrupts. Although
<br>
&nbsp;MS-DOS provides no pure keyboard-status function that is immune to Ctrl-C,
<br>
&nbsp;a program can read keyboard status (somewhat circuitously) without
<br>
&nbsp;interference by using Int 21H Function 06H. Extended keys, such as the
<br>
&nbsp;IBM PC keyboard's special function keys, require two calls to a
<br>
&nbsp;character-input function.
<br>
<br>
&nbsp;As an alternative to single-character input, a program can use
<br>
&nbsp;buffered-line input (Int 21H Function 0AH) to obtain an entire line from
<br>
&nbsp;the keyboard in one operation. MS-DOS builds up buffered lines in an
<br>
&nbsp;internal buffer and does not pass them to the calling program until the
<br>
&nbsp;user presses the Enter key. While the line is being entered, all the usual
<br>
&nbsp;editing keys are active and are handled by the MS-DOS keyboard driver. You
<br>
&nbsp;use Int 21H Function 0AH as follows:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;81 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; maximum length of input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; actual length (from MS-DOS)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;81 dup (0) &nbsp;; receives keyboard input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0ah &nbsp; &nbsp; &nbsp;; function 0ah = read buffered line
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff ; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Int 21H Function 0AH differs from Int 21H Function 3FH in several
<br>
&nbsp;important ways. First, the maximum length is passed in the first byte of
<br>
&nbsp;the buffer, rather than in the CX register. Second, the actual length is
<br>
&nbsp;returned in the second byte of the structure, rather than in the AX
<br>
&nbsp;register. Finally, when the user has entered one less than the specified
<br>
&nbsp;maximum number of characters, MS-DOS ignores all subsequent characters and
<br>
&nbsp;sounds a warning beep until the Enter key is pressed.
<br>
<br>
&nbsp;For detailed information about each of the traditional keyboard-input
<br>
&nbsp;functions, see Section II of this book, &quot;MS-DOS Functions Reference.&quot;
<br>
<br>
Keyboard Input with ROM BIOS Functions
<br>
<br>
&nbsp;Programmers writing applications for IBM PC compatibles can bypass the
<br>
&nbsp;MS-DOS keyboard functions and choose from two hardware-dependent
<br>
&nbsp;techniques for keyboard input.
<br>
<br>
&nbsp;The first method is to call the ROM BIOS keyboard driver using Int 16H.
<br>
&nbsp;For example, the following sequence reads a single character from the
<br>
&nbsp;keyboard input buffer and returns it in the AL register:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp;ah,0 &nbsp; &nbsp; &nbsp; &nbsp; ; function 0=read keyboard
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp;16h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to ROM BIOS
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Int 16H Function 00H also returns the keyboard scan code in the AH
<br>
&nbsp;register, allowing the program to detect key codes that are not ordinarily
<br>
&nbsp;returned by MS-DOS. Other Int 16H services return the keyboard status
<br>
&nbsp;(that is, whether a character is waiting) or the keyboard shift state
<br>
&nbsp;(from the ROM BIOS data area 0000:0417H). For a more detailed explanation
<br>
&nbsp;of ROM BIOS keyboard functions, see Section III of this book, &quot;IBM ROM
<br>
&nbsp;BIOS and Mouse Functions Reference.&quot;
<br>
<br>
&nbsp;You should consider carefully before building ROM BIOS dependence into an
<br>
&nbsp;application. Although this technique allows you to bypass any I/O
<br>
&nbsp;redirection that may be in effect, ways exist to do this without
<br>
&nbsp;introducing dependence on the ROM BIOS. And there are real disadvantages
<br>
&nbsp;to calling the ROM BIOS keyboard driver:
<br>
<br>
&nbsp;■ &nbsp;It always bypasses I/O redirection, which sometimes may not be
<br>
&nbsp; &nbsp; desirable.
<br>
<br>
&nbsp;■ &nbsp;It is dependent on IBM PC compatibility and does not work correctly,
<br>
&nbsp; &nbsp; unchanged, on some older machines such as the Hewlett-Packard
<br>
&nbsp; &nbsp; TouchScreen or the Wang Professional Computer.
<br>
<br>
&nbsp;■ &nbsp;It may introduce complicated interactions with TSR utilities.
<br>
<br>
&nbsp;The other and more hardware-dependent method of keyboard input on an IBM
<br>
&nbsp;PC is to write a new handler for ROM BIOS Int 09H and service the keyboard
<br>
&nbsp;controller's interrupts directly. This involves translation of scan codes
<br>
&nbsp;to ASCII characters and maintenance of the type-ahead buffer. In ordinary
<br>
&nbsp;PC applications, there is no reason to take over keyboard I/O at this
<br>
&nbsp;level; therefore, I will not discuss this method further here. If you are
<br>
&nbsp;curious about the techniques that would be required, the best reference is
<br>
&nbsp;the listing for the ROM BIOS Int 09H handler in the IBM PC or PC/AT
<br>
&nbsp;technical reference manual.
<br>
<br>
<br>
Ctrl-C and Ctrl-Break Handlers
<br>
<br>
&nbsp;In the discussion of keyboard input with the MS-DOS handle and traditional
<br>
&nbsp;functions, I made some passing references to the fact that Ctrl-C entries
<br>
&nbsp;can interfere with the expected behavior of those functions. Let's look at
<br>
&nbsp;this subject in more detail now.
<br>
<br>
&nbsp;During most character I/O operations, MS-DOS checks for a Ctrl-C (ASCII
<br>
&nbsp;code 03H) waiting at the keyboard and executes an Int 23H if one is
<br>
&nbsp;detected. If the system break flag is on, MS-DOS also checks for a Ctrl-C
<br>
&nbsp;entry during certain other operations (such as file reads and writes).
<br>
&nbsp;Ordinarily, the Int 23H vector points to a routine that simply terminates
<br>
&nbsp;the currently active process and returns control to the parent process──
<br>
&nbsp;usually the MS-DOS command interpreter.
<br>
<br>
&nbsp;In other words, if your program is executing and you enter a Ctrl-C,
<br>
&nbsp;accidentally or intentionally, MS-DOS simply aborts the program. Any files
<br>
&nbsp;the program has opened using file control blocks will not be closed
<br>
&nbsp;properly, any interrupt vectors it has altered may not be restored
<br>
&nbsp;correctly, and if it is performing any direct I/O operations (for example,
<br>
&nbsp;if it contains an interrupt driver for the serial port), all kinds of
<br>
&nbsp;unexpected events may occur.
<br>
<br>
&nbsp;Although you can use a number of partially effective methods to defeat
<br>
&nbsp;Ctrl-C checking, such as performing keyboard input with Int 21H Functions
<br>
&nbsp;06H and 07H, placing all character devices into binary mode, or turning
<br>
&nbsp;off the system break flag with Int 21H Function 33H, none of these is
<br>
&nbsp;completely foolproof. The simplest and most elegant way to defeat Ctrl-C
<br>
&nbsp;checking is simply to substitute your own Int 23H handler, which can take
<br>
&nbsp;some action appropriate to your program. When the program terminates,
<br>
&nbsp;MS-DOS automatically restores the previous contents of the Int 23H vector
<br>
&nbsp;from information saved in the program segment prefix. The following
<br>
&nbsp;example shows how to install your own Ctrl-C handler (which in this case
<br>
&nbsp;does nothing at all):
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set int 23h vector...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,2523h &nbsp; &nbsp;; function 25h = set interrupt
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; int 23h = vector for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Ctrl-C handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg handler ; DS:DX = handler address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;handler: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; a Ctrl-C handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; that does nothing
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The first part of the code (which alters the contents of the Int 23H
<br>
&nbsp;vector) would be executed in the initialization part of the application.
<br>
&nbsp;The handler receives control whenever MS-DOS detects a Ctrl-C at the
<br>
&nbsp;keyboard. (Because this handler consists only of an interrupt return, the
<br>
&nbsp;Ctrl-C will remain in the keyboard input stream and will be passed to the
<br>
&nbsp;application when it requests a character from the keyboard, appearing on
<br>
&nbsp;the screen as ^C.)
<br>
<br>
&nbsp;When an Int 23H handler is called, MS-DOS is in a stable state. Thus, the
<br>
&nbsp;handler can call any MS-DOS function. It can also reset the segment
<br>
&nbsp;registers and the stack pointer and transfer control to some other point
<br>
&nbsp;in the application without ever returning control to MS-DOS with an IRET.
<br>
<br>
&nbsp;On IBM PC compatibles, an additional interrupt handler must be taken into
<br>
&nbsp;consideration. Whenever the ROM BIOS keyboard driver detects the key
<br>
&nbsp;combination Ctrl-Break, it calls a handler whose address is stored in the
<br>
&nbsp;vector for Int 1BH. The default ROM BIOS Int 1BH handler does nothing.
<br>
&nbsp;MS-DOS alters the Int 1BH vector to point to its own handler, which sets a
<br>
&nbsp;flag and returns; the net effect is to remap the Ctrl-Break into a Ctrl-C
<br>
&nbsp;that is forced ahead of any other characters waiting in the keyboard
<br>
&nbsp;buffer.
<br>
<br>
&nbsp;Taking over the Int 1BH vector in an application is somewhat tricky but
<br>
&nbsp;extremely useful. Because the keyboard is interrupt driven, a press of
<br>
&nbsp;Ctrl-Break lets the application regain control under almost any
<br>
&nbsp;circumstance──often, even if the program has crashed or is in an endless
<br>
&nbsp;loop.
<br>
<br>
&nbsp;You cannot, in general, use the same handler for Int 1BH that you use for
<br>
&nbsp;Int 23H. The Int 1BH handler is more limited in what it can do, because it
<br>
&nbsp;has been called as a result of a hardware interrupt and MS-DOS may have
<br>
&nbsp;been executing a critical section of code at the time the interrupt was
<br>
&nbsp;serviced. Thus, all registers except CS:IP are in an unknown state; they
<br>
&nbsp;may have to be saved and then modified before your interrupt handler can
<br>
&nbsp;execute. Similarly, the depth of the stack in use when the Int 1BH handler
<br>
&nbsp;is called is unknown, and if the handler is to perform stack-intensive
<br>
&nbsp;operations, it may have to save the stack segment and the stack pointer
<br>
&nbsp;and switch to a new stack that is known to have sufficient depth.
<br>
<br>
&nbsp;In normal application programs, you should probably avoid retaining
<br>
&nbsp;control in an Int 1BH handler, rather than performing an IRET. Because of
<br>
&nbsp;subtle differences among non-IBM ROM BIOSes, it is difficult to predict
<br>
&nbsp;the state of the keyboard controller and the 8259 Programmable Interrupt
<br>
&nbsp;Controller (PIC) when the Int 1BH handler begins executing. Also, MS-DOS
<br>
&nbsp;itself may not be in a stable state at the point of interrupt, a situation
<br>
&nbsp;that can manifest itself in unexpected critical errors during subsequent
<br>
&nbsp;I/O operations. Finally, MS-DOS versions 3.2 and later allocate a stack
<br>
&nbsp;from an internal pool for use by the Int 09H handler. If the Int 1BH
<br>
&nbsp;handler never returns, the Int 09H handler never returns either, and
<br>
&nbsp;repeated entries of Ctrl-Break will eventually exhaust the stack pool,
<br>
&nbsp;halting the system.
<br>
<br>
&nbsp;Because Int 1BH is a ROM BIOS interrupt and not an MS-DOS interrupt,
<br>
&nbsp;MS-DOS does not restore the previous contents of the Int 1BH vector when a
<br>
&nbsp;program exits. If your program modifies this vector, it must save the
<br>
&nbsp;original value and restore it before terminating. Otherwise, the vector
<br>
&nbsp;will be left pointing to some random area in the next program that runs,
<br>
&nbsp;and the next time the user presses Ctrl-Break a system crash is the best
<br>
&nbsp;you can hope for.
<br>
<br>
Ctrl-C and Ctrl-Break Handlers and High-Level Languages
<br>
<br>
&nbsp;Capturing the Ctrl-C and Ctrl-Break interrupts is straightforward when you
<br>
&nbsp;are programming in assembly language. The process is only slightly more
<br>
&nbsp;difficult with high-level languages, as long as you have enough
<br>
&nbsp;information about the language's calling conventions that you can link in
<br>
&nbsp;a small assembly-language routine as part of the program.
<br>
<br>
&nbsp;The BREAK.ASM listing in Figure 5-1 contains source code for a Ctrl-Break
<br>
&nbsp;handler that can be linked with small-model Microsoft C programs running
<br>
&nbsp;on an IBM PC compatible. The short C program in Figure 5-2 demonstrates
<br>
&nbsp;use of the handler. (This code should be readily portable to other C
<br>
&nbsp;compilers.)
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page &nbsp; &nbsp;55,132
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;title &nbsp; Ctrl-C &amp; Ctrl-Break Handlers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;break
<br>
<br>
&nbsp;;
<br>
&nbsp;; Ctrl-C and Ctrl-Break handler for Microsoft C
<br>
&nbsp;; programs running on IBM PC compatibles
<br>
&nbsp;;
<br>
&nbsp;; by Ray Duncan
<br>
&nbsp;;
<br>
&nbsp;; Assemble with: &nbsp;C&gt;MASM /Mx BREAK;
<br>
&nbsp;;
<br>
&nbsp;; This module allows C programs to retain control
<br>
&nbsp;; when the user enters a Ctrl-Break or Ctrl-C.
<br>
&nbsp;; It uses Microsoft C parameter-passing conventions
<br>
&nbsp;; and assumes the C small memory model.
<br>
&nbsp;;
<br>
&nbsp;; The procedure _capture is called to install
<br>
&nbsp;; a new handler for the Ctrl-C and Ctrl-Break
<br>
&nbsp;; interrupts (1bh and 23h). &nbsp;_capture is passed
<br>
&nbsp;; the address of a static variable, which will be
<br>
&nbsp;; set to true by the handler whenever a Ctrl-C
<br>
&nbsp;; or Ctrl-Break is detected. &nbsp;The C syntax is:
<br>
&nbsp;;
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; static int flag;
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; capture(&amp;flag);
<br>
&nbsp;;
<br>
&nbsp;; The procedure _release is called by the C program
<br>
&nbsp;; to restore the original Ctrl-Break and Ctrl-C
<br>
&nbsp;; handler. The C syntax is:
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; release();
<br>
&nbsp;;
<br>
&nbsp;; The procedure ctrlbrk is the actual interrupt
<br>
&nbsp;; handler. &nbsp;It receives control when a software
<br>
&nbsp;; int 1bh is executed by the ROM BIOS or int 23h
<br>
&nbsp;; is executed by MS-DOS. &nbsp;It simply sets the C
<br>
&nbsp;; program's variable to true (1) and returns.
<br>
&nbsp;;
<br>
<br>
&nbsp;args &nbsp; &nbsp;equ &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; stack offset of arguments,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; C small memory model
<br>
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII linefeed
<br>
<br>
&nbsp;_TEXT &nbsp; segment word public 'CODE'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assume cs:_TEXT
<br>
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public &nbsp;_capture
<br>
&nbsp;_capture proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; take over Ctrl-Break
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and Ctrl-C interrupt vectors
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set up stack frame
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bp,sp
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;si
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save address of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; calling program's &quot;flag&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,word ptr [bp+args]
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr cs:flag,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr cs:flag+2,ds
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save address of original
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,3523h &nbsp; &nbsp; &nbsp; &nbsp;; int 23h handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr cs:int23,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr cs:int23+2,es
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,351bh &nbsp; &nbsp; &nbsp; &nbsp;; save address of original
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; int 1bh handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr cs:int1b,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr cs:int1b+2,es
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set DS:DX = address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; of new handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset _TEXT:ctrlbrk
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,02523h &nbsp; &nbsp; &nbsp; ; set int 23h vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,0251bh &nbsp; &nbsp; &nbsp; ; set int 1bh vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; si &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; discard stack frame
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and return to caller
<br>
<br>
&nbsp;_capture endp
<br>
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public &nbsp;_release
<br>
&nbsp;_release proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore original Ctrl-C
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and Ctrl-Break handlers
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;si
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lds &nbsp; &nbsp; dx,cs:int1b &nbsp; &nbsp; ; get address of previous
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; int 1bh handler
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,251bh &nbsp; &nbsp; &nbsp; &nbsp;; set int 1bh vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lds &nbsp; &nbsp; dx,cs:int23 &nbsp; &nbsp; ; get address of previous
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; int 23h handler
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,2523h &nbsp; &nbsp; &nbsp; &nbsp;; set int 23h vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; si &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; di &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and return to caller
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bp
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
&nbsp;release endp
<br>
<br>
&nbsp;ctrlbrk proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Ctrl-C and Ctrl-Break
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; interrupt handler
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lds &nbsp; &nbsp; bx,cs:flag &nbsp; &nbsp; &nbsp;; get address of C program's
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &quot;flag variable&quot;
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and set the flag &quot;true&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr ds:[bx],1
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bx
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return from handler
<br>
<br>
&nbsp;ctrlbrk endp
<br>
<br>
&nbsp;flag &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; far pointer to caller's
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Ctrl-Break or Ctrl-C flag
<br>
<br>
&nbsp;int23 &nbsp; dd &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; address of original
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Ctrl-C handler
<br>
<br>
&nbsp;int1b &nbsp; dd &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; address of original
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Ctrl-Break handler
<br>
<br>
&nbsp;_TEXT &nbsp; ends
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 5-1. &nbsp;BREAK.ASM: A Ctrl-C and Ctrl-Break interrupt handler that can
<br>
&nbsp;be linked with Microsoft C programs.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;TRYBREAK.C
<br>
<br>
&nbsp; &nbsp; &nbsp;Demo of BREAK.ASM Ctrl-Break and Ctrl-C
<br>
&nbsp; &nbsp; &nbsp;interrupt handler, by Ray Duncan
<br>
<br>
&nbsp; &nbsp; &nbsp;To create the executable file TRYBREAK.EXE, enter:
<br>
<br>
&nbsp; &nbsp; &nbsp;MASM /Mx BREAK;
<br>
&nbsp; &nbsp; &nbsp;CL TRYBREAK.C BREAK.OBJ
<br>
&nbsp;*/
<br>
<br>
&nbsp;#include &lt;stdio.h&gt;
<br>
<br>
&nbsp;main(int argc, char *argv[])
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;int hit = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* flag for key press &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;int c = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* character from keyboard */
<br>
&nbsp; &nbsp; &nbsp;static int flag = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* true if Ctrl-Break
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or Ctrl-C detected &nbsp; &nbsp; &nbsp;*/
<br>
<br>
&nbsp; &nbsp; &nbsp;puts(&quot;\n*** TRYBREAK.C running ***\n&quot;);
<br>
&nbsp; &nbsp; &nbsp;puts(&quot;Press Ctrl-C or Ctrl-Break to test handler,&quot;);
<br>
&nbsp; &nbsp; &nbsp;puts(&quot;Press the Esc key to exit TRYBREAK.\n&quot;);
<br>
<br>
&nbsp; &nbsp; &nbsp;capture(&amp;flag); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* install new Ctrl-C and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Ctrl-Break handler and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pass address of flag &nbsp; &nbsp;*/
<br>
<br>
&nbsp; &nbsp; &nbsp;puts(&quot;TRYBREAK has captured interrupt vectors.\n&quot;);
<br>
<br>
&nbsp; &nbsp; &nbsp;while(1)
<br>
&nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hit = kbhit(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* check for key press &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* (MS-DOS sees Ctrl-C
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; when keyboard polled) &nbsp;*/
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(flag != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* if flag is true, an &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* interrupt has occurred &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;puts(&quot;\nControl-Break detected.\n&quot;);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;flag = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* reset interrupt flag &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(hit != 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* if any key waiting &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c = getch(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* read key, exit if Esc &nbsp; */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if( (c &amp; 0x7f) == 0x1b) break;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;putch(c); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* otherwise display it &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
<br>
&nbsp; &nbsp; &nbsp;}
<br>
&nbsp; &nbsp; &nbsp;release(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* restore original Ctrl-C
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and Ctrl-Break handlers */
<br>
<br>
&nbsp; &nbsp; &nbsp;puts(&quot;\n\nTRYBREAK has released interrupt vectors.&quot;);
<br>
&nbsp;}
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 5-2. &nbsp;TRYBREAK.C: A simple Microsoft C program that demonstrates
<br>
&nbsp;use of the interrupt handler BREAK.ASM from Figure 5-1.
<br>
<br>
&nbsp;In the example handler, the procedure named capture is called with the
<br>
&nbsp;address of an integer variable within the C program. It saves the address
<br>
&nbsp;of the variable, points the Int 1BH and Int 23H vectors to its own
<br>
&nbsp;interrupt handler, and then returns.
<br>
<br>
&nbsp;When MS-DOS detects a Ctrl-C or Ctrl-Break, the interrupt handler sets the
<br>
&nbsp;integer variable within the C program to true (1) and returns. The C
<br>
&nbsp;program can then poll this variable at its leisure. Of course, to detect
<br>
&nbsp;more than one Ctrl-C, the program must reset the variable to zero again.
<br>
<br>
&nbsp;The procedure named release simply restores the Int 1BH and Int 23H
<br>
&nbsp;vectors to their original values, thereby disabling the interrupt handler.
<br>
&nbsp;Although it is not strictly necessary for release to do anything about Int
<br>
&nbsp;23H, this action does give the C program the option of restoring the
<br>
&nbsp;default handler for Int 23H without terminating.
<br>
<br>
<br>
Pointing Devices
<br>
<br>
&nbsp;Device drivers for pointing devices are supplied by the hardware
<br>
&nbsp;manufacturer and are loaded with a DEVICE statement in the CONFIG.SYS
<br>
&nbsp;file. Although the hardware characteristics of the available pointing
<br>
&nbsp;devices differ greatly, nearly all of their drivers present the same
<br>
&nbsp;software interface to application programs: the Int 33H protocol used by
<br>
&nbsp;the Microsoft Mouse driver. Version 6 of the Microsoft Mouse driver (which
<br>
&nbsp;was current as this was written) offers the following functions:
<br>
<br>
<br>
&nbsp;Function &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reset mouse and get status.
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Show mouse pointer.
<br>
&nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hide mouse pointer.
<br>
&nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get button status and pointer position.
<br>
&nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set pointer position.
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get button-press information.
<br>
&nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get button-release information.
<br>
&nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set horizontal limits for pointer.
<br>
&nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set vertical limits for pointer.
<br>
&nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set graphics pointer type.
<br>
&nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set text pointer type.
<br>
&nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read mouse-motion counters.
<br>
&nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Install interrupt handler for mouse events.
<br>
&nbsp;0DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Turn on light pen emulation.
<br>
&nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Turn off light pen emulation.
<br>
&nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set mickeys to pixel ratio.
<br>
&nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set pointer exclusion area.
<br>
&nbsp;13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set double-speed threshold.
<br>
&nbsp;14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Swap mouse-event interrupt routines.
<br>
&nbsp;15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get buffer size for mouse-driver state.
<br>
&nbsp;16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Save mouse-driver state.
<br>
&nbsp;17H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Restore mouse-driver state.
<br>
&nbsp;18H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Install alternate handler for mouse events.
<br>
&nbsp;19H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get address of alternate handler.
<br>
&nbsp;1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set mouse sensitivity.
<br>
&nbsp;1BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get mouse sensitivity.
<br>
&nbsp;1CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set mouse interrupt rate.
<br>
&nbsp;1DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Select display page for pointer.
<br>
&nbsp;1EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get display page for pointer.
<br>
&nbsp;1FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Disable mouse driver.
<br>
&nbsp;20H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Enable mouse driver.
<br>
&nbsp;21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reset mouse driver.
<br>
&nbsp;22H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set language for mouse-driver messages.
<br>
&nbsp;23H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get language number.
<br>
&nbsp;24H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get driver version, mouse type, and IRQ number.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Although this list of mouse functions may appear intimidating, the average
<br>
&nbsp;application will only need a few of them.
<br>
<br>
&nbsp;A program first calls Int 33H Function 00H to initialize the mouse driver
<br>
&nbsp;for the current display mode and to check its status. At this point, the
<br>
&nbsp;mouse is &quot;alive&quot; and the application can obtain its state and position;
<br>
&nbsp;however, the pointer does not become visible until the process calls Int
<br>
&nbsp;33H Function 01H.
<br>
<br>
&nbsp;The program can then call Int 33H Functions 03H, 05H, and 06H to
<br>
&nbsp;monitor the mouse position and the status of the mouse buttons.
<br>
&nbsp;Alternatively, the program can register an interrupt handler for mouse
<br>
&nbsp;events, using Int 33H Function 0CH. This latter technique eliminates the
<br>
&nbsp;need to poll the mouse driver; the driver will notify the program by
<br>
&nbsp;calling the interrupt handler whenever the mouse is moved or a button is
<br>
&nbsp;pressed or released.
<br>
<br>
&nbsp;When the application is finished with the mouse, it can call Int 33H
<br>
&nbsp;Function 02H to hide the mouse pointer. If the program has registered an
<br>
&nbsp;interrupt handler for mouse events, it should disable further calls to the
<br>
&nbsp;handler by resetting the mouse driver again with Int 33H Function 00H.
<br>
<br>
&nbsp;For a complete description of the mouse-driver functions, see Section
<br>
&nbsp;III of this book, &quot;IBM ROM BIOS and Mouse Functions Reference.&quot; Figure
<br>
&nbsp;5-3 shows a small demonstration program that polls the mouse continually,
<br>
&nbsp;to display its position and status.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;Simple Demo of Int 33H Mouse Driver
<br>
&nbsp; &nbsp; &nbsp;(C) 1988 Ray Duncan
<br>
<br>
&nbsp; &nbsp; &nbsp;Compile with: CL MOUDEMO.C
<br>
&nbsp;*/
<br>
<br>
&nbsp;#include &lt;stdio.h&gt;
<br>
&nbsp;#include &lt;dos.h&gt;
<br>
<br>
&nbsp;union REGS regs;
<br>
<br>
&nbsp;void cls(void); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* function prototypes &nbsp; &nbsp; &nbsp; */
<br>
&nbsp;void gotoxy(int, int);
<br>
<br>
&nbsp;main(int argc, char *argv[])
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;int x,y,buttons; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* some scratch variables &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* for the mouse state &nbsp; &nbsp; &nbsp; */
<br>
<br>
&nbsp; &nbsp; &nbsp;regs.x.ax = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* reset mouse driver &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;int86(0x33, &amp;regs, &amp;regs); &nbsp; &nbsp; &nbsp;/* and check status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
<br>
&nbsp; &nbsp; &nbsp;if(regs.x.ax == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* exit if no mouse &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;{ &nbsp; printf(&quot;\nMouse not available\n&quot;);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit(1);
<br>
&nbsp; &nbsp; &nbsp;}
<br>
<br>
&nbsp; &nbsp; &nbsp;cls(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* clear the screen &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;gotoxy(45,0); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* and show help info &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;puts(&quot;Press Both Mouse Buttons To Exit&quot;);
<br>
<br>
&nbsp; &nbsp; &nbsp;regs.x.ax = 1; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* display mouse cursor &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;int86(0x33, &amp;regs, &amp;regs);
<br>
<br>
&nbsp; &nbsp; &nbsp;do {
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;regs.x.ax = 3; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* get mouse position &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int86(0x33, &amp;regs, &amp;regs); &nbsp;/* and button status &nbsp; &nbsp; &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;buttons = regs.x.bx &amp; 3;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x = regs.x.cx;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y = regs.x.dx;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;gotoxy(0,0); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* display mouse position &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot;X = %3d &nbsp;Y = %3d&quot;, x, y);
<br>
<br>
&nbsp; &nbsp; &nbsp;} while(buttons != 3); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* exit if both buttons down */
<br>
<br>
&nbsp; &nbsp; &nbsp;regs.x.ax = 2; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* hide mouse cursor &nbsp; &nbsp; &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;int86(0x33, &amp;regs, &amp;regs);
<br>
<br>
&nbsp; &nbsp; &nbsp;cls(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* display message and exit &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;gotoxy(0,0);
<br>
&nbsp; &nbsp; &nbsp;puts(&quot;Have a Mice Day!&quot;);
<br>
&nbsp;}
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;Clear the screen
<br>
&nbsp;*/
<br>
&nbsp;void cls(void)
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;regs.x.ax = 0x0600; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* ROM BIOS video driver &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;regs.h.bh = 7; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* int 10h function 06h &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;regs.x.cx = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* initializes a window &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;regs.h.dh = 24;
<br>
&nbsp; &nbsp; &nbsp;regs.h.dl = 79;
<br>
&nbsp; &nbsp; &nbsp;int86(0x10, &amp;regs, &amp;regs);
<br>
&nbsp;}
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;Position cursor to (x,y)
<br>
&nbsp;*/
<br>
&nbsp;void gotoxy(int x, int y)
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;regs.h.dl = x; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* ROM BIOS video driver &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;regs.h.dh = y; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* int 10h function 02h &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;regs.h.bh = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* positions the cursor &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;regs.h.ah = 2;
<br>
&nbsp; &nbsp; &nbsp;int86(0x10, &amp;regs, &amp;regs);
<br>
&nbsp;}
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 5-3. &nbsp;MOUDEMO.C: A simple Microsoft C program that polls the mouse
<br>
&nbsp;and continually displays the coordinates of the mouse pointer in the upper
<br>
&nbsp;left corner of the screen. The program uses the ROM BIOS video driver,
<br>
&nbsp;which is discussed in Chapter 6, to clear the screen and position the
<br>
&nbsp;text cursor.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 6 &nbsp;Video Display
<br>
<br>
&nbsp;The visual presentation of an application program is one of its most
<br>
&nbsp;important elements. Users frequently base their conclusions about a
<br>
&nbsp;program's performance and &quot;polish&quot; on the speed and attractiveness of its
<br>
&nbsp;displays. Therefore, a feel for the computer system's display facilities
<br>
&nbsp;and capabilities at all levels, from MS-DOS down to the bare hardware, is
<br>
&nbsp;important to you as a programmer.
<br>
<br>
<br>
Video Display Adapters
<br>
<br>
&nbsp;The video display adapters found in IBM PC─compatible computers have a
<br>
&nbsp;hybrid interface to the central processor. The overall display
<br>
&nbsp;characteristics, such as vertical and horizontal resolution, background
<br>
&nbsp;color, and palette, are controlled by values written to I/O ports whose
<br>
&nbsp;addresses are hardwired on the adapter, whereas the appearance of each
<br>
&nbsp;individual character or graphics pixel on the display is controlled by a
<br>
&nbsp;specific location within an area of memory called the regen buffer or
<br>
&nbsp;refresh buffer. Both the CPU and the video controller access this memory;
<br>
&nbsp;the software updates the display by simply writing character codes or bit
<br>
&nbsp;patterns directly into the regen buffer. (This is called memory-mapped
<br>
&nbsp;I/O.)
<br>
<br>
&nbsp;The following adapters are in common use as this book is being written:
<br>
<br>
&nbsp;■ &nbsp;Monochrome/Printer Display Adapter (MDA). Introduced with the original
<br>
&nbsp; &nbsp; IBM PC in 1981, this adapter supports 80-by-25 text display on a green
<br>
&nbsp; &nbsp; (monochrome) screen and has no graphics capabilities at all.
<br>
<br>
&nbsp;■ &nbsp;Color/Graphics Adapter (CGA). Also introduced by IBM in 1981, this
<br>
&nbsp; &nbsp; adapter supports 40-by-25 and 80-by-25 text modes and 320-by-200,
<br>
&nbsp; &nbsp; 4-color or 640-by-200, 2-color graphics (all-points-addressable, or
<br>
&nbsp; &nbsp; APA) modes on composite or digital RGB monitors.
<br>
<br>
&nbsp;■ &nbsp;Enhanced Graphics Adapter (EGA). Introduced by IBM in 1985 and upwardly
<br>
&nbsp; &nbsp; compatible from the CGA, this adapter adds support for 640-by-350,
<br>
&nbsp; &nbsp; 16-color graphics modes on digital RGB monitors. It also supports an
<br>
&nbsp; &nbsp; MDA-compatible text mode.
<br>
<br>
&nbsp;■ &nbsp;Multi-Color Graphics Array (MCGA). Introduced by IBM in 1987 with the
<br>
&nbsp; &nbsp; Personal System/2 (PS/2) models 25 and 30, this adapter is partially
<br>
&nbsp; &nbsp; compatible with the CGA and EGA and supports 640-by-480, 2-color or
<br>
&nbsp; &nbsp; 320-by-200, 256-color graphics on analog RGB monitors.
<br>
<br>
&nbsp;■ &nbsp;Video Graphics Array (VGA). Introduced by IBM in 1987 with the PS/2
<br>
&nbsp; &nbsp; models 50, 60, and 80, this adapter is upwardly compatible from the EGA
<br>
&nbsp; &nbsp; and supports 640-by-480, 16-color or 320-by-200, 256-color graphics on
<br>
&nbsp; &nbsp; analog RGB monitors. It also supports an MDA-compatible text mode.
<br>
<br>
&nbsp;■ &nbsp;Hercules Graphics Card, Graphics CardPlus, and InColor Cards. These are
<br>
&nbsp; &nbsp; upwardly compatible from the MDA for text display but offer graphics
<br>
&nbsp; &nbsp; capabilities that are incompatible with all of the IBM adapters.
<br>
<br>
&nbsp;The locations of the regen buffers for the various IBM PC─compatible
<br>
&nbsp;adapters are shown in Figure 6-1.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌───────────────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ROM BIOS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;FE000H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System ROM, Stand-alone BASIC, etc. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;F4000H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved for BIOS extensions &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (hard-disk controller, etc.) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;C0000H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;BC000H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp;16 KB regen buffer for CGA, EGA, MCGA, and VGA &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; in text modes and 200-line graphics modes &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;B8000H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;B1000H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; 4 KB Monochrome Adapter regen buffer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;B0000H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; Regen buffer area for EGA, MCGA, and VGA &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp;in 350-line or 480-line graphics modes &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;A0000H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Transient part of COMMAND.COM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Transient program area &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;varies ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS and its buffers, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tables, and device drivers &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00400H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Interrupt vectors &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;00000H └───────────────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 6-1. &nbsp;Memory diagram of an IBM PC─compatible personal computer,
<br>
&nbsp;showing the locations of the regen buffers for various adapters.
<br>
<br>
<br>
Support Considerations
<br>
<br>
&nbsp;MS-DOS offers several functions to transfer text to the display. Version 1
<br>
&nbsp;supported only Teletype-like output capabilities; version 2 added an
<br>
&nbsp;optional ANSI console driver to allow the programmer to clear the screen,
<br>
&nbsp;position the cursor, and select colors and attributes with standard escape
<br>
&nbsp;sequences embedded in the output. Programs that use only the MS-DOS
<br>
&nbsp;functions will operate properly on any computer system that runs MS-DOS,
<br>
&nbsp;regardless of the level of IBM hardware compatibility.
<br>
<br>
&nbsp;On IBM PC─compatible machines, the ROM BIOS contains a video driver that
<br>
&nbsp;programs can invoke directly, bypassing MS-DOS. The ROM BIOS functions
<br>
&nbsp;allow a program to write text or individual pixels to the screen or to
<br>
&nbsp;select display modes, video pages, palette, and foreground and background
<br>
&nbsp;colors. These functions are relatively efficient (compared with the MS-DOS
<br>
&nbsp;functions, at least), although the graphics support is primitive.
<br>
<br>
&nbsp;Unfortunately, the display functions of both MS-DOS and the ROM BIOS were
<br>
&nbsp;designed around the model of a cursor-addressable terminal and therefore
<br>
&nbsp;do not fully exploit the capabilities of the memory-mapped, high-bandwidth
<br>
&nbsp;display adapters used on IBM PC─compatible machines. As a result, nearly
<br>
&nbsp;every popular interactive application with full-screen displays or
<br>
&nbsp;graphics capability ignores both MS-DOS and the ROM BIOS and writes
<br>
&nbsp;directly to the video controller's registers and regen buffer.
<br>
<br>
&nbsp;Programs that control the hardware directly are sometimes called
<br>
&nbsp;&quot;ill-behaved,&quot; because they are performing operations that are normally
<br>
&nbsp;reserved for operating-system device drivers. These programs are a severe
<br>
&nbsp;management problem in multitasking real-mode environments such as DesqView
<br>
&nbsp;and Microsoft Windows, and they are the main reason why such environments
<br>
&nbsp;are not used more widely. It could be argued, however, that the blame for
<br>
&nbsp;such problematic behavior lies not with the application programs but with
<br>
&nbsp;the failure of MS-DOS and the ROM BIOS──even six years after the first
<br>
&nbsp;appearance of the IBM PC──to provide display functions of adequate range
<br>
&nbsp;and power.
<br>
<br>
<br>
MS-DOS Display Functions
<br>
<br>
&nbsp;Under MS-DOS versions 2.0 and later, the preferred method for sending text
<br>
&nbsp;to the display is to use handle-based Int 21H Function 40H (Write File or
<br>
&nbsp;Device). When an application program receives control, MS-DOS has already
<br>
&nbsp;assigned it handles for the standard output (1) and standard error (2)
<br>
&nbsp;devices, and these handles can be used immediately. For example, the
<br>
&nbsp;sequence at the top of the following page writes the message hello to the
<br>
&nbsp;display using the standard output handle.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'hello' &nbsp; &nbsp; ; message to display
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg &nbsp; &nbsp; &nbsp; ; length of message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp;; function 40h = write file or device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp;; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg msg &nbsp;; DS:DX = address of message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; ; jump if error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;If there is no error, the function returns the carry flag cleared and the
<br>
&nbsp;number of characters actually transferred in register AX. Unless a Ctrl-Z
<br>
&nbsp;is embedded in the text or the standard output is redirected to a disk
<br>
&nbsp;file and the disk is full, this number should equal the number of
<br>
&nbsp;characters requested.
<br>
<br>
&nbsp;As in the case of keyboard input, the user's ability to specify
<br>
&nbsp;command-line redirection parameters that are invisible to the application
<br>
&nbsp;means that if you use the predefined standard output handle, you can't
<br>
&nbsp;always be sure where your output is going. However, to ensure that your
<br>
&nbsp;output actually goes to the display, you can use the predefined standard
<br>
&nbsp;error handle, which is always opened to the CON (logical console) device
<br>
&nbsp;and is not redirectable.
<br>
<br>
&nbsp;As an alternative to the standard output and standard error handles, you
<br>
&nbsp;can bypass any output redirection and open a separate channel to CON,
<br>
&nbsp;using the handle obtained from that open operation for character output.
<br>
&nbsp;For example, the following code opens the console display for output and
<br>
&nbsp;then writes the string hello to it:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'CON',0 &nbsp; &nbsp; &nbsp;; name of CON device
<br>
&nbsp;handle &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; handle for CON device
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'hello' &nbsp; &nbsp; &nbsp;; message to display
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg &nbsp; &nbsp; &nbsp; &nbsp;; length of message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,3d02h &nbsp; &nbsp; ; AH = function 3dh = open
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; AL = mode = read/write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg fname ; DS:DX = device name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp;; jump if open failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; handle,ax &nbsp; &nbsp;; save handle for CON
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; ; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp; ; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg msg &nbsp; ; DS:DX = address of message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,handle &nbsp; &nbsp;; BX = CON device handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp;; jump if error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;As with the keyboard input functions, MS-DOS also supports traditional
<br>
&nbsp;display functions that are upwardly compatible from the corresponding CP/M
<br>
&nbsp;output calls:
<br>
<br>
&nbsp;■ &nbsp;Int 21H Function 02H sends the character in the DL register to the
<br>
&nbsp; &nbsp; standard output device. It is sensitive to Ctrl-C interrupts, and it
<br>
&nbsp; &nbsp; handles carriage returns, linefeeds, bell codes, and backspaces
<br>
&nbsp; &nbsp; appropriately.
<br>
<br>
&nbsp;■ &nbsp;Int 21H Function 06H transfers the character in the DL register to the
<br>
&nbsp; &nbsp; standard output device, but it is not sensitive to Ctrl-C interrupts.
<br>
&nbsp; &nbsp; You must take care when using this function, because it can also be
<br>
&nbsp; &nbsp; used for input and for status requests.
<br>
<br>
&nbsp;■ &nbsp;Int 21H Function 09H sends a string to the standard output device. The
<br>
&nbsp; &nbsp; string is terminated by the $ character.
<br>
<br>
&nbsp;With MS-DOS version 2 or later, these three traditional functions are
<br>
&nbsp;converted internally to handle-based writes to the standard output and
<br>
&nbsp;thus are susceptible to output redirection.
<br>
<br>
&nbsp;The sequence at the top of the following page sounds a warning beep by
<br>
&nbsp;sending an ASCII bell code (07H) to the display driver using the
<br>
&nbsp;traditional character-output call Int 21H Function 02H.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,7 &nbsp; &nbsp; &nbsp; &nbsp;; 07h = ASCII bell code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,2 &nbsp; &nbsp; &nbsp; &nbsp;; function 02h = display character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The following sequence uses the traditional string-output call Int 21H
<br>
&nbsp;Function 09H to display a string:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'hello$'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg msg &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,9 &nbsp; &nbsp; &nbsp; &nbsp;; function 09h = write string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Note that MS-DOS detects the $ character as a terminator and does not
<br>
&nbsp;display it on the screen.
<br>
<br>
Screen Control with MS-DOS Functions
<br>
<br>
&nbsp;With version 2.0 or later, if MS-DOS loads the optional device driver
<br>
&nbsp;ANSI.SYS in response to a DEVICE directive in the CONFIG.SYS file,
<br>
&nbsp;programs can clear the screen, control the cursor position, and select
<br>
&nbsp;foreground and background colors by embedding escape sequences in the text
<br>
&nbsp;output. Escape sequences are so called because they begin with an escape
<br>
&nbsp;character (1BH), which alerts the driver to intercept and interpret the
<br>
&nbsp;subsequent characters in the sequence. When the ANSI driver is not loaded,
<br>
&nbsp;MS-DOS simply passes the escape sequence to the display like any other
<br>
&nbsp;text, usually resulting in a chaotic screen.
<br>
<br>
&nbsp;The escape sequences that can be used with the ANSI driver for screen
<br>
&nbsp;control are a subset of those defined in the ANSI 3.64─1979 Standard.
<br>
&nbsp;These standard sequences are summarized in Figure 6-2. Note that case is
<br>
&nbsp;significant for the last character in an escape sequence and that numbers
<br>
&nbsp;must always be represented as ASCII digit strings, not as their binary
<br>
&nbsp;values. (A separate set of escape sequences supported by ANSI.SYS, but not
<br>
&nbsp;compatible with the ANSI standard, may be used for reprogramming and
<br>
&nbsp;remapping the keyboard.)
<br>
<br>
<br>
&nbsp;Escape sequence &nbsp; &nbsp;Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Esc[2J &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Clear screen; place cursor in upper left corner (home
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; position).
<br>
&nbsp;Esc[K &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Clear from cursor to end of line.
<br>
&nbsp;Esc[row;colH &nbsp; &nbsp; &nbsp; Position cursor. (Row is the y coordinate in the range
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1─25 and col is the x coordinate in the range 1─80 for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 80-by-25 text display modes.) Escape sequences
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; terminated with the letter f instead of H have the same
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; effect.
<br>
&nbsp;Esc[nA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Move cursor up n rows.
<br>
&nbsp;Esc[nB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Move cursor down n rows.
<br>
&nbsp;Esc[nC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Move cursor right n columns.
<br>
&nbsp;Esc[nD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Move cursor left n columns.
<br>
&nbsp;Esc[s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Save current cursor position.
<br>
&nbsp;Esc[u &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Restore cursor to saved position.
<br>
&nbsp;Esc[6n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Return current cursor position on the standard input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; handle in the format Esc[row;colR.
<br>
&nbsp;Esc[nm &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Select character attributes:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = no special attributes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = high intensity
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 = low intensity
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 = italic
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 = underline
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 = blink
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 = rapid blink
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 = reverse video
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 = concealed text (no display)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 30 = foreground black
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 31 = foreground red
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 32 = foreground green
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 33 = foreground yellow
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 34 = foreground blue
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 35 = foreground magenta
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 36 = foreground cyan
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 37 = foreground white
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 40 = background black
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 41 = background red
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42 = background green
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 43 = background yellow
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 44 = background blue
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 45 = background magenta
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 46 = background cyan
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 47 = background white
<br>
&nbsp;Esc[=nh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select display mode:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = 40-by-25, 16-color text (color burst off)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = 40-by-25, 16-color text
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 = 80-by-25, 16-color text (color burst off)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 = 80-by-25, 16-color text
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 = 320-by-200, 4-color graphics
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 = 320-by-200, 4-color graphics (color burst off)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 = 620-by-200, 2-color graphics
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 14 = 640-by-200, 16-color graphics (EGA and VGA,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MS-DOS 4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 15 = 640-by-350, 2-color graphics (EGA and VGA,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MS-DOS 4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 16 = 640-by-350, 16-color graphics (EGA and VGA,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MS-DOS 4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 17 = 640-by-480, 2-color graphics (MCGA and VGA,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MS-DOS 4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 18 = 640-by-480, 16-color graphics (VGA, MS-DOS 4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 19 = 320-by-200, 256-color graphics (MCGA and VGA,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MS-DOS 4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Escape sequences terminated with l instead of h have
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the same effect.
<br>
&nbsp;Esc[=7h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Enable line wrap.
<br>
&nbsp;Esc[=7l &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Disable line wrap.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 6-2. &nbsp;The ANSI escape sequences supported by the MS-DOS ANSI.SYS
<br>
&nbsp;driver. Programs running under MS-DOS 2.0 or later may use these
<br>
&nbsp;functions, if ANSI.SYS is loaded, to control the appearance of the display
<br>
&nbsp;in a hardware-independent manner. The symbol Esc indicates an ASCII escape
<br>
&nbsp;code──a character with the value 1BH. Note that cursor positions in ANSI
<br>
&nbsp;escape sequences are one-based, unlike the cursor coordinates used by the
<br>
&nbsp;IBM ROM BIOS, which are zero-based. Numbers embedded in an escape sequence
<br>
&nbsp;must always be represented as a string of ASCII digits, not as their
<br>
&nbsp;binary values.
<br>
<br>
Binary Output Mode
<br>
<br>
&nbsp;Under MS-DOS version 2 or later, you can substantially increase display
<br>
&nbsp;speeds for well-behaved application programs without sacrificing hardware
<br>
&nbsp;independence by selecting binary (raw) mode for the standard output. In
<br>
&nbsp;binary mode, MS-DOS does not check between each character it transfers to
<br>
&nbsp;the output device for a Ctrl-C waiting at the keyboard, nor does it filter
<br>
&nbsp;the output string for certain characters such as Ctrl-Z.
<br>
<br>
&nbsp;Bit 5 in the device information word associated with a device handle
<br>
&nbsp;controls binary mode. Programs access the device information word by using
<br>
&nbsp;Subfunctions 00H and 01H of the MS-DOS IOCTL function (I/O Control, Int
<br>
&nbsp;21H Function 44H). For example, the sequence on the following page places
<br>
&nbsp;the standard output handle into binary mode.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get device information...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp;; standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4400h &nbsp; &nbsp;; function 44h subfunction 00h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dh,0 &nbsp; &nbsp; &nbsp; &nbsp;; set upper byte of DX = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;dl,20h &nbsp; &nbsp; &nbsp;; set binary mode bit in DL
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write device information...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; (BX still has handle)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4401h &nbsp; &nbsp;; function 44h subfunction 01h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Note that if a program changes the mode of any of the standard handles, it
<br>
&nbsp;should restore those handles to ASCII (cooked) mode before it exits.
<br>
&nbsp;Otherwise, subsequent application programs may behave in unexpected ways.
<br>
&nbsp;For more detailed information on the IOCTL function, see Section II of
<br>
&nbsp;this book, &quot;MS-DOS Functions Reference.&quot;
<br>
<br>
<br>
The ROM BIOS Display Functions
<br>
<br>
&nbsp;You can somewhat improve the display performance of programs that are
<br>
&nbsp;intended for use only on IBM PC─compatible machines by using the ROM BIOS
<br>
&nbsp;video driver instead of the MS-DOS output functions. Accessed by means of
<br>
&nbsp;Int 10H, the ROM BIOS driver supports the following functions for all of
<br>
&nbsp;the currently available IBM display adapters:
<br>
<br>
<br>
&nbsp;Function &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Display mode control
<br>
&nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set display mode.
<br>
&nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get display mode.
<br>
<br>
&nbsp;Cursor control
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set cursor size.
<br>
&nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set cursor position.
<br>
&nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get cursor position and size.
<br>
<br>
&nbsp;Writing to the display
<br>
&nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write character and attribute at cursor.
<br>
&nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write character-only at cursor.
<br>
&nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write character in teletype mode.
<br>
<br>
&nbsp;Reading from the display
<br>
&nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read character and attribute at cursor.
<br>
<br>
&nbsp;Graphics support
<br>
&nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write pixel.
<br>
&nbsp;0DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read pixel.
<br>
<br>
&nbsp;Scroll or clear display
<br>
&nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Scroll up or initialize window.
<br>
&nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Scroll down or initialize window.
<br>
<br>
&nbsp;Miscellaneous
<br>
&nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read light pen.
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Select display page.
<br>
&nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Select palette/set border color.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Additional ROM BIOS functions are available on the EGA, MCGA, VGA, and
<br>
&nbsp;PCjr to support the enhanced features of these adapters, such as
<br>
&nbsp;programmable palettes and character sets (fonts). Some of the functions
<br>
&nbsp;are valid only in certain display modes.
<br>
<br>
&nbsp;Each display mode is characterized by the number of colors it can display,
<br>
&nbsp;its vertical resolution, its horizontal resolution, and whether it
<br>
&nbsp;supports text or graphics memory mapping. The ROM BIOS identifies it with
<br>
&nbsp;a unique number. Section III of this book, &quot;IBM ROM BIOS and Mouse
<br>
&nbsp;Functions Reference,&quot; documents all of the ROM BIOS Int 10H functions and
<br>
&nbsp;display modes.
<br>
<br>
&nbsp;As you can see from the preceding list, the ROM BIOS offers several
<br>
&nbsp;desirable capabilities that are not available from MS-DOS, including
<br>
&nbsp;initialization or scrolling of selected screen windows, modification of
<br>
&nbsp;the cursor shape, and reading back the character being displayed at an
<br>
&nbsp;arbitrary screen location. These functions can be used to isolate your
<br>
&nbsp;program from the hardware on any IBM PC─compatible adapter. However, the
<br>
&nbsp;ROM BIOS functions do not suffice for the needs of a high-performance,
<br>
&nbsp;interactive, full-screen program such as a word processor. They do not
<br>
&nbsp;support the rapid display of character strings at an arbitrary screen
<br>
&nbsp;position, and they do not implement graphics operations at the level
<br>
&nbsp;normally required by applications (for example, bit-block transfers and
<br>
&nbsp;rapid drawing of lines, circles, and filled polygons). And, of course,
<br>
&nbsp;they are of no use whatsoever in non-IBM display modes such as the
<br>
&nbsp;monochrome graphics mode of the Hercules Graphics Card.
<br>
<br>
&nbsp;Let's look at a simple example of a call to the ROM BIOS video driver. The
<br>
&nbsp;following sequence writes the string hello to the screen:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'hello'
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,seg msg &nbsp;; DS:SI = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp;; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cld
<br>
&nbsp;next: &nbsp; lodsb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get AL = next character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;si &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save message pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0eh &nbsp; &nbsp; &nbsp;; int 10h function 0eh = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; character in teletype mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bh,0 &nbsp; &nbsp; &nbsp; &nbsp;; assume video page 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,color &nbsp; &nbsp;; (use in graphics modes only)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 10h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to ROM BIOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; si &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore message pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop &nbsp; &nbsp;next &nbsp; &nbsp; &nbsp; &nbsp;; loop until message done
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;(Note that the SI and DI registers are not necessarily preserved across a
<br>
&nbsp;call to a ROM BIOS video function.)
<br>
<br>
<br>
Memory-mapped Display Techniques
<br>
<br>
&nbsp;Display performance is best when an application program takes over
<br>
&nbsp;complete control of the video adapter and the refresh buffer. Because the
<br>
&nbsp;display is memory-mapped, the speed at which characters can be put on the
<br>
&nbsp;screen is limited only by the CPU's ability to copy bytes from one
<br>
&nbsp;location in memory to another. The trade-off for this performance is that
<br>
&nbsp;such programs are highly sensitive to hardware compatibility and do not
<br>
&nbsp;always function properly on &quot;clones&quot; or even on new models of IBM video
<br>
&nbsp;adapters.
<br>
<br>
Text Mode
<br>
<br>
&nbsp;Direct programming of the IBM PC─compatible video adapters in their text
<br>
&nbsp;display modes (sometimes also called alphanumeric display modes) is
<br>
&nbsp;straightforward. The character set is the same for all, and the cursor
<br>
&nbsp;home position──(x,y) = (0,0)──is defined to be the upper left corner of
<br>
&nbsp;the screen (Figure 6-3). The MDA uses 4 KB of memory starting at segment
<br>
&nbsp;B000H as a regen buffer, and the various adapters with both text and
<br>
&nbsp;graphics capabilities (CGA, EGA, MCGA, and VGA) use 16 KB of memory
<br>
&nbsp;starting at segment B800H. (See Figure 6-1.) In the latter case, the 16
<br>
&nbsp;KB is divided into &quot;pages&quot; that can be independently updated and
<br>
&nbsp;displayed.
<br>
<br>
&nbsp; (0,0)┌─────────────────────────────────┐(79,0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;(0,24)└─────────────────────────────────┘(79,24)
<br>
<br>
&nbsp;Figure 6-3. &nbsp;Cursor addressing for 80-by-25 text display modes (IBM ROM
<br>
&nbsp;BIOS modes 2, 3, and 7).
<br>
<br>
&nbsp;Each character-display position is allotted 2 bytes in the regen buffer.
<br>
&nbsp;The first byte (even address) contains the ASCII code of the character,
<br>
&nbsp;which is translated by a special hardware character generator into a
<br>
&nbsp;dot-matrix pattern for the screen. The second byte (odd address) is the
<br>
&nbsp;attribute byte. Several bit fields in this byte control such features as
<br>
&nbsp;blinking, intensity (highlighting), and reverse video, depending on the
<br>
&nbsp;adapter type and display mode (Figures 6-4 and 6-5). Figure 6-6 shows a
<br>
&nbsp;hex and ASCII dump of part of the video map for the MDA.
<br>
<br>
&nbsp;Display &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Background &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Foreground
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;No display (black) &nbsp; &nbsp; &nbsp; 000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 000
<br>
&nbsp;No display (white)
<br>
VGA only
<br>
&nbsp; &nbsp; &nbsp;111 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 111
<br>
&nbsp;Underline &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 001
<br>
&nbsp;Normal video &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 111
<br>
&nbsp;Reverse video &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;111 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 000
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 6-4. &nbsp;Attribute byte for 80-by-25 monochrome text display mode on
<br>
&nbsp;the MDA, Hercules cards, EGA, and VGA (IBM ROM BIOS mode 7).
<br>
<br>
&nbsp;Value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Color
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Black
<br>
&nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Blue
<br>
&nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Green
<br>
&nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cyan
<br>
&nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Red
<br>
&nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Magenta
<br>
&nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Brown
<br>
&nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; White
<br>
&nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Gray
<br>
&nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Light blue
<br>
&nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Light green
<br>
&nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Light cyan
<br>
&nbsp;12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Light red
<br>
&nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Light magenta
<br>
&nbsp;14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Yellow
<br>
&nbsp;15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Intense white
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 6-5. &nbsp;Attribute byte for the 40-by-25 and 80-by-25 text display
<br>
&nbsp;modes on the CGA, EGA, MCGA, and VGA (IBM ROM BIOS modes 0─3). The table
<br>
&nbsp;of color values assumes default palette programming and that the B or I
<br>
&nbsp;bit controls intensity.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;B000:0000 3e 07 73 07 65 07 6c 07 65 07 63 07 74 07 20 07
<br>
&nbsp;B000:0010 74 07 65 07 6d 07 70 07 20 07 20 07 20 07 20 07
<br>
&nbsp;B000:0020 20 07 20 07 20 07 20 07 20 07 20 07 20 07 20 07
<br>
&nbsp;B000:0030 20 07 20 07 20 07 20 07 20 07 20 07 20 07 20 07
<br>
&nbsp;B000:0040 20 07 20 07 20 07 20 07 20 07 20 07 20 07 20 07
<br>
&nbsp;B000:0050 20 07 20 07 20 07 20 07 20 07 20 07 20 07 20 07
<br>
&nbsp;B000:0060 20 07 20 07 20 07 20 07 20 07 20 07 20 07 20 07
<br>
&nbsp;B000:0070 20 07 20 07 20 07 20 07 20 07 20 07 20 07 20 07
<br>
&nbsp;B000:0080 20 07 20 07 20 07 20 07 20 07 20 07 20 07 20 07
<br>
&nbsp;B000:0090 20 07 20 07 20 07 20 07 20 07 20 07 20 07 20 07
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 6-6. &nbsp;Example dump of the first 160 bytes of the MDA's regen
<br>
&nbsp;buffer. These bytes correspond to the first visible line on the screen.
<br>
&nbsp;Note that ASCII character codes are stored in even bytes and their
<br>
&nbsp;respective character attributes in odd bytes; all the characters in this
<br>
&nbsp;example line have the attribute normal video.
<br>
<br>
&nbsp;You can calculate the memory offset of any character on the display as the
<br>
&nbsp;line number (y coordinate) times 80 characters per line times 2 bytes per
<br>
&nbsp;character, plus the column number (x coordinate) times 2 bytes per
<br>
&nbsp;character, plus (for the text/graphics adapters) the page number times the
<br>
&nbsp;size of the page (4 KB per page in 80-by-25 modes; 2 KB per page in
<br>
&nbsp;40-by-25 modes). In short, the formula for the offset of the
<br>
&nbsp;character-attribute pair for a given screen position (x,y) in 80-by-25
<br>
&nbsp;text modes is
<br>
<br>
&nbsp; &nbsp;offset = ((y * 50H + x) * 2) + (page * 1000H)
<br>
<br>
&nbsp;In 40-by-25 text modes, the formula is
<br>
<br>
&nbsp; &nbsp;offset = ((y * 50H + x) * 2) + (page * 0800H)
<br>
<br>
&nbsp;Of course, the segment register being used to address the video buffer
<br>
&nbsp;must be set appropriately, depending on the type of display adapter.
<br>
<br>
&nbsp;As a simple example, assume that the character to be displayed is in the
<br>
&nbsp;AL register, the desired attribute byte for the character is in the AH
<br>
&nbsp;register, the x coordinate (column) is in the BX register, and the y
<br>
&nbsp;coordinate (row) is in the CX register. The following code stores the
<br>
&nbsp;character and attribute byte into the MDA's video refresh buffer at the
<br>
&nbsp;proper location:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save char and attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,160
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mul &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DX:AX = Y * 160
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shl &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp;; multiply X by 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; bx,ax &nbsp; &nbsp; &nbsp; ; BX = (Y*160) + (X*2)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,0b000h &nbsp; ; ES = segment of monochrome
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,ax &nbsp; &nbsp; &nbsp; ; adapter refresh buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore char and attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[bx],ax &nbsp;; write them to video buffer
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;More frequently, we wish to move entire strings into the refresh buffer,
<br>
&nbsp;starting at a given coordinate. In the next example, assume that the DS:SI
<br>
&nbsp;registers point to the source string, the ES:DI registers point to the
<br>
&nbsp;starting position in the video buffer (calculated as shown in the previous
<br>
&nbsp;example), the AH register contains the attribute byte to be assigned to
<br>
&nbsp;every character in the string, and the CX register contains the length of
<br>
&nbsp;the string. The following code moves the entire string into the refresh
<br>
&nbsp;buffer:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;xfer: &nbsp; lodsb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; fetch next character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stosw &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; store char + attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop &nbsp; &nbsp;xfer &nbsp; &nbsp; &nbsp; &nbsp;; until all chars moved
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Of course, the video drivers written for actual application programs must
<br>
&nbsp;take into account many additional factors, such as checking for special
<br>
&nbsp;control codes (linefeeds, carriage returns, tabs), line wrap, and
<br>
&nbsp;scrolling.
<br>
<br>
&nbsp;Programs that write characters directly to the CGA regen buffer in text
<br>
&nbsp;modes must deal with an additional complicating factor──they must examine
<br>
&nbsp;the video controller's status port and access the refresh buffer only
<br>
&nbsp;during the horizontal retrace or vertical retrace intervals. (A retrace
<br>
&nbsp;interval is the period when the electron beam that illuminates the screen
<br>
&nbsp;phosphors is being repositioned to the start of a new scan line.)
<br>
&nbsp;Otherwise, the contention for memory between the CPU and the video
<br>
&nbsp;controller is manifest as unsightly &quot;snow&quot; on the display. (If you are
<br>
&nbsp;writing programs for any of the other IBM PC─compatible video adapters,
<br>
&nbsp;such as the MDA, EGA, MCGA, or VGA, you can ignore the retrace intervals;
<br>
&nbsp;snow is not a problem with these video controllers.)
<br>
<br>
&nbsp;A program can detect the occurrence of a retrace interval by monitoring
<br>
&nbsp;certain bits in the video controller's status register. For example,
<br>
&nbsp;assume that the offset for the desired character position has been
<br>
&nbsp;calculated as in the preceding example and placed in the BX register, the
<br>
&nbsp;segment for the CGA's refresh buffer is in the ES register, and an ASCII
<br>
&nbsp;character code to be displayed is in the CL register. The following code
<br>
&nbsp;waits for the beginning of a new horizontal retrace interval and then
<br>
&nbsp;writes the character into the buffer:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,03dah &nbsp; &nbsp;; DX = video controller's
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; status port address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cli &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; disable interrupts
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if retrace is already
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; in progress, wait for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; it to end...
<br>
&nbsp;wait1: &nbsp;in &nbsp; &nbsp; &nbsp;al,dx &nbsp; &nbsp; &nbsp; ; read status port
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp;; check if retrace bit on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; wait1 &nbsp; &nbsp; &nbsp; ; yes, wait
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; wait for new retrace
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; interval to start...
<br>
&nbsp;wait2: &nbsp;in &nbsp; &nbsp; &nbsp;al,dx &nbsp; &nbsp; &nbsp; ; read status port
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp;; retrace bit on yet?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;wait2 &nbsp; &nbsp; &nbsp; ; jump if not yet on
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[bx],cl &nbsp;; write character to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; the regen buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sti &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; enable interrupts again
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The first wait loop &quot;synchronizes&quot; the code to the beginning of a
<br>
&nbsp;horizontal retrace interval. If only the second wait loop were used (that
<br>
&nbsp;is, if a character were written when a retrace interval was already in
<br>
&nbsp;progress), the write would occasionally begin so close to the end of a
<br>
&nbsp;horizontal retrace &quot;window&quot; that it would partially miss the retrace,
<br>
&nbsp;resulting in scattered snow at the left edge of the display. Notice that
<br>
&nbsp;the code also disables interrupts during accesses to the video buffer, so
<br>
&nbsp;that service of a hardware interrupt won't disrupt the synchronization
<br>
&nbsp;process.
<br>
<br>
&nbsp;Because of the retrace-interval constraints just outlined, the rate at
<br>
&nbsp;which you can update the CGA in text modes is severely limited when the
<br>
&nbsp;updating is done one character at a time. You can obtain better results by
<br>
&nbsp;calculating all the relevant addresses and setting up the appropriate
<br>
&nbsp;registers, disabling the video controller by writing to register 3D8H,
<br>
&nbsp;moving the entire string to the buffer with a REP MOVSW operation, and
<br>
&nbsp;then reenabling the video controller. If the string is of reasonable
<br>
&nbsp;length, the user won't even notice a flicker in the display. Of course,
<br>
&nbsp;this procedure introduces additional hardware dependence into your code
<br>
&nbsp;because it requires much greater knowledge of the 6845 controller.
<br>
&nbsp;Luckily, snow is not a problem in CGA graphics modes.
<br>
<br>
Graphics Mode
<br>
<br>
&nbsp;Graphics-mode memory-mapped programming for IBM PC─compatible adapters is
<br>
&nbsp;considerably more complicated than text-mode programming. Each bit or
<br>
&nbsp;group of bits in the regen buffer corresponds to an addressable point, or
<br>
&nbsp;pixel, on the screen. The mapping of bits to pixels differs for each of
<br>
&nbsp;the available graphics modes, with their differences in resolution and
<br>
&nbsp;number of supported colors. The newer adapters (EGA, MCGA, and VGA) also
<br>
&nbsp;use the concept of bit planes, where bits of a pixel are segregated into
<br>
&nbsp;multiple banks of memory mapped at the same address; you must manipulate
<br>
&nbsp;these bit planes by a combination of memory-mapped I/O and port
<br>
&nbsp;addressing.
<br>
<br>
&nbsp;IBM-video-systems graphics programming is a subject large enough for a
<br>
&nbsp;book of its own, but we can use the 640-by-200, 2-color graphics display
<br>
&nbsp;mode of the CGA (which is also supported by all subsequent IBM
<br>
&nbsp;text/graphics adapters) to illustrate a few of the techniques involved.
<br>
&nbsp;This mode is simple to deal with because each pixel is represented by a
<br>
&nbsp;single bit. The pixels are assigned (x,y) coordinates in the range (0,0)
<br>
&nbsp;through (639,199), where x is the horizontal displacement, y is the
<br>
&nbsp;vertical displacement, and the home position (0,0) is the upper left
<br>
&nbsp;corner of the display. (See Figure 6-7.)
<br>
<br>
&nbsp; &nbsp;(0,0)┌─────────────────────────────────┐(639,0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;(0,199)└─────────────────────────────────┘(639,199)
<br>
<br>
&nbsp;Figure 6-7. &nbsp;Point addressing for 640-by-200, 2-color graphics modes on
<br>
&nbsp;the CGA, EGA, MCGA, and VGA (IBM ROM BIOS mode 6).
<br>
<br>
&nbsp;Each successive group of 80 bytes (640 bits) represents one horizontal
<br>
&nbsp;scan line. Within each byte, the bits map one-for-one onto pixels, with
<br>
&nbsp;the most significant bit corresponding to the leftmost displayed pixel of
<br>
&nbsp;a set of eight pixels and the least significant bit corresponding to the
<br>
&nbsp;rightmost displayed pixel of the set. The memory map is set up so that all
<br>
&nbsp;the even y coordinates are scanned as a set and all the odd y coordinates
<br>
&nbsp;are scanned as a set; this mapping is referred to as the memory interlace.
<br>
<br>
&nbsp;To find the regen buffer offset for a particular (x,y) coordinate, you
<br>
&nbsp;would use the following formula:
<br>
<br>
&nbsp; &nbsp;offset = ((y AND 1) * 2000H) + (y/2 * 50H) + (x/8)
<br>
<br>
&nbsp;The assembly-language implementation of this formula is as follows:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; assume AX = Y, BX = X
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp;; divide X by 8
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; bx,1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; bx,1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save copy of Y
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; ax,1 &nbsp; &nbsp; &nbsp; &nbsp;; find (Y/2) * 50h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,50h &nbsp; &nbsp; &nbsp;; with product in DX:AX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mul &nbsp; &nbsp; cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; bx,ax &nbsp; &nbsp; &nbsp; ; add product to X/8
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; add (Y AND 1) * 2000h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; ax,1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;label1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; bx,2000h
<br>
&nbsp;label1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; now BX = offset into
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; video buffer
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;After calculating the correct byte address, you can use the following
<br>
&nbsp;formula to calculate the bit position for a given pixel coordinate:
<br>
<br>
&nbsp; &nbsp;bit = 7 - (x MOD 8)
<br>
<br>
&nbsp;where bit 7 is the most significant bit and bit 0 is the least significant
<br>
&nbsp;bit. It is easiest to build an 8-byte table, or array of bit masks, and
<br>
&nbsp;use the operation X AND 7 to extract the appropriate entry from the table:
<br>
<br>
&nbsp;(X AND 7) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit mask &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(X AND 7) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit mask
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;08H
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;40H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;20H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H
<br>
&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The assembly-language implementation of this second calculation is as
<br>
&nbsp;follows:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;table &nbsp; db &nbsp; &nbsp; &nbsp;80h &nbsp; &nbsp; &nbsp; &nbsp; ; X AND 7 = offset 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;40h &nbsp; &nbsp; &nbsp; &nbsp; ; X AND 7 = offset 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;20h &nbsp; &nbsp; &nbsp; &nbsp; ; X AND 7 = offset 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;10h &nbsp; &nbsp; &nbsp; &nbsp; ; X AND 7 = offset 3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;08h &nbsp; &nbsp; &nbsp; &nbsp; ; X AND 7 = offset 4
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;04h &nbsp; &nbsp; &nbsp; &nbsp; ; X AND 7 = offset 5
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;02h &nbsp; &nbsp; &nbsp; &nbsp; ; X AND 7 = offset 6
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;01h &nbsp; &nbsp; &nbsp; &nbsp; ; X AND 7 = offset 7
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; assume BX = X coordinate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; bx,7 &nbsp; &nbsp; &nbsp; &nbsp;; isolate 0─7 offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,[bx+table]
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now AL = mask from table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The program can then use the mask, together with the byte offset
<br>
&nbsp;previously calculated, to set or clear the appropriate bit in the video
<br>
&nbsp;controller's regen buffer.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 7 &nbsp;Printer and Serial Port
<br>
<br>
&nbsp;MS-DOS supports printers, plotters, modems, and other hard-copy output or
<br>
&nbsp;communication devices with device drivers for parallel ports and serial
<br>
&nbsp;ports. Parallel ports are so named because they transfer a byte──8 bits──
<br>
&nbsp;in parallel to the destination device over eight separate physical paths
<br>
&nbsp;(plus additional status and handshaking signals). The serial port, on the
<br>
&nbsp;other hand, communicates with the CPU with bytes but sends data to or
<br>
&nbsp;receives data from its destination device serially──a bit at a time──over
<br>
&nbsp;a single physical connection.
<br>
<br>
&nbsp;Parallel ports are typically used for high-speed output devices, such as
<br>
&nbsp;line printers, over relatively short distances (less than 50 feet). They
<br>
&nbsp;are rarely used for devices that require two-way communication with the
<br>
&nbsp;computer. Serial ports are used for lower-speed devices, such as modems
<br>
&nbsp;and terminals, that require two-way communication (although some printers
<br>
&nbsp;also have serial interfaces). A serial port can drive its device reliably
<br>
&nbsp;over much greater distances (up to 1000 feet) over as few as three wires──
<br>
&nbsp;transmit, receive, and ground.
<br>
<br>
&nbsp;The most commonly used type of serial interface follows a standard called
<br>
&nbsp;RS-232. This standard specifies a 25-wire interface with certain
<br>
&nbsp;electrical characteristics, the use of various handshaking signals, and a
<br>
&nbsp;standard DB-25 connector. Other serial-interface standards exist──for
<br>
&nbsp;example, the RS-422, which is capable of considerably higher speeds than
<br>
&nbsp;the RS-232── but these are rarely used in personal computers (except for
<br>
&nbsp;the Apple Macintosh) at this time.
<br>
<br>
&nbsp;MS-DOS has built-in device drivers for three parallel adapters, and for
<br>
&nbsp;two serial adapters on the PC or PC/AT and three serial adapters on the
<br>
&nbsp;PS/2. The logical names for these devices are LPT1, LPT2, LPT3, COM1,
<br>
&nbsp;COM2, and COM3. The standard printer (PRN) and standard auxiliary (AUX)
<br>
&nbsp;devices are normally aliased to LPT1 and COM1, but you can redirect PRN to
<br>
&nbsp;one of the serial ports with the MS-DOS MODE command.
<br>
<br>
&nbsp;As with keyboard and video display I/O, you can manage printer and
<br>
&nbsp;serial-port I/O at several levels that offer different degrees of
<br>
&nbsp;flexibility and hardware independence:
<br>
<br>
&nbsp;■ &nbsp;MS-DOS handle-oriented functions
<br>
<br>
&nbsp;■ &nbsp;MS-DOS traditional character functions
<br>
<br>
&nbsp;■ &nbsp;IBM ROM BIOS driver functions
<br>
<br>
&nbsp;In the case of the serial port, direct control of the hardware by
<br>
&nbsp;application programs is also common. I will discuss each of these I/O
<br>
&nbsp;methods briefly, with examples, in the following pages.
<br>
<br>
<br>
Printer Output
<br>
<br>
&nbsp;The preferred method of printer output is to use the handle write function
<br>
&nbsp;(Int 21H Function 40H) with the predefined standard printer handle (4).
<br>
&nbsp;For example, you could write the string hello to the printer as follows:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'hello' &nbsp; &nbsp; ; message for printer
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg &nbsp; &nbsp; &nbsp; ; length of message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp;; function 40h = write file or device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,4 &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard printer handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp;; CX = length of string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg msg &nbsp;; DS:DX = string address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; ; jump if error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;If there is no error, the function returns the carry flag cleared and the
<br>
&nbsp;number of characters actually transferred to the list device in register
<br>
&nbsp;AX. Under normal circumstances, this number should always be the same as
<br>
&nbsp;the length requested and the carry flag indicating an error should never
<br>
&nbsp;be set. However, the output will terminate early if your data contains an
<br>
&nbsp;end-of-file mark (Ctrl-Z).
<br>
<br>
&nbsp;You can write independently to several list devices (for example, LPT1,
<br>
&nbsp;LPT2) by issuing a specific open request (Int 21H Function 3DH) for each
<br>
&nbsp;device and using the handles returned to access the printers individually
<br>
&nbsp;with Int 21H Function 40H. You have already seen this general approach in
<br>
&nbsp;Chapters 5 and 6.
<br>
<br>
&nbsp;An alternative method of printer output is to use the traditional Int 21H
<br>
&nbsp;Function 05H, which transfers the character in the DL register to the
<br>
&nbsp;printer. (This function is sensitive to Ctrl-C interrupts.) For example,
<br>
&nbsp;the assembly-language code sequence at the top of the following page would
<br>
&nbsp;write the the string hello to the line printer.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'hello' &nbsp; &nbsp; ; message for printer
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg &nbsp; &nbsp; &nbsp; ; length of message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,seg msg &nbsp;; DS:BX = string address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp;; CX = string length
<br>
<br>
&nbsp;next: &nbsp; mov &nbsp; &nbsp; dl,[bx] &nbsp; &nbsp; ; get next character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,5 &nbsp; &nbsp; &nbsp; &nbsp;; function 05h = printer output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bump string pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop &nbsp; &nbsp;next &nbsp; &nbsp; &nbsp; &nbsp;; loop until string done
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Programs that run on IBM PC─compatible machines can obtain improved
<br>
&nbsp;printer throughput by bypassing MS-DOS and calling the ROM BIOS printer
<br>
&nbsp;driver directly by means of Int 17H. Section III of this book, &quot;IBM ROM
<br>
&nbsp;BIOS and Mouse Functions Reference,&quot; documents the Int 17H functions in
<br>
&nbsp;detail. Use of the ROM BIOS functions also allows your program to test
<br>
&nbsp;whether the printer is off line or out of paper, a capability that MS-DOS
<br>
&nbsp;does not offer.
<br>
<br>
&nbsp;For example, the following sequence of instructions calls the ROM BIOS
<br>
&nbsp;printer driver to send the string hello to the line printer:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'hello' &nbsp; &nbsp; ; message for printer
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg &nbsp; &nbsp; &nbsp; ; length of message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,seg msg &nbsp;; DS:BX = string address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp;; CX = string length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,0 &nbsp; &nbsp; &nbsp; &nbsp;; DX = printer number
<br>
<br>
&nbsp;next: &nbsp; mov &nbsp; &nbsp; al,[bx] &nbsp; &nbsp; ; AL = character to print
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0 &nbsp; &nbsp; &nbsp; &nbsp;; function 00h = printer output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 17h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to ROM BIOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bump string pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop &nbsp; &nbsp;next &nbsp; &nbsp; &nbsp; &nbsp;; loop until string done
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Note that the printer numbers used by the ROM BIOS are zero-based, whereas
<br>
&nbsp;the printer numbers in MS-DOS logical-device names are one-based. For
<br>
&nbsp;example, ROM BIOS printer 0 corresponds to LPT1.
<br>
<br>
&nbsp;Finally, the most hardware-dependent technique of printer output is to
<br>
&nbsp;access the printer controller directly. Considering the functionality
<br>
&nbsp;already provided in MS-DOS and the IBM ROM BIOS, as well as the speeds of
<br>
&nbsp;the devices involved, I cannot see any justification for using direct
<br>
&nbsp;hardware control in this case. The disadvantage of introducing such
<br>
&nbsp;extreme hardware dependence for such a low-speed device would far outweigh
<br>
&nbsp;any small performance gains that might be obtained.
<br>
<br>
<br>
The Serial Port
<br>
<br>
&nbsp;MS-DOS support for serial ports (often referred to as the auxiliary device
<br>
&nbsp;in MS-DOS manuals) is weak compared with its keyboard, video-display, and
<br>
&nbsp;printer support. This is one area where the application programmer is
<br>
&nbsp;justified in making programs hardware dependent to extract adequate
<br>
&nbsp;performance.
<br>
<br>
&nbsp;Programs that restrict themselves to MS-DOS functions to ensure
<br>
&nbsp;portability can use the handle read and write functions (Int 21H Functions
<br>
&nbsp;3FH and 40H), with the predefined standard auxiliary handle (3) to
<br>
&nbsp;access the serial port. For example, the following code writes the string
<br>
&nbsp;hello to the serial port that is currently defined as the AUX device:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'hello' &nbsp; &nbsp; ; message for serial port
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg &nbsp; &nbsp; &nbsp; ; length of message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp;; function 40h = write file or device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,3 &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard aux handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp;; CX = string length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg msg &nbsp;; DS:DX = string address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; ; jump if error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The standard auxiliary handle gives access to only the first serial port
<br>
&nbsp;(COM1). If you want to read or write COM2 and COM3 using the handle calls,
<br>
&nbsp;you must issue an open request (Int 21H Function 3DH) for the desired
<br>
&nbsp;serial port and use the handle returned by that function with Int 21H
<br>
&nbsp;Functions 3FH and 40H.
<br>
<br>
&nbsp;Some versions of MS-DOS have a bug in character-device handling that
<br>
&nbsp;manifests itself as follows: If you issue a read request with Int 21H
<br>
&nbsp;Function 3FH for the exact number of characters that are waiting in the
<br>
&nbsp;driver's buffer, the length returned in the AX register is the number of
<br>
&nbsp;characters transferred minus one. You can circumvent this problem by
<br>
&nbsp;always requesting more characters than you expect to receive or by placing
<br>
&nbsp;the device handle into binary mode using Int 21H Function 44H.
<br>
<br>
&nbsp;MS-DOS also supports two traditional functions for serial-port I/O. Int
<br>
&nbsp;21H Function 03H inputs a character from COM1 and returns it in the AL
<br>
&nbsp;register; Int 21H Function 04H transmits the character in the DL register
<br>
&nbsp;to COM1. Like the other traditional calls, these two are direct
<br>
&nbsp;descendants of the CP/M auxiliary-device functions.
<br>
<br>
&nbsp;For example, the following code sends the string hello to COM1 using the
<br>
&nbsp;traditional Int 21H Function 04H:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'hello' &nbsp; &nbsp; ; message for serial port
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg &nbsp; &nbsp; &nbsp; ; length of message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,seg msg &nbsp;; DS:BX = string address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp;; CX = length of string
<br>
&nbsp; &nbsp;mov &nbsp; &nbsp; dl,[bx] &nbsp; &nbsp; ; get next character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4 &nbsp; &nbsp; &nbsp; &nbsp;; function 04h = aux output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bump pointer to string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop &nbsp; &nbsp;next &nbsp; &nbsp; &nbsp; &nbsp;; loop until string done
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;MS-DOS translates the traditional auxiliary-device functions into calls on
<br>
&nbsp;the same device driver used by the handle calls. Therefore, it is
<br>
&nbsp;generally preferable to use the handle functions in the first place,
<br>
&nbsp;because they allow very long strings to be read or written in one
<br>
&nbsp;operation, they give access to serial ports other than COM1, and they are
<br>
&nbsp;symmetrical with the handle video-display, keyboard, printer, and file I/O
<br>
&nbsp;methods described elsewhere in this book.
<br>
<br>
&nbsp;Although the handle or traditional serial-port functions allow you to
<br>
&nbsp;write programs that are portable to any machine running MS-DOS, they have
<br>
&nbsp;a number of disadvantages:
<br>
<br>
&nbsp;■ &nbsp;The built-in MS-DOS serial-port driver is slow and is not interrupt
<br>
&nbsp; &nbsp; driven.
<br>
<br>
&nbsp;■ &nbsp;MS-DOS serial-port I/O is not buffered.
<br>
<br>
&nbsp;■ &nbsp;Determinin                                                                                                                                                                                                                           rs no standardized function to configure the serial port
<br>
&nbsp; &nbsp; from within a program.
<br>
<br>
&nbsp;For programs that are going to run on the IBM PC or compatibles, a more
<br>
&nbsp;flexible technique for serial-port I/O is to call the IBM ROM BIOS
<br>
&nbsp;serial-port driver by means of Int 14H. You can use this driver to
<br>
&nbsp;initialize the serial port to a desired configuration and baud rate,
<br>
&nbsp;examine the status of the controller, and read or write characters.
<br>
&nbsp;Section III of this book, &quot;IBM ROM BIOS and Mouse Functions Reference,&quot;
<br>
&nbsp;documents the functions available from the ROM BIOS serial-port driver.
<br>
<br>
&nbsp;For example, the following sequence sends the character X to the first
<br>
&nbsp;serial port (COM1):
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1 &nbsp; &nbsp; &nbsp; &nbsp;; function 01h = send character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,'X' &nbsp; &nbsp; &nbsp;; AL = character to transmit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,0 &nbsp; &nbsp; &nbsp; &nbsp;; DX = serial-port number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 14h &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to ROM BIOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; ah,80h &nbsp; &nbsp; &nbsp;; did transmit fail?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; ; jump if transmit error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;As with the ROM BIOS printer driver, the serial-port numbers used by the
<br>
&nbsp;ROM BIOS are zero-based, whereas the serial-port numbers in MS-DOS
<br>
&nbsp;logical-device names are one-based. In this example, serial port 0
<br>
&nbsp;corresponds to COM1.
<br>
<br>
&nbsp;Unfortunately, like the MS-DOS auxiliary-device driver, the ROM BIOS
<br>
&nbsp;serial-port driver is not interrupt driven. Although it will support
<br>
&nbsp;higher transfer speeds than the MS-DOS functions, at rates greater than
<br>
&nbsp;2400 baud it may still lose characters. Consequently, most programmers
<br>
&nbsp;writing high-performance applications that use a serial port (such as
<br>
&nbsp;telecommunications programs) take complete control of the serial-port
<br>
&nbsp;controller and provide their own interrupt driver. The built-in functions
<br>
&nbsp;provided by MS-DOS, and by the ROM BIOS in the case of the IBM PC, are
<br>
&nbsp;simply not adequate.
<br>
<br>
&nbsp;Writing such programs requires a good understanding of the hardware. In
<br>
&nbsp;the case of the IBM PC, the chips to study are the INS8250 Asynchronous
<br>
&nbsp;Communications Controller and the Intel 8259A Programmable Interrupt
<br>
&nbsp;Controller. The IBM technical reference documentation for these chips is a
<br>
&nbsp;bit disorganized, but most of the necessary information is there if you
<br>
&nbsp;look for it.
<br>
<br>
<br>
The TALK Program
<br>
<br>
&nbsp;The simple terminal-emulator program TALK.ASM (Figure 7-1) is an example
<br>
&nbsp;of a useful program that performs screen, keyboard, and serial-port I/O.
<br>
&nbsp;This program recapitulates all of the topics discussed in Chapters 5
<br>
&nbsp;through 7. TALK uses the IBM PC's ROM BIOS video driver to put characters
<br>
&nbsp;on the screen, to clear the display, and to position the cursor; it uses
<br>
&nbsp;the MS-DOS character-input calls to read the keyboard; and it contains its
<br>
&nbsp;own interrupt driver for the serial-port controller.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp; &nbsp;talk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page &nbsp; &nbsp; &nbsp;55,132
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.lfcond &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; List false conditionals too
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;title &nbsp; &nbsp; TALK--Simple terminal emulator
<br>
<br>
&nbsp;;
<br>
&nbsp;; TALK.ASM--Simple IBM PC terminal emulator
<br>
&nbsp;;
<br>
&nbsp;; Copyright (c) 1988 Ray Duncan
<br>
&nbsp;;
<br>
&nbsp;; To assemble and link this program into TALK.EXE:
<br>
&nbsp;;
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; C&gt;MASM TALK;
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; C&gt;LINK TALK;
<br>
&nbsp;;
<br>
<br>
&nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard input handle
<br>
&nbsp;stdout &nbsp;equ &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp;stderr &nbsp;equ &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard error handle
<br>
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII linefeed
<br>
&nbsp;bsp &nbsp; &nbsp; equ &nbsp; &nbsp; 08h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII backspace
<br>
&nbsp;escape &nbsp;equ &nbsp; &nbsp; 1bh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII escape code
<br>
<br>
&nbsp;dattr &nbsp; equ &nbsp; &nbsp; 07h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; display attribute to use
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; while in emulation mode
<br>
<br>
&nbsp;bufsiz &nbsp;equ &nbsp; &nbsp; 4096 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; size of serial-port buffer
<br>
<br>
&nbsp;echo &nbsp; &nbsp;equ &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 0 = full-duplex, -1 = half-duplex
<br>
&nbsp; &nbsp; equ &nbsp; &nbsp; -1
<br>
&nbsp;false &nbsp; equ &nbsp; &nbsp; 0
<br>
<br>
&nbsp;com1 &nbsp; &nbsp;equ &nbsp; &nbsp; true &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; use COM1 if nonzero
<br>
&nbsp;com2 &nbsp; &nbsp;equ &nbsp; &nbsp; not com1 &nbsp; &nbsp; &nbsp; &nbsp;; use COM2 if nonzero
<br>
<br>
&nbsp;pic_mask &nbsp;equ &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 8259 interrupt mask port
<br>
&nbsp;pic_eoi &nbsp; equ &nbsp; 20h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 8259 EOI port
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if &nbsp; &nbsp; &nbsp;com1
<br>
&nbsp;com_data equ &nbsp; &nbsp;03f8h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; port assignments for COM1
<br>
&nbsp;com_ier &nbsp;equ &nbsp; &nbsp;03f9h
<br>
&nbsp;com_mcr &nbsp;equ &nbsp; &nbsp;03fch
<br>
&nbsp;com_sts &nbsp;equ &nbsp; &nbsp;03fdh
<br>
&nbsp;com_int &nbsp;equ &nbsp; &nbsp;0ch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; COM1 interrupt number
<br>
&nbsp;int_mask equ &nbsp; &nbsp;10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; IRQ4 mask for 8259
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;endif
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if &nbsp; &nbsp; &nbsp;com2
<br>
&nbsp;com_data equ &nbsp; &nbsp;02f8h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; port assignments for COM2
<br>
&nbsp;com_ier &nbsp;equ &nbsp; &nbsp;02f9h
<br>
&nbsp;com_mcr &nbsp;equ &nbsp; &nbsp;02fch
<br>
&nbsp;com_sts &nbsp;equ &nbsp; &nbsp;02fdh
<br>
&nbsp;com_int &nbsp;equ &nbsp; &nbsp;0bh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; COM2 interrupt number
<br>
&nbsp;int_mask equ &nbsp; &nbsp;08h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; IRQ3 mask for 8259
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;endif
<br>
<br>
&nbsp;_TEXT &nbsp; segment word public 'CODE'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assume &nbsp;cs:_TEXT,ds:_DATA,es:_DATA,ss:STACK
<br>
<br>
&nbsp;talk &nbsp; &nbsp;proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; entry point from MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp;; make data segment addressable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; initialize display for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; terminal emulator mode...
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get display width and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; current display mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dec &nbsp; &nbsp; ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save display width for use
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; columns,ah &nbsp; &nbsp; &nbsp;; by the screen-clear routine
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; enforce text display mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;talk2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; mode 7 ok, proceed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; al,3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jbe &nbsp; &nbsp; talk2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; modes 0-3 ok, proceed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg1_len
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; talk6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; print error message and exit
<br>
<br>
&nbsp;talk2: &nbsp;mov &nbsp; &nbsp; bh,dattr &nbsp; &nbsp; &nbsp; &nbsp;; clear screen and home cursor
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;cls
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;asc_enb &nbsp; &nbsp; &nbsp; &nbsp; ; capture serial-port interrupt
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; vector and enable interrupts
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg2 &nbsp;; display message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg2_len &nbsp; &nbsp; ; 'terminal emulator running'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; BX = standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write file or device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;talk3: &nbsp;call &nbsp; &nbsp;pc_stat &nbsp; &nbsp; &nbsp; &nbsp; ; keyboard character waiting?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;talk4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; nothing waiting, jump
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;pc_in &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; read keyboard character
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; is it a function key?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; talk32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; not function key, jump
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;pc_in &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; function key, discard 2nd
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; character of sequence
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; talk5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; then terminate program
<br>
<br>
&nbsp;talk32: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; keyboard character received
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if &nbsp; &nbsp; &nbsp;echo
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if half-duplex, echo
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;pc_out &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; character to PC display
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;endif
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;com_out &nbsp; &nbsp; &nbsp; &nbsp; ; write char to serial port
<br>
<br>
&nbsp;talk4: &nbsp;call &nbsp; &nbsp;com_stat &nbsp; &nbsp; &nbsp; &nbsp;; serial-port character waiting?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;talk3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; nothing waiting, jump
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;com_in &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read serial-port character
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,20h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; is it control code?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jae &nbsp; &nbsp; talk45 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if not
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;ctrl_code &nbsp; &nbsp; &nbsp; ; control code, process it
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; talk3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check keyboard again
<br>
<br>
&nbsp;talk45: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; noncontrol char received,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;pc_out &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write it to PC display
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; talk4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; see if any more waiting
<br>
<br>
&nbsp;talk5: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function key detected,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; prepare to terminate...
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bh,07h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; clear screen and home cursor
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;cls
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg3 &nbsp;; display farewell message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg3_len
<br>
<br>
&nbsp;talk6: &nbsp;push &nbsp; &nbsp;dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and message length
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;asc_dsb &nbsp; &nbsp; &nbsp; &nbsp; ; disable serial-port interrupts
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and release interrupt vector
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and address
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; handle for standard output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp;; terminate program with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return code = 0
<br>
<br>
&nbsp;talk &nbsp; &nbsp;endp
<br>
<br>
&nbsp;com_stat proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; check asynch status; returns
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Z = false if character ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Z = true if nothing waiting
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,asc_in &nbsp; &nbsp; &nbsp; ; compare ring buffer pointers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,asc_out
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to caller
<br>
&nbsp;stat endp
<br>
<br>
&nbsp;com_in &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get character from serial-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; port buffer; returns
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; new character in AL
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save register BX
<br>
<br>
&nbsp;com_in1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if no char waiting, wait
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,asc_out &nbsp; &nbsp; &nbsp;; until one is received
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; bx,asc_in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;com_in1 &nbsp; &nbsp; &nbsp; &nbsp; ; jump, nothing waiting
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,[bx+asc_buf] ; character is ready,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; extract it from buffer
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; update buffer pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; bx,bufsiz
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; com_in2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; bx,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; reset pointer if wrapped
<br>
&nbsp;com_in2:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; asc_out,bx &nbsp; &nbsp; &nbsp;; store updated pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore register BX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and return to caller
<br>
<br>
&nbsp;com_in &nbsp;endp
<br>
<br>
&nbsp;com_out proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write character in AL
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to serial port
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save register DX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save character to send
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,com_sts &nbsp; &nbsp; &nbsp;; DX = status port address
<br>
<br>
&nbsp;com_out1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check if transmit buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in &nbsp; &nbsp; &nbsp;al,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is empty (TBE bit = set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; al,20h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;com_out1 &nbsp; &nbsp; &nbsp; &nbsp;; no, must wait
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get character to send
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,com_data &nbsp; &nbsp; ; DX = data port address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;out &nbsp; &nbsp; dx,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transmit the character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore register DX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and return to caller
<br>
<br>
&nbsp;com_out endp
<br>
&nbsp;pc_stat proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read keyboard status; returns
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Z = false if character ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Z = true if nothing waiting
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; register DX destroyed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,in_flag &nbsp; &nbsp; &nbsp;; if character already
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; waiting, return status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; pc_stat1
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; otherwise call MS-DOS to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,0ffh &nbsp; &nbsp; &nbsp; &nbsp; ; determine keyboard status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;pc_stat1 &nbsp; &nbsp; &nbsp; &nbsp;; jump if no key ready
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; in_char,al &nbsp; &nbsp; &nbsp;; got key, save it for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; in_flag,0ffh &nbsp; &nbsp;; &quot;pc_in&quot; routine
<br>
<br>
&nbsp;pc_stat1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to caller with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Z flag set appropriately
<br>
<br>
&nbsp;pc_stat endp
<br>
<br>
&nbsp;pc_in &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read keyboard character,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return it in AL
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DX may be destroyed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,in_flag &nbsp; &nbsp; &nbsp;; key already waiting?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; pc_in1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; yes, return it to caller
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;pc_stat &nbsp; &nbsp; &nbsp; &nbsp; ; try to read a character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; pc_in
<br>
<br>
&nbsp;pc_in1: mov &nbsp; &nbsp; in_flag,0 &nbsp; &nbsp; &nbsp; ; clear char-waiting flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,in_char &nbsp; &nbsp; &nbsp;; and return AL = character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;pc_in &nbsp; endp
<br>
<br>
&nbsp;pc_out &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write character in AL
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to the PC's display
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ROM BIOS function 0eh =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &quot;teletype output&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save register BX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; bx,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; assume page 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to ROM BIOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore register BX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and return to caller
<br>
<br>
&nbsp;pc_out &nbsp;endp
<br>
<br>
<br>
&nbsp;cls &nbsp; &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; clear display using
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; char attribute in BH
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; registers AX, CX,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and DX destroyed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,columns &nbsp; &nbsp; &nbsp;; set DL,DH = X,Y of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dh,24 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; lower right corner
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set CL,CH = X,Y of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; upper left corner
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,600h &nbsp; &nbsp; &nbsp; &nbsp; ; ROM BIOS function 06h =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &quot;scroll or initialize
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; window&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to ROM BIOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;home &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set cursor at (0,0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and return to caller
<br>
<br>
&nbsp;cls &nbsp; &nbsp; endp
<br>
<br>
&nbsp;clreol &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; clear from cursor to end
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; of line using attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; in BH, registers AX, CX,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and DX destroyed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;getxy &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get current cursor position
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; current position = &quot;upper
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; left corner&quot; of window;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,columns &nbsp; &nbsp; &nbsp;; &quot;lower right corner&quot; X is
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; max columns, Y is same
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; as upper left corner
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,600h &nbsp; &nbsp; &nbsp; &nbsp; ; ROM BIOS function 06h =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &quot;scroll or initialize
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; window&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to ROM BIOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to caller
<br>
<br>
&nbsp;clreol &nbsp;endp
<br>
&nbsp;home &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; put cursor at home position
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set (X,Y) = (0,0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;gotoxy &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; position the cursor
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to caller
<br>
<br>
&nbsp;home &nbsp; &nbsp;endp
<br>
<br>
&nbsp;gotoxy &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; position the cursor
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call with DL = X, DH = Y
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bh,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; assume page 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ROM BIOS function 02h =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set cursor position
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to ROM BIOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and return to caller
<br>
<br>
&nbsp;gotoxy &nbsp;endp
<br>
<br>
<br>
&nbsp;getxy &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get cursor position,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns DL = X, DH = Y
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cx
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ROM BIOS function 03h =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get cursor position
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bh,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; assume page 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to ROM BIOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and return to caller
<br>
<br>
&nbsp;getxy &nbsp; endp
<br>
&nbsp;ctrl_code proc &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; process control code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call with AL = char
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,cr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; if carriage return
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;ctrl8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; just send it
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,lf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; if linefeed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;ctrl8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; just send it
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,bsp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if backspace
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;ctrl8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; just send it
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,26 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is it cls control code?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; ctrl7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, jump
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bh,dattr &nbsp; &nbsp; &nbsp; &nbsp;; cls control code, clear
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;cls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; screen and home cursor
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; ctrl9
<br>
<br>
&nbsp;ctrl7:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,escape &nbsp; &nbsp; &nbsp; ; is it Escape character?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; ctrl9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, throw it away
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;esc_seq &nbsp; &nbsp; &nbsp; &nbsp; ; yes, emulate CRT terminal
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; ctrl9
<br>
<br>
&nbsp;ctrl8: &nbsp;call &nbsp; &nbsp;pc_out &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; send CR, LF, or backspace
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to the display
<br>
<br>
&nbsp;ctrl9: &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to caller
<br>
<br>
&nbsp;ctrl_code endp
<br>
<br>
<br>
&nbsp;esc_seq proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; decode Televideo 950 escape
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; sequence for screen control
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;com_in &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get next character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,84 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is it clear to end of line?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; esc_seq1 &nbsp; &nbsp; &nbsp; &nbsp;; no, jump
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bh,dattr &nbsp; &nbsp; &nbsp; &nbsp;; yes, clear to end of line
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;clreol
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; esc_seq2 &nbsp; &nbsp; &nbsp; &nbsp;; then exit
<br>
&nbsp;esc_seq1:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,61 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is it cursor positioning?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; esc_seq2 &nbsp; &nbsp; &nbsp; &nbsp;; no jump
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;com_in &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; yes, get Y parameter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub &nbsp; &nbsp; al,33 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and remove offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dh,al
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;com_in &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get X parameter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub &nbsp; &nbsp; al,33 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and remove offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,al
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;gotoxy &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; position the cursor
<br>
<br>
&nbsp;esc_seq2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to caller
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;esc_seq endp
<br>
<br>
<br>
&nbsp;asc_enb proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; capture serial-port interrupt
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; vector and enable interrupt
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save address of previous
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; interrupt handler...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,3500h+com_int ; function 35h = get vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr oldvec+2,es
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr oldvec,bx
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now install our handler...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,cs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set DS:DX = address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; of our interrupt handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset asc_int
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,2500h+com_int ; function 25h = set vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore data segment
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,com_mcr &nbsp; &nbsp; &nbsp;; set modem-control register
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0bh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DTR and OUT2 bits
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;out &nbsp; &nbsp; dx,al
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,com_ier &nbsp; &nbsp; &nbsp;; set interrupt-enable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; register on serial-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;out &nbsp; &nbsp; dx,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; port controller
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in &nbsp; &nbsp; &nbsp;al,pic_mask &nbsp; &nbsp; ; read current 8259 mask
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; al,not int_mask ; set mask for COM port
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;out &nbsp; &nbsp; pic_mask,al &nbsp; &nbsp; ; write new 8259 mask
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to caller
<br>
<br>
&nbsp;asc_enb endp
<br>
<br>
<br>
&nbsp;asc_dsb proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; disable interrupt and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; release interrupt vector
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in &nbsp; &nbsp; &nbsp;al,pic_mask &nbsp; &nbsp; ; read current 8259 mask
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,int_mask &nbsp; &nbsp; ; reset mask for COM port
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;out &nbsp; &nbsp; pic_mask,al &nbsp; &nbsp; ; write new 8259 mask
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lds &nbsp; &nbsp; dx,oldvec &nbsp; &nbsp; &nbsp; ; load address of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; previous interrupt handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,2500h+com_int ; function 25h = set vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore data segment
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to caller
<br>
<br>
&nbsp;asc_dsb endp
<br>
<br>
<br>
&nbsp;asc_int proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; interrupt service routine
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; for serial port
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sti &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; turn interrupts back on
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp;; make our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; addressable
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cli &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; clear interrupts for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; pointer manipulation
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,com_data &nbsp; &nbsp; ; DX = data port address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in &nbsp; &nbsp; &nbsp;al,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; read this character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,asc_in &nbsp; &nbsp; &nbsp; ; get buffer pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; [asc_buf+bx],al ; store this character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bump pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; bx,bufsiz &nbsp; &nbsp; &nbsp; ; time for wrap?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; asc_int1 &nbsp; &nbsp; &nbsp; &nbsp;; no, jump
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; bx,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; yes, reset pointer
<br>
<br>
&nbsp;asc_int1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; store updated pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; asc_in,bx
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sti &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; turn interrupts back on
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,20h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; send EOI to 8259
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;out &nbsp; &nbsp; pic_eoi,al
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore all registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return from interrupt
<br>
<br>
&nbsp;asc_int endp
<br>
<br>
&nbsp;_TEXT &nbsp; ends
<br>
<br>
<br>
&nbsp;_DATA &nbsp; segment word public 'DATA'
<br>
<br>
&nbsp;in_char db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; PC keyboard input char
<br>
&nbsp;in_flag db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &lt;&gt;0 if char waiting
<br>
<br>
&nbsp;columns db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; highest numbered column in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; current display mode (39 or 79)
<br>
<br>
&nbsp;msg1 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Display must be text mode.'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp;msg1_len equ $-msg1
<br>
<br>
&nbsp;msg2 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Terminal emulator running...'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp;msg2_len equ $-msg2
<br>
<br>
&nbsp;msg3 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Exit from terminal emulator.'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp;msg3_len equ $-msg3
<br>
&nbsp;oldvec &nbsp;dd &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; original contents of serial-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; port interrupt vector
<br>
<br>
&nbsp;asc_in &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; input pointer to ring buffer
<br>
&nbsp;asc_out dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; output pointer to ring buffer
<br>
<br>
&nbsp;asc_buf db &nbsp; &nbsp; &nbsp;bufsiz dup (?) &nbsp;; communications buffer
<br>
<br>
&nbsp;_DATA &nbsp; ends
<br>
<br>
<br>
&nbsp;STACK &nbsp; segment para stack 'STACK'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;128 dup (?)
<br>
<br>
&nbsp;STACK &nbsp; ends
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end &nbsp; &nbsp; talk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp;defines entry point
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 7-1. &nbsp;TALK.ASM: A simple terminal-emulator program for IBM
<br>
&nbsp;PC─compatible computers. This program demonstrates use of the MS-DOS and
<br>
&nbsp;ROM BIOS video and keyboard functions and direct control of the
<br>
&nbsp;serial-communications adapter.
<br>
<br>
&nbsp;The TALK program illustrates the methods that an application should use to
<br>
&nbsp;take over and service interrupts from the serial port without running
<br>
&nbsp;afoul of MS-DOS conventions.
<br>
<br>
&nbsp;The program begins with some equates and conditional assembly statements
<br>
&nbsp;that configure the program for half- or full-duplex and for the desired
<br>
&nbsp;serial port (COM1 or COM2). At entry from MS-DOS, the main routine of the
<br>
&nbsp;program──the procedure named talk──checks the status of the serial port,
<br>
&nbsp;initializes the display, and calls the asc_enb routine to take over the
<br>
&nbsp;serial-port interrupt vector and enable interrupts. The talk procedure
<br>
&nbsp;then enters a loop that reads the keyboard and sends the characters out
<br>
&nbsp;the serial port and then reads the serial port and puts the characters on
<br>
&nbsp;the display──in other words, it causes the PC to emulate a simple CRT
<br>
&nbsp;terminal.
<br>
<br>
&nbsp;The TALK program intercepts and handles control codes (carriage return,
<br>
&nbsp;linefeed, and so forth) appropriately. It detects escape sequences and
<br>
&nbsp;handles them as a subset of the Televideo 950 terminal capabilities. (You
<br>
&nbsp;can easily modify the program to emulate any other cursor-addressable
<br>
&nbsp;terminal.) When one of the PC's special function keys is pressed, the
<br>
&nbsp;program disables serial-port interrupts, releases the serial-port
<br>
&nbsp;interrupt vector, and exits back to MS-DOS.
<br>
<br>
&nbsp;There are several TALK program procedures that are worth your attention
<br>
&nbsp;because they can easily be incorporated into other programs. These are
<br>
&nbsp;listed in the table on the following page.
<br>
<br>
<br>
&nbsp;Procedure &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;asc_enb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Takes over the serial-port interrupt vector and enables
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interrupts by writing to the modem-control register of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the INS8250 and the interrupt-mask register of the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8259A.
<br>
<br>
&nbsp;asc_dsb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Restores the original state of the serial-port
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interrupt vector and disables interrupts by writing to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the interrupt-mask register of the 8259A.
<br>
<br>
&nbsp;asc_int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Services serial-port interrupts, placing received
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; characters into a ring buffer.
<br>
<br>
&nbsp;com_stat &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Tests whether characters from the serial port are
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waiting in the ring buffer.
<br>
<br>
&nbsp;com_in &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Removes characters from the interrupt handler's ring
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer and increments the buffer pointers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appropriately.
<br>
<br>
&nbsp;com_out &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sends one character to the serial port.
<br>
<br>
&nbsp;cls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Calls the ROM BIOS video driver to clear the screen.
<br>
<br>
&nbsp;clreol &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Calls the ROM BIOS video driver to clear from the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current cursor position to the end of the line.
<br>
<br>
&nbsp;home &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Places the cursor in the upper left corner of the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; screen.
<br>
<br>
&nbsp;gotoxy &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Positions the cursor at the desired position on the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; display.
<br>
<br>
&nbsp;getxy &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Obtains the current cursor position.
<br>
<br>
&nbsp;pc_out &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sends one character to the PC's display.
<br>
<br>
&nbsp;pc_stat &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Gets status for the PC's keyboard.
<br>
<br>
&nbsp;pc_in &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Returns a character from the PC's keyboard.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 8 &nbsp;File Management
<br>
<br>
&nbsp;The dual heritage of MS-DOS──CP/M and UNIX/XENIX──is perhaps most clearly
<br>
&nbsp;demonstrated in its file-management services. In general, MS-DOS provides
<br>
&nbsp;at least two distinct operating-system calls for each major file or record
<br>
&nbsp;operation. This chapter breaks this overlapping battery of functions into
<br>
&nbsp;two groups and explains the usage, advantages, and disadvantages of each.
<br>
<br>
&nbsp;I will refer to the set of file and record functions that are compatible
<br>
&nbsp;with CP/M as FCB functions. These functions rely on a data structure
<br>
&nbsp;called a file control block (hence, FCB) to maintain certain bookkeeping
<br>
&nbsp;information about open files. This structure resides in the application
<br>
&nbsp;program's memory space. The FCB functions allow the programmer to create,
<br>
&nbsp;open, close, and delete files and to read or write records of any size at
<br>
&nbsp;any record position within such files. These functions do not support the
<br>
&nbsp;hierarchical (treelike) file structure that was first introduced in MS-DOS
<br>
&nbsp;version 2.0, so they can be used only to access files in the current
<br>
&nbsp;subdirectory for a given disk drive.
<br>
<br>
&nbsp;I will refer to the set of file and record functions that provide
<br>
&nbsp;compatibility with UNIX/XENIX as the handle functions. These functions
<br>
&nbsp;allow the programmer to open or create files by passing MS-DOS a
<br>
&nbsp;null-terminated string that describes the file's location in the
<br>
&nbsp;hierarchical file structure (the drive and path), the file's name, and its
<br>
&nbsp;extension. If the open or create operation is successful, MS-DOS returns a
<br>
&nbsp;16-bit token, or handle, that is saved by the application program and used
<br>
&nbsp;to specify the file in subsequent operations.
<br>
<br>
&nbsp;When you use the handle functions, the operating system maintains the data
<br>
&nbsp;structures that contain bookkeeping information about the file inside its
<br>
&nbsp;own memory space, and these structures are not accessible to the
<br>
&nbsp;application program. The handle functions fully support the hierarchical
<br>
&nbsp;file structure, allowing the programmer to create, open, close, and delete
<br>
&nbsp;files in any subdirectory on any disk drive and to read or write records
<br>
&nbsp;of any size at any byte offset within such files.
<br>
<br>
&nbsp;Although we are discussing the FCB functions first in this chapter for
<br>
&nbsp;historical reasons, new MS-DOS applications should always be written using
<br>
&nbsp;the more powerful handle functions. Use of the FCB functions in new
<br>
&nbsp;programs should be avoided, unless compatibility with MS-DOS version 1.0
<br>
&nbsp;is needed.
<br>
<br>
<br>
Using the FCB Functions
<br>
<br>
&nbsp;Understanding the structure of the file control block is the key to
<br>
&nbsp;success with the FCB family of file and record functions. An FCB is a
<br>
&nbsp;37-byte data structure allocated within the application program's memory
<br>
&nbsp;space; it is divided into many fields (Figure 8-1). Typically, the
<br>
&nbsp;program initializes an FCB with a drive code, a filename, and an extension
<br>
&nbsp;(conveniently accomplished with the parse-filename service, Int 21H
<br>
&nbsp;Function 29H) and then passes the address of the FCB to MS-DOS to open or
<br>
&nbsp;create the file. If the file is successfully opened or created, MS-DOS
<br>
&nbsp;fills in certain fields of the FCB with information from the file's entry
<br>
&nbsp;in the disk directory. This information includes the file's exact size in
<br>
&nbsp;bytes and the date and time the file was created or last updated. MS-DOS
<br>
&nbsp;also places certain other information within a reserved area of the FCB;
<br>
&nbsp;however, this area is used by the operating system for its own purposes
<br>
&nbsp;and varies among different versions of MS-DOS. Application programs should
<br>
&nbsp;never modify the reserved area.
<br>
<br>
&nbsp;For compatibility with CP/M, MS-DOS automatically sets the record-size
<br>
&nbsp;field of the FCB to 128 bytes. If the program does not want to use this
<br>
&nbsp;default record size, it must place the desired size (in bytes) into the
<br>
&nbsp;record-size field after the open or create operation. Subsequently, when
<br>
&nbsp;the program needs to read or write records from the file, it must pass the
<br>
&nbsp;address of the FCB to MS-DOS; MS-DOS, in turn, keeps the FCB updated with
<br>
&nbsp;information about the current position of the file pointer and the size of
<br>
&nbsp;the file. Data is always read to or written from the current disk transfer
<br>
&nbsp;area (DTA), whose address is set with Int 21H Function 1AH. If the
<br>
&nbsp;application program wants to perform random record access, it must set the
<br>
&nbsp;record number into the FCB before issuing each function call; when
<br>
&nbsp;sequential record access is being used, MS-DOS maintains the FCB and no
<br>
&nbsp;special intervention is needed from the application.
<br>
<br>
&nbsp;Byte offset
<br>
&nbsp;00H ┌───────────────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Drive identification &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 1
<br>
&nbsp;01H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filename (8 characters) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 2
<br>
&nbsp;09H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Extension (3 characters) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 2
<br>
&nbsp;0CH ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Current block number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 9
<br>
&nbsp;0EH ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Record size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 10
<br>
&nbsp;10H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;File size (4 bytes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Notes 3, 6
<br>
&nbsp;14H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Date created/updated &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 7
<br>
&nbsp;16H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Time created/updated &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 8
<br>
&nbsp;18H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;20H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Current-record number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ Note 9
<br>
&nbsp;21H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relative-record number (4 bytes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 5
<br>
&nbsp; &nbsp; &nbsp;└───────────────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 8-1. &nbsp;Normal file control block. Total length is 37 bytes (25H
<br>
&nbsp;bytes). See notes on pages 133─34.
<br>
<br>
&nbsp;In general, MS-DOS functions that use FCBs accept the full address of the
<br>
&nbsp;FCB in the DS:DX register and pass back a return code in the AL register
<br>
&nbsp;(Figure 8-2). For file-management calls (open, close, create, and
<br>
&nbsp;delete), this return code is zero if the function was successful and 0FFH
<br>
&nbsp;(255) if the function failed. For the FCB-type record read and write
<br>
&nbsp;functions, the success code returned in the AL register is again zero, but
<br>
&nbsp;there are several failure codes. Under MS-DOS version 3.0 or later, more
<br>
&nbsp;detailed error reporting can be obtained by calling Int 21H Function 59H
<br>
&nbsp;(Get Extended Error Information) after a failed FCB function call.
<br>
<br>
&nbsp;When a program is loaded under MS-DOS, the operating system sets up two
<br>
&nbsp;FCBs in the program segment prefix, at offsets 005CH and 006CH. These are
<br>
&nbsp;often referred to as the default FCBs, and they are included to provide
<br>
&nbsp;upward compatibility from CP/M. MS-DOS parses the first two parameters in
<br>
&nbsp;the command line that invokes the program (excluding any redirection
<br>
&nbsp;directives) into the default FCBs, under the assumption that they may be
<br>
&nbsp;file specifications. The application must determine whether they really
<br>
&nbsp;are filenames or not. In addition, because the default FCBs overlap and
<br>
&nbsp;are not in a particularly convenient location (especially for .EXE
<br>
&nbsp;programs), they usually must be copied elsewhere in order to be used
<br>
&nbsp;safely. (See Chapter 3.)
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; filename was previously
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; parsed into &quot;my_fcb&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; dx,seg my_fcb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:DX = address of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; ds,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; file control block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; dx,offset my_fcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; ah,0fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; function 0fh = open
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; was open successful?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; no, jump to error routine
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;my_fcb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp;37 dup (0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file control block
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 8-2. &nbsp;A typical FCB file operation. This sequence of code attempts
<br>
&nbsp;to open the file whose name was previously parsed into the FCB named
<br>
&nbsp;my_fcb.
<br>
<br>
&nbsp;Note that the structures of FCBs under CP/M and MS-DOS are not identical.
<br>
&nbsp;However, the differences lie chiefly in the reserved areas of the FCBs
<br>
&nbsp;(which should not be manipulated by application programs in any case), so
<br>
&nbsp;well-behaved CP/M applications should be relatively easy to port into
<br>
&nbsp;MS-DOS. It seems, however, that few such applications exist. Many of the
<br>
&nbsp;tricks that were played by clever CP/M programmers to increase performance
<br>
&nbsp;or circumvent the limitations of that operating system can cause severe
<br>
&nbsp;problems under MS-DOS, particularly in networking environments. At any
<br>
&nbsp;rate, much better performance can be achieved by thoroughly rewriting the
<br>
&nbsp;CP/M applications to take advantage of the superior capabilities of
<br>
&nbsp;MS-DOS.
<br>
<br>
&nbsp;You can use a special FCB variant called an extended file control block to
<br>
&nbsp;create or access files with special attributes (such as hidden or
<br>
&nbsp;read-only files), volume labels, and subdirectories. An extended FCB has a
<br>
&nbsp;7-byte header followed by the 37-byte structure of a normal FCB (Figure
<br>
&nbsp;8-3). The first byte contains 0FFH, which could never be a legal drive
<br>
&nbsp;code and thus indicates to MS-DOS that an extended FCB is being used. The
<br>
&nbsp;next 5 bytes are reserved and are unused in current versions of MS-DOS.
<br>
&nbsp;The seventh byte contains the attribute of the special file type that is
<br>
&nbsp;being accessed. (Attribute bytes are discussed in more detail in Chapter
<br>
&nbsp;9.) Any MS-DOS function that uses a normal FCB can also use an extended
<br>
&nbsp;FCB.
<br>
<br>
&nbsp;The FCB file- and record-management functions may be gathered into the
<br>
&nbsp;following broad classifications:
<br>
<br>
&nbsp;Byte
<br>
&nbsp;offset
<br>
&nbsp;00H ┌───────────────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0FFH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 11
<br>
&nbsp;01H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved (5 bytes, must be zero) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;06H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Attribute byte &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ Note 12
<br>
&nbsp;07H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Drive identification &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 1
<br>
&nbsp;08H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filename (8 characters) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 2
<br>
&nbsp;10H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Extension (3 characters) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 2
<br>
&nbsp;13H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Current-block number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 9
<br>
&nbsp;15H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Record size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 10
<br>
&nbsp;17H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;File size (4 bytes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Notes 3, 6
<br>
&nbsp;1BH ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Date created/updated &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 7
<br>
&nbsp;1DH ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Time created/updated &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 8
<br>
&nbsp;1FH ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;27H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Current-record number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ Note 9
<br>
&nbsp;28H ├───────────────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relative-record number (4 bytes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Note 5
<br>
&nbsp; &nbsp; &nbsp;└───────────────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 8-3. &nbsp;Extended file control block. Total length is 44 bytes (2CH
<br>
&nbsp;bytes). See notes on pages 133─34.
<br>
<br>
<br>
&nbsp;Function &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Common FCB file operations
<br>
&nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Open file.
<br>
&nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Close file.
<br>
&nbsp;16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Create file.
<br>
<br>
&nbsp;Common FCB record operations
<br>
&nbsp;14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Perform sequential read.
<br>
&nbsp;15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Perform sequential write.
<br>
&nbsp;21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Perform random read.
<br>
&nbsp;22H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Perform random write.
<br>
&nbsp;27H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Perform random block read.
<br>
&nbsp;28H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Perform random block write.
<br>
<br>
&nbsp;Other vital FCB operations
<br>
&nbsp;1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set disk transfer address.
<br>
&nbsp;29H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Parse filename.
<br>
<br>
&nbsp;Less commonly used FCB file operations
<br>
&nbsp;13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Delete file.
<br>
&nbsp;17H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rename file.
<br>
<br>
&nbsp;Less commonly used FCB record operations
<br>
&nbsp;23H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Obtain file size.
<br>
&nbsp;24H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set relative-record number.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Several of these functions have special properties. For example, Int 21H
<br>
&nbsp;Functions 27H (Random Block Read) and 28H (Random Block Write) allow
<br>
&nbsp;reading and writing of multiple records of any size and also update the
<br>
&nbsp;random-record field automatically (unlike Int 21H Functions 21H and
<br>
&nbsp;22H). Int 21H Function 28H can truncate a file to any desired size, and
<br>
&nbsp;Int 21H Function 17H used with an extended FCB can alter a volume label
<br>
&nbsp;or rename a subdirectory.
<br>
<br>
&nbsp;Section 2 of this book, &quot;MS-DOS Functions Reference,&quot; gives detailed
<br>
&nbsp;specifications for each of the FCB file and record functions, along with
<br>
&nbsp;assembly-language examples. It is also instructive to compare the
<br>
&nbsp;preceding groups with the corresponding groups of handle-type functions
<br>
&nbsp;listed on pages 140─41.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Notes for Figures 8-1 and 8-3
<br>
&nbsp; &nbsp;1. &nbsp;The drive identification is a binary number: 00=default drive,
<br>
&nbsp; &nbsp; &nbsp; &nbsp;01=drive A:, 02=drive B:, and so on. If the application program
<br>
&nbsp; &nbsp; &nbsp; &nbsp;supplies the drive code as zero (default drive), MS-DOS fills in the
<br>
&nbsp; &nbsp; &nbsp; &nbsp;code for the actual current disk drive after a successful open or
<br>
&nbsp; &nbsp; &nbsp; &nbsp;create call.
<br>
<br>
&nbsp; &nbsp;2. &nbsp;File and extension names must be left justified and padded with
<br>
&nbsp; &nbsp; &nbsp; &nbsp;blanks.
<br>
<br>
&nbsp; &nbsp;3. &nbsp;The file size, date, time, and reserved fields should not be
<br>
&nbsp; &nbsp; &nbsp; &nbsp;modified by applications.
<br>
<br>
&nbsp; &nbsp;4. &nbsp;All word fields are stored with the least significant byte at the
<br>
&nbsp; &nbsp; &nbsp; &nbsp;lower address.
<br>
<br>
&nbsp; &nbsp;5. &nbsp;The relative-record field is treated as 4 bytes if the record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp;is less than 64 bytes; otherwise, only the first 3 bytes of this
<br>
&nbsp; &nbsp; &nbsp; &nbsp;field are used.
<br>
<br>
&nbsp; &nbsp;6. &nbsp;The file-size field is in the same format as in the directory, with
<br>
&nbsp; &nbsp; &nbsp; &nbsp;the less significant word at the lower address.
<br>
<br>
&nbsp; &nbsp;7. &nbsp;The date field is mapped as in the directory. Viewed as a 16-bit
<br>
&nbsp; &nbsp; &nbsp; &nbsp;word (as it would appear in a register), the field is broken down as
<br>
&nbsp; &nbsp; &nbsp; &nbsp;follows:
<br>
<br>
&nbsp; &nbsp; &nbsp;F &nbsp;E &nbsp;D &nbsp;C &nbsp;B &nbsp;A &nbsp;9 &nbsp; 8 &nbsp; &nbsp; 7 &nbsp; &nbsp; 6 &nbsp; &nbsp; 5 &nbsp; &nbsp;4 &nbsp; 3 &nbsp; 2 &nbsp; 1 &nbsp; 0
<br>
&nbsp; &nbsp;┌─────────────────────┬─────────────────────┬─────────────────────┐
<br>
&nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp;Year &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp;Month &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; Day &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp;└─────────────────────┴─────────────────────┴─────────────────────┘
<br>
<br>
&nbsp; &nbsp;Bits &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contents
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H─04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Day (1─31)
<br>
&nbsp; &nbsp;05H─08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Month (1─12)
<br>
&nbsp; &nbsp;09H─0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Year, relative to 1980
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;8. &nbsp;The time field is mapped as in the directory. Viewed as a 16-bit
<br>
&nbsp; &nbsp; &nbsp; &nbsp;word (as it would appear in a register), the field is broken down as
<br>
&nbsp; &nbsp; &nbsp; &nbsp;follows:
<br>
<br>
&nbsp; &nbsp; &nbsp;F &nbsp; E &nbsp; D &nbsp; C &nbsp; B &nbsp; A &nbsp; 9 &nbsp; 8 &nbsp; 7 &nbsp; 6 &nbsp; 5 &nbsp; 4 &nbsp; 3 &nbsp; 2 &nbsp; 1 &nbsp; 0
<br>
&nbsp; &nbsp;┌───────────────────┬───────────────────────┬─────────────────────┐
<br>
&nbsp; &nbsp;│ &nbsp; &nbsp; Hours &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp;Minutes &nbsp; &nbsp; &nbsp; &nbsp;│ 2-second increments │
<br>
&nbsp; &nbsp;└───────────────────┴───────────────────────┴─────────────────────┘
<br>
<br>
&nbsp; &nbsp;Bits &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contents
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H─04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2-second increments (0─29)
<br>
&nbsp; &nbsp;05H─0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Minutes (0─59)
<br>
&nbsp; &nbsp;0BH─0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hours (0─23)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;9. &nbsp;The current-block and current-record numbers are used together on
<br>
&nbsp; &nbsp; &nbsp; &nbsp;sequential reads and writes. This simulates the behavior of CP/M.
<br>
<br>
&nbsp; &nbsp;10. The Int 21H open (0FH) and create (16H) functions set the
<br>
&nbsp; &nbsp; &nbsp; &nbsp;record-size field to 128 bytes, to provide compatibility with CP/M.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;If you use another record size, you must fill it in after the open
<br>
&nbsp; &nbsp; &nbsp; &nbsp;or create operation.
<br>
<br>
&nbsp; &nbsp;11. An 0FFH (255) in the first byte of the structure signifies that it
<br>
&nbsp; &nbsp; &nbsp; &nbsp;is an extended file control block. You can use extended FCBs with
<br>
&nbsp; &nbsp; &nbsp; &nbsp;any of the functions that accept an ordinary FCB. (See also note
<br>
&nbsp; &nbsp; &nbsp; &nbsp;12.)
<br>
<br>
&nbsp; &nbsp;12. The attribute byte in an extended FCB allows access to files with
<br>
&nbsp; &nbsp; &nbsp; &nbsp;the special characteristics hidden, system, or read-only. You can
<br>
&nbsp; &nbsp; &nbsp; &nbsp;also use extended FCBs to read volume labels and the contents of
<br>
&nbsp; &nbsp; &nbsp; &nbsp;special subdirectory files.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
FCB File-Access Skeleton
<br>
<br>
&nbsp;The following is a typical program sequence to access a file using the
<br>
&nbsp;FCB, or traditional, functions (Figure 8-4):
<br>
<br>
&nbsp;1. &nbsp;Zero out the prospective FCB.
<br>
<br>
&nbsp;2. &nbsp;Obtain the filename from the user, from the default FCBs, or from the
<br>
&nbsp; &nbsp; &nbsp;command tail in the PSP.
<br>
<br>
&nbsp;3. &nbsp;If the filename was not obtained from one of the default FCBs, parse
<br>
&nbsp; &nbsp; &nbsp;the filename into the new FCB using Int 21H Function 29H.
<br>
<br>
&nbsp;4. &nbsp;Open the file (Int 21H Function 0FH) or, if writing new data only,
<br>
&nbsp; &nbsp; &nbsp;create the file or truncate any existing file of the same name to zero
<br>
&nbsp; &nbsp; &nbsp;length (Int 21H Function 16H).
<br>
<br>
&nbsp;5. &nbsp;Set the record-size field in the FCB, unless you are using the default
<br>
&nbsp; &nbsp; &nbsp;record size. Recall that it is important to do this after a successful
<br>
&nbsp; &nbsp; &nbsp;open or create operation. (See Figure 8-5.)
<br>
<br>
&nbsp;6. &nbsp;Set the relative-record field in the FCB if you are performing random
<br>
&nbsp; &nbsp; &nbsp;record I/O.
<br>
<br>
&nbsp;7. &nbsp;Set the disk transfer area address using Int 21H Function 1AH, unless
<br>
&nbsp; &nbsp; &nbsp;the buffer address has not been changed since the last call to this
<br>
&nbsp; &nbsp; &nbsp;function. If the application never performs a set DTA, the DTA address
<br>
&nbsp; &nbsp; &nbsp;defaults to offset 0080H in the PSP.
<br>
<br>
&nbsp;8. &nbsp;Request the needed read- or write-record operation (Int 21H Function
<br>
&nbsp; &nbsp; &nbsp;14H─Sequential Read, 15H─Sequential Write, 21H─Random Read,
<br>
&nbsp; &nbsp; &nbsp;22H─Random Write, 27H─Random Block Read, 28H─Random Block Write).
<br>
<br>
&nbsp;9. &nbsp;If the program is not finished processing the file, go to step 6;
<br>
&nbsp; &nbsp; &nbsp;otherwise, close the file (Int 21H Function 10H). If the file was
<br>
&nbsp; &nbsp; &nbsp;used for reading only, you can skip the close operation under early
<br>
&nbsp; &nbsp; &nbsp;versions of MS-DOS. However, this shortcut can cause problems under
<br>
&nbsp; &nbsp; &nbsp;MS-DOS versions 3.0 and later, especially when the files are being
<br>
&nbsp; &nbsp; &nbsp;accessed across a network.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;recsize &nbsp; &nbsp; &nbsp;equ &nbsp; 1024 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,29h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; parse input filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; skip leading blanks
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; si,offset fname1 &nbsp; &nbsp; &nbsp; ; address of filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; di,offset fcb1 &nbsp; &nbsp; &nbsp; &nbsp; ; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; name_err &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; was bad
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,29h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; parse output filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; skip leading blanks
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; si,offset fname2 &nbsp; &nbsp; &nbsp; ; address of filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; di,offset fcb2 &nbsp; &nbsp; &nbsp; &nbsp; ; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; name_err &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; was bad
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,0fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; open input file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset fcb1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; open successful?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; no_file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; no, jump
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,16h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; create and open
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset fcb2 &nbsp; &nbsp; &nbsp; &nbsp; ; output file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; create successful?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; disk_full &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; no, jump
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set record sizes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; word ptr fcb1+0eh,recsize
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; word ptr fcb2+0eh,recsize
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set disk transfer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset buffer &nbsp; &nbsp; &nbsp; ; address for reads
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and writes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp;next: &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; process next record
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,14h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; sequential read from
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset fcb1 &nbsp; &nbsp; &nbsp; &nbsp; ; input file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; al,01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; check for end of file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; je &nbsp; &nbsp;file_end &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if end of file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; al,03
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; je &nbsp; &nbsp;file_end &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if end of file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; other read fault?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; bad_read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if bad read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,15h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; sequential write to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset fcb2 &nbsp; &nbsp; &nbsp; &nbsp; ; output file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write successful?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; bad_write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if write failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp &nbsp; next &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; process next record
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp;file_end: &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; reached end of input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; close input file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset fcb1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; close output file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset fcb2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; exit with return
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; code of zero
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp;fname1 &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;'OLDFILE.DAT',0 &nbsp; &nbsp; &nbsp; &nbsp;; name of input file
<br>
&nbsp;fname2 &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;'NEWFILE.DAT',0 &nbsp; &nbsp; &nbsp; &nbsp;; name of output file
<br>
&nbsp;fcb1 &nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;37 dup (0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; FCB for input file
<br>
&nbsp;fcb2 &nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;37 dup (0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; FCB for output file
<br>
&nbsp;buffer &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;recsize dup (?) &nbsp; &nbsp; &nbsp; &nbsp;; buffer for file I/O
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 8-4. &nbsp;Skeleton of an assembly-language program that performs file
<br>
&nbsp;and record I/O using the FCB family of functions.
<br>
<br>
&nbsp;Byte Offset &nbsp;FCB before open &nbsp; &nbsp; &nbsp; FCB contents &nbsp; &nbsp; &nbsp; FCB after open
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ┌────────────────────┬────────────────────┬────────────────────┐
<br>
&nbsp; &nbsp; &nbsp; 00H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; Drive &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 03 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────┼────────────────────┼────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; 01H │ &nbsp; &nbsp; &nbsp; &nbsp; 4D &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 4D &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 02H │ &nbsp; &nbsp; &nbsp; &nbsp; 59 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 59 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 03H │ &nbsp; &nbsp; &nbsp; &nbsp; 46 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 46 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 04H │ &nbsp; &nbsp; &nbsp; &nbsp; 49 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp;Filename &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 49 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 05H │ &nbsp; &nbsp; &nbsp; &nbsp; 4C &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 4C &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 06H │ &nbsp; &nbsp; &nbsp; &nbsp; 45 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 45 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 07H │ &nbsp; &nbsp; &nbsp; &nbsp; 20 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 20 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 08H │ &nbsp; &nbsp; &nbsp; &nbsp; 20 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 20 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────┼────────────────────┼────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; 09H │ &nbsp; &nbsp; &nbsp; &nbsp; 44 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 44 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 0AH │ &nbsp; &nbsp; &nbsp; &nbsp; 41 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; Extension &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 41 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 0BH │ &nbsp; &nbsp; &nbsp; &nbsp; 54 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 54 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────┼────────────────────┼────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; 0CH │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 0DH │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; Current block &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────┼────────────────────┼────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; 0EH │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 80 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 0FH │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp;Record size &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────┼────────────────────┼────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; 10H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 80 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 11H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 3D &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 12H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; File size &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 13H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────┼────────────────────┼────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; 14H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 43 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 15H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; File date &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 0B &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────┼────────────────────┼────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; 16H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; A1 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 17H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; File time &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 52 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────┼────────────────────┼────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; 18H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 03 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 19H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 02 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 1AH │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 42 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 1BH │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 73 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 1CH │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp;Reserved &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 1DH │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 01 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 1EH │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 35 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 1FH │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 0F &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────┼────────────────────┼────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; 20H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; Current record &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ├────────────────────┼────────────────────┼────────────────────┤
<br>
&nbsp; &nbsp; &nbsp; 21H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 22H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp;Relative-record &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 23H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; number &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; 24H │ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; 00 &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; └────────────────────┴────────────────────┴────────────────────┘
<br>
<br>
&nbsp;Figure 8-5. &nbsp;A typical file control block before and after a successful
<br>
&nbsp;open call (Int 21H Function 0FH).
<br>
<br>
Points to Remember
<br>
<br>
&nbsp;Here is a summary of the pros and cons of using the FCB-related file and
<br>
&nbsp;record functions in your programs.
<br>
<br>
&nbsp;Advantages:
<br>
<br>
&nbsp;■ &nbsp;Under MS-DOS versions 1 and 2, the number of files that can be open
<br>
&nbsp; &nbsp; concurrently when using FCBs is unlimited. (This is not true under
<br>
&nbsp; &nbsp; MS-DOS versions 3.0 and later, especially if networking software is
<br>
&nbsp; &nbsp; running.)
<br>
<br>
&nbsp;■ &nbsp;File-access methods using FCBs are familiar to programmers with a CP/M
<br>
&nbsp; &nbsp; background, and well-behaved CP/M applications require little change in
<br>
&nbsp; &nbsp; logical flow to run under MS-DOS.
<br>
<br>
&nbsp;■ &nbsp;MS-DOS supplies the size, time, and date for a file to its FCB after
<br>
&nbsp; &nbsp; the file is opened. The calling program can inspect this information.
<br>
<br>
&nbsp;Disadvantages:
<br>
<br>
&nbsp;■ &nbsp;FCBs take up room in the application program's memory space.
<br>
<br>
&nbsp;■ &nbsp;FCBs offer no support for the hierarchical file structure (no access to
<br>
&nbsp; &nbsp; files outside the current directory).
<br>
<br>
&nbsp;■ &nbsp;FCBs provide no support for file locking/sharing or record locking in
<br>
&nbsp; &nbsp; networking environments.
<br>
<br>
&nbsp;■ &nbsp;In addition to the read or write call itself, file reads or writes
<br>
&nbsp; &nbsp; using FCBs require manipulation of the FCB to set record size and
<br>
&nbsp; &nbsp; record number, plus a previous call to a separate MS-DOS function to
<br>
&nbsp; &nbsp; set the DTA address.
<br>
<br>
&nbsp;■ &nbsp;Random record I/O using FCBs for a file containing variable-length
<br>
&nbsp; &nbsp; records is very clumsy and inconvenient.
<br>
<br>
&nbsp;■ &nbsp;You must use extended FCBs, which are incompatible with CP/M anyway, to
<br>
&nbsp; &nbsp; access or create files with special attributes such as hidden,
<br>
&nbsp; &nbsp; read-only, or system.
<br>
<br>
&nbsp;■ &nbsp;The FCB file functions have poor error reporting. This situation has
<br>
&nbsp; &nbsp; been improved somewhat in MS-DOS version 3 because a program can call
<br>
&nbsp; &nbsp; the added Int 21H Function 59H (Get Extended Error Information) after
<br>
&nbsp; &nbsp; a failed FCB function to obtain additional information.
<br>
<br>
&nbsp;■ &nbsp;Microsoft discourages use of FCBs. FCBs will make your program more
<br>
&nbsp; &nbsp; difficult to port to MS OS/2 later because MS OS/2 does not support
<br>
&nbsp; &nbsp; FCBs in protected mode at all.
<br>
<br>
<br>
Using the Handle Functions
<br>
<br>
&nbsp;The handle file- and record-management functions access files in a fashion
<br>
&nbsp;similar to that used under the UNIX/XENIX operating system. Files are
<br>
&nbsp;designated by an ASCIIZ string (an ASCII character string terminated by a
<br>
&nbsp;null, or zero, byte) that can contain a drive designator, path, filename,
<br>
&nbsp;and extension. For example, the file specification
<br>
<br>
&nbsp;C:\SYSTEM\COMMAND.COM
<br>
<br>
&nbsp;would appear in memory as the following sequence of bytes:
<br>
<br>
&nbsp;43 3A 5C 53 59 53 54 45 4D 5C 43 4F 4D 4D 41 4E 44 2E 43 4F 4D 00
<br>
<br>
&nbsp;When a program wishes to open or create a file, it passes the address of
<br>
&nbsp;the ASCIIZ string specifying the file to MS-DOS in the DS:DX registers
<br>
&nbsp;(Figure 8-6). If the operation is successful, MS-DOS returns a 16-bit
<br>
&nbsp;handle to the program in the AX register. The program must save this
<br>
&nbsp;handle for further reference.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,3dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 3dh = open
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; al,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; mode 2 = read/write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,seg filename &nbsp; &nbsp; &nbsp; &nbsp; ; address of ASCIIZ
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ds,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file specification
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; request open from DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jc &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if open failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; handle,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp;filename &nbsp; &nbsp; db &nbsp; &nbsp;'C:\MYDIR\MYFILE.DAT',0 ; filename
<br>
&nbsp;handle &nbsp; &nbsp; &nbsp; dw &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file handle
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 8-6. &nbsp;A typical handle file operation. This sequence of code
<br>
&nbsp;attempts to open the file designated in the ASCIIZ string whose address is
<br>
&nbsp;passed to MS-DOS in the DS:DX registers.
<br>
<br>
&nbsp;When the program requests subsequent operations on the file, it usually
<br>
&nbsp;places the handle in the BX register before the call to MS-DOS. All the
<br>
&nbsp;handle functions return with the CPU's carry flag cleared if the operation
<br>
&nbsp;was successful, or set if the operation failed; in the latter case, the AX
<br>
&nbsp;register contains a code describing the failure.
<br>
<br>
&nbsp;MS-DOS restricts the number of handles that can be active at any one
<br>
&nbsp;time──that is, the number of files and devices that can be open
<br>
&nbsp;concurrently when using the handle family of functions──in two different
<br>
&nbsp;ways:
<br>
<br>
&nbsp;■ &nbsp;The maximum number of concurrently open files in the system, for all
<br>
&nbsp; &nbsp; active processes combined, is specified by the entry
<br>
<br>
&nbsp; &nbsp; FILES=nn
<br>
<br>
&nbsp; &nbsp; in the CONFIG.SYS file. This entry determines the number of entries
<br>
&nbsp; &nbsp; to be allocated in the system file table; under MS-DOS version 3, the
<br>
&nbsp; &nbsp; default value is 8 and the maximum is 255. After MS-DOS is booted and
<br>
&nbsp; &nbsp; running, you cannot expand this table to increase the total number of
<br>
&nbsp; &nbsp; files that can be open. You must use an editor to modify the CONFIG.SYS
<br>
&nbsp; &nbsp; file and then restart the system.
<br>
<br>
&nbsp;■ &nbsp;The maximum number of concurrently open files for a single process is
<br>
&nbsp; &nbsp; 20, assuming that sufficient entries are also available in the system
<br>
&nbsp; &nbsp; file table. When a program is loaded, MS-DOS preassigns 5 of its
<br>
&nbsp; &nbsp; potential 20 handles to the standard devices. Each time the process
<br>
&nbsp; &nbsp; issues an open or create call, MS-DOS assigns a handle from the
<br>
&nbsp; &nbsp; process's private allocation of 20, until all the handles are used up
<br>
&nbsp; &nbsp; or the system file table is full. In MS-DOS versions 3.3 and later, you
<br>
&nbsp; &nbsp; can expand the per-process limit of 20 handles with a call to Int 21H
<br>
&nbsp; &nbsp; Function 67H (Set Handle Count).
<br>
<br>
&nbsp;The handle file- and record-management calls may be gathered into the
<br>
&nbsp;following broad classifications for study:
<br>
<br>
<br>
&nbsp;Function &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Common handle file operations
<br>
&nbsp;3CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Create file (requires ASCIIZ string).
<br>
&nbsp;3DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Open file (requires ASCIIZ string).
<br>
&nbsp;3EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Close file.
<br>
<br>
&nbsp;Common handle record operations
<br>
&nbsp;42H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set file pointer (also used to find file size).
<br>
&nbsp;3FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read file.
<br>
&nbsp;40H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write file.
<br>
<br>
&nbsp;Less commonly used handle operations
<br>
&nbsp;41H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Delete file.
<br>
&nbsp;43H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get or modify file attributes.
<br>
&nbsp;44H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOCTL (I/O Control).
<br>
&nbsp;45H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Duplicate handle.
<br>
&nbsp;46H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Redirect handle.
<br>
&nbsp;56H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rename file.
<br>
&nbsp;57H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get or set file date and time.
<br>
&nbsp;5AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Create temporary file (versions 3.0 and later).
<br>
&nbsp;5BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Create file (fails if file already exists;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; versions 3.0 and later).
<br>
&nbsp;5CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lock or unlock file region (versions 3.0 and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; later).
<br>
&nbsp;67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set handle count (versions 3.3 and later).
<br>
&nbsp;68H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Commit file (versions 3.3 and later).
<br>
&nbsp;6CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Extended open file (version 4).
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Compare the groups of handle-type functions in the preceding table with
<br>
&nbsp;the groups of FCB functions outlined earlier, noting the degree of
<br>
&nbsp;functional overlap. Section 2 of this book, &quot;MS-DOS Functions Reference,&quot;
<br>
&nbsp;gives detailed specifications for each of the handle functions, along with
<br>
&nbsp;assembly-language examples.
<br>
<br>
Handle File-Access Skeleton
<br>
<br>
&nbsp;The following is a typical program sequence to access a file using the
<br>
&nbsp;handle family of functions (Figure 8-7):
<br>
<br>
&nbsp;1. &nbsp;Get the filename from the user by means of the buffered input service
<br>
&nbsp; &nbsp; &nbsp;(Int 21H Function 0AH) or from the command tail supplied by MS-DOS in
<br>
&nbsp; &nbsp; &nbsp;the PSP.
<br>
<br>
&nbsp;2. &nbsp;Put a zero at the end of the file specification in order to create an
<br>
&nbsp; &nbsp; &nbsp;ASCIIZ string.
<br>
<br>
&nbsp;3. &nbsp;Open the file using Int 21H Function 3DH and mode 2 (read/write
<br>
&nbsp; &nbsp; &nbsp;access), or create the file using Int 21H Function 3CH. (Be sure to
<br>
&nbsp; &nbsp; &nbsp;set the CX register to zero, so that you don't accidentally make a
<br>
&nbsp; &nbsp; &nbsp;file with special attributes.) Save the handle that is returned.
<br>
<br>
&nbsp;4. &nbsp;Set the file pointer using Int 21H Function 42H. You may set the
<br>
&nbsp; &nbsp; &nbsp;file-pointer position relative to one of three different locations:
<br>
&nbsp; &nbsp; &nbsp;the start of the file, the current pointer position, or the end of the
<br>
&nbsp; &nbsp; &nbsp;file. If you are performing sequential record I/O, you can usually
<br>
&nbsp; &nbsp; &nbsp;skip this step because MS-DOS will maintain the file pointer for you
<br>
&nbsp; &nbsp; &nbsp;automatically.
<br>
<br>
&nbsp;5. &nbsp;Read from the file (Int 21H Function 3FH) or write to the file (Int
<br>
&nbsp; &nbsp; &nbsp;21H Function 40H). Both of these functions require that the BX
<br>
&nbsp; &nbsp; &nbsp;register contain the file's handle, the CX register contain the length
<br>
&nbsp; &nbsp; &nbsp;of the record, and the DS:DX registers point to the data being
<br>
&nbsp; &nbsp; &nbsp;transferred. Both return the actual number of bytes transferred in the
<br>
&nbsp; &nbsp; &nbsp;AX register.
<br>
<br>
&nbsp; &nbsp; &nbsp;In a read operation, if the number of bytes read is less than the
<br>
&nbsp; &nbsp; &nbsp;number requested, the end of the file has been reached. In a write
<br>
&nbsp; &nbsp; &nbsp;operation, if the number of bytes written is less than the number
<br>
&nbsp; &nbsp; &nbsp;requested, the disk containing the file is full. Neither of these
<br>
&nbsp; &nbsp; &nbsp;conditions is returned as an error code; that is, the carry flag is
<br>
&nbsp; &nbsp; &nbsp;not set.
<br>
<br>
&nbsp;6. &nbsp;If the program is not finished processing the file, go to step 4;
<br>
&nbsp; &nbsp; &nbsp;otherwise, close the file (Int 21H Function 3EH). Any normal exit
<br>
&nbsp; &nbsp; &nbsp;from the program will also close all active handles.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;recsize &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 1024 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,3dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; open input file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; mode = read only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset fname1 &nbsp; &nbsp; &nbsp; ; name of input file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jc &nbsp; &nbsp;no_file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if no file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; handle1,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save token for file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,3ch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; create output file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; cx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; attribute = normal
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset fname2 &nbsp; &nbsp; &nbsp; ; name of output file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jc &nbsp; &nbsp;disk_full &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if create fails
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; handle2,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save token for file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp;next: &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; process next record
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,3fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; sequential read from
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; bx,handle1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; input file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; cx,recsize
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jc &nbsp; &nbsp;bad_read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if read error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or &nbsp; &nbsp;ax,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; check bytes transferred
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jz &nbsp; &nbsp;file_end &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if end of file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; sequential write to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; bx,handle2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; output file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; cx,recsize
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; dx,offset buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jc &nbsp; &nbsp;bad_write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if write error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; ax,recsize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; whole record written?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jne &nbsp; disk_full &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if disk is full
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp &nbsp; next &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; process next record
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp;file_end: &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; reached end of input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,3eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; close input file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; bx,handle1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ah,3eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; close output file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; bx,handle2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; exit with return
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; code of zero
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp;fname1 &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;'OLDFILE.DAT',0 &nbsp; &nbsp; &nbsp; &nbsp;; name of input file
<br>
&nbsp;fname2 &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;'NEWFILE.DAT',0 &nbsp; &nbsp; &nbsp; &nbsp;; name of output file
<br>
&nbsp;handle1 &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; token for input file
<br>
&nbsp;handle2 &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; token for output file
<br>
&nbsp;buffer &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;recsize dup (?) &nbsp; &nbsp; &nbsp; &nbsp;; buffer for file I/O
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 8-7. &nbsp;Skeleton of an assembly-language program that performs
<br>
&nbsp;sequential processing on an input file and writes the results to an output
<br>
&nbsp;file using the handle file and record functions. This code assumes that
<br>
&nbsp;the DS and ES registers have already been set to point to the segment
<br>
&nbsp;containing the buffers and filenames.
<br>
<br>
Points to Remember
<br>
<br>
&nbsp;Here is a summary of the pros and cons of using the handle file and record
<br>
&nbsp;operations in your program. Compare this list with the one given earlier
<br>
&nbsp;in the chapter for the FCB family of functions.
<br>
<br>
&nbsp;Advantages:
<br>
<br>
&nbsp;■ &nbsp;The handle calls provide direct support for I/O redirection and pipes
<br>
&nbsp; &nbsp; with the standard input and output devices in a manner functionally
<br>
&nbsp; &nbsp; similar to that used by UNIX/XENIX.
<br>
<br>
&nbsp;■ &nbsp;The handle functions provide direct support for directories (the
<br>
&nbsp; &nbsp; hierarchical file structure) and special file attributes.
<br>
<br>
&nbsp;■ &nbsp;The handle calls support file sharing/locking and record locking in
<br>
&nbsp; &nbsp; networking environments.
<br>
<br>
&nbsp;■ &nbsp;Using the handle functions, the programmer can open channels to
<br>
&nbsp; &nbsp; character devices and treat them as files.
<br>
<br>
&nbsp;■ &nbsp;The handle calls make the use of random record access extremely easy.
<br>
&nbsp; &nbsp; The current file pointer can be moved to any byte offset relative to
<br>
&nbsp; &nbsp; the start of the file, the end of the file, or the current pointer
<br>
&nbsp; &nbsp; position. Records of any length, up to an entire segment (65,535
<br>
&nbsp; &nbsp; bytes), can be read to any memory address in one operation.
<br>
<br>
&nbsp;■ &nbsp;The handle functions have relatively good error reporting in MS-DOS
<br>
&nbsp; &nbsp; version 2, and error reporting has been enhanced even further in MS-DOS
<br>
&nbsp; &nbsp; versions 3.0 and later.
<br>
<br>
&nbsp;■ &nbsp;Microsoft strongly encourages use of the handle family of functions in
<br>
&nbsp; &nbsp; order to provide upward compatibility with MS OS/2.
<br>
<br>
&nbsp;Disadvantages:
<br>
<br>
&nbsp;■ &nbsp;There is a limit per program of 20 concurrently open files and devices
<br>
&nbsp; &nbsp; using handles in MS-DOS versions 2.0 through 3.2.
<br>
<br>
&nbsp;■ &nbsp;Minor gaps still exist in the implementation of the handle functions.
<br>
&nbsp; &nbsp; For example, you must still use extended FCBs to change volume labels
<br>
&nbsp; &nbsp; and to access the contents of the special files that implement
<br>
&nbsp; &nbsp; directories.
<br>
<br>
<br>
MS-DOS Error Codes
<br>
<br>
&nbsp;When one of the handle file functions fails with the carry flag set, or
<br>
&nbsp;when a program calls Int 21H Function 59H (Get Extended Error
<br>
&nbsp;Information) following a failed FCB function or other system service, one
<br>
&nbsp;of the following error codes may be returned:
<br>
<br>
<br>
&nbsp;Value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;MS-DOS version 2 error codes
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Function number invalid
<br>
&nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;File not found
<br>
&nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Path not found
<br>
&nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Too many open files
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Access denied
<br>
&nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Handle invalid
<br>
&nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Memory control blocks destroyed
<br>
&nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Insufficient memory
<br>
&nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Memory block address invalid
<br>
&nbsp;0AH (10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Environment invalid
<br>
&nbsp;0BH (11) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Format invalid
<br>
&nbsp;0CH (12) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Access code invalid
<br>
&nbsp;0DH (13) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Data invalid
<br>
&nbsp;0EH (14) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unknown unit
<br>
&nbsp;0FH (15) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Disk drive invalid
<br>
&nbsp;10H (16) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Attempted to remove current directory
<br>
&nbsp;11H (17) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Not same device
<br>
&nbsp;12H (18) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; No more files
<br>
<br>
&nbsp;Mappings to critical-error codes
<br>
&nbsp;13H (19) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-protected disk
<br>
&nbsp;14H (20) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unknown unit
<br>
&nbsp;15H (21) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Drive not ready
<br>
&nbsp;16H (22) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unknown command
<br>
&nbsp;17H (23) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Data error (CRC)
<br>
&nbsp;18H (24) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bad request-structure length
<br>
&nbsp;19H (25) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Seek error
<br>
&nbsp;1AH (26) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unknown media type
<br>
&nbsp;1BH (27) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sector not found
<br>
&nbsp;1CH (28) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Printer out of paper
<br>
&nbsp;1DH (29) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write fault
<br>
&nbsp;1EH (30) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read fault
<br>
&nbsp;1FH (31) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; General failure
<br>
<br>
&nbsp;MS-DOS version 3 and later extended error codes
<br>
&nbsp;20H (32) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sharing violation
<br>
&nbsp;21H (33) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; File-lock violation
<br>
&nbsp;22H (34) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Disk change invalid
<br>
&nbsp;23H (35) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FCB unavailable
<br>
&nbsp;24H (36) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sharing buffer exceeded
<br>
&nbsp;25H─31H (37─49) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved
<br>
&nbsp;32H (50) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unsupported network request
<br>
&nbsp;33H (51) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remote machine not listening
<br>
&nbsp;34H (52) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Duplicate name on network
<br>
&nbsp;35H (53) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Network name not found
<br>
&nbsp;36H (54) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Network busy
<br>
&nbsp;37H (55) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Device no longer exists on network
<br>
&nbsp;38H (56) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NetBIOS command limit exceeded
<br>
&nbsp;39H (57) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Error in network adapter hardware
<br>
&nbsp;3AH (58) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Incorrect response from network
<br>
&nbsp;3BH (59) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unexpected network error
<br>
&nbsp;3CH (60) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remote adapter incompatible
<br>
&nbsp;3DH (61) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Print queue full
<br>
&nbsp;3EH (62) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Not enough room for print file
<br>
&nbsp;3FH (63) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Print file was deleted
<br>
&nbsp;40H (64) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Network name deleted
<br>
&nbsp;41H (65) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Network access denied
<br>
&nbsp;42H (66) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Incorrect network device type
<br>
&nbsp;43H (67) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Network name not found
<br>
&nbsp;44H (68) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Network name limit exceeded
<br>
&nbsp;45H (69) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NetBIOS session limit exceeded
<br>
&nbsp;46H (70) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Temporary pause
<br>
&nbsp;47H (71) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Network request not accepted
<br>
&nbsp;48H (72) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Print or disk redirection paused
<br>
&nbsp;49H─4FH (73─79) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved
<br>
&nbsp;50H (80) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; File already exists
<br>
&nbsp;51H (81) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved
<br>
&nbsp;52H (82) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cannot make directory
<br>
&nbsp;53H (83) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Fail on Int 24H (critical error)
<br>
&nbsp;54H (84) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Too many redirections
<br>
&nbsp;55H (85) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Duplicate redirection
<br>
&nbsp;56H (86) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invalid password
<br>
&nbsp;57H (87) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invalid parameter
<br>
&nbsp;58H (88) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Net write fault
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Under MS-DOS versions 3.0 and later, you can also use Int 21H Function
<br>
&nbsp;59H to obtain other information about the error, such as the error locus
<br>
&nbsp;and the recommended recovery action.
<br>
<br>
Critical-Error Handlers
<br>
<br>
&nbsp;In Chapter 5, we discussed how an application program can take over the
<br>
&nbsp;Ctrl-C handler vector (Int 23H) and replace the MS-DOS default handler, to
<br>
&nbsp;avoid losing control of the computer when the user enters a Ctrl-C or
<br>
&nbsp;Ctrl-Break at the keyboard. Similarly, MS-DOS provides a
<br>
&nbsp;critical-error-handler vector (Int 24H) that defines the routine to be
<br>
&nbsp;called when unrecoverable hardware faults occur. The default MS-DOS
<br>
&nbsp;critical-error handler is the routine that displays a message describing
<br>
&nbsp;the error type and the cue
<br>
<br>
&nbsp;Abort, Retry, Ignore?
<br>
<br>
&nbsp;This message appears after such actions as the following:
<br>
<br>
&nbsp;■ &nbsp;Attempting to open a file on a disk drive that doesn't contain a floppy
<br>
&nbsp; &nbsp; disk or whose door isn't closed
<br>
<br>
&nbsp;■ &nbsp;Trying to read a disk sector that contains a CRC error
<br>
<br>
&nbsp;■ &nbsp;Trying to print when the printer is off line
<br>
<br>
&nbsp;The unpleasant thing about MS-DOS's default critical-error handler is, of
<br>
&nbsp;course, that if the user enters an A for Abort, the application that is
<br>
&nbsp;currently executing is terminated abruptly and never has a chance to clean
<br>
&nbsp;up and make a graceful exit. Intermediate files may be left on the disk,
<br>
&nbsp;files that have been extended using FCBs are not properly closed so that
<br>
&nbsp;the directory is updated, interrupt vectors may be left pointing into the
<br>
&nbsp;transient program area, and so forth.
<br>
<br>
&nbsp;To write a truly bombproof MS-DOS application, you must take over the
<br>
&nbsp;critical-error-handler vector and point it to your own routine, so that
<br>
&nbsp;your program intercepts all catastrophic hardware errors and handles them
<br>
&nbsp;appropriately. You can use MS-DOS Int 21H Function 25H to alter the Int
<br>
&nbsp;24H vector in a well-behaved manner. When your application exits, MS-DOS
<br>
&nbsp;will automatically restore the previous contents of the Int 24H vector
<br>
&nbsp;from information saved in the program segment prefix.
<br>
<br>
&nbsp;MS-DOS calls the critical-error handler for two general classes of
<br>
&nbsp;errors── disk-related and non-disk-related──and passes different
<br>
&nbsp;information to the handler in the registers for each of these classes.
<br>
<br>
&nbsp;For disk-related errors, MS-DOS sets the registers as shown on the
<br>
&nbsp;following page. (Bits 3─5 of the AH register are relevant only in MS-DOS
<br>
&nbsp;versions 3.1 and later.)
<br>
<br>
<br>
&nbsp;Register &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bit(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0, to signify disk error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 = ignore response not allowed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 = ignore response allowed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 = retry response not allowed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 = retry response allowed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 = fail response not allowed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 = fail response allowed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1─2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Area where disk error occurred
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 00 = MS-DOS area
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 01 = file allocation table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10 = root directory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 = files area
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 = read operation
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 = write operation
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Drive code (0 = A, 1 = B, and so
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forth)
<br>
&nbsp;DI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Driver error code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8─15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Not used
<br>
&nbsp;BP:SI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Segment:offset of device-driver
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;For non-disk-related errors, the interrupt was generated either as the
<br>
&nbsp;result of a character-device error or because a corrupted memory image of
<br>
&nbsp;the file allocation table was detected. In this case, MS-DOS sets the
<br>
&nbsp;registers as follows:
<br>
<br>
&nbsp;Register &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bit(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1, to signify a non-disk error
<br>
&nbsp;DI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Driver error code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8─15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Not used
<br>
&nbsp;BP:SI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Segment:offset of device-driver
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;To determine whether the critical error was caused by a character device,
<br>
&nbsp;use the address in the BP:SI registers to examine the device attribute
<br>
&nbsp;word at offset 0004H in the presumed device-driver header. If bit 15 is
<br>
&nbsp;set, then the error was indeed caused by a character device, and the
<br>
&nbsp;program can inspect the name field of the driver's header to determine the
<br>
&nbsp;device.
<br>
<br>
&nbsp;At entry to a critical-error handler, MS-DOS has already disabled
<br>
&nbsp;interrupts and set up the stack as shown in Figure 8-8. A critical-error
<br>
&nbsp;handler cannot use any MS-DOS services except Int 21H Functions 01H
<br>
&nbsp;through 0CH (Traditional Character I/O), Int 21H Function 30H (Get MS-DOS
<br>
&nbsp;Version), and Int 21H Function 59H (Get Extended Error Information).
<br>
&nbsp;These functions use a special stack so that the context of the original
<br>
&nbsp;function (which generated the critical error) will not be lost.
<br>
<br>
&nbsp;┌───────┐─┐
<br>
&nbsp;│ Flags │ │
<br>
&nbsp;├───────┤ │ &nbsp;Flags and CS:IP pushed
<br>
&nbsp;│ &nbsp;CS &nbsp; │ ├─ on stack by original
<br>
&nbsp;├───────┤ │ &nbsp;Int 21H call
<br>
&nbsp;│ &nbsp;IP &nbsp; │ │
<br>
&nbsp;├───────┤═╡─SS:SP on entry to
<br>
&nbsp;│ &nbsp;ES &nbsp; │ │ &nbsp;Int 21H handler
<br>
&nbsp;├───────┤ │
<br>
&nbsp;│ &nbsp;DS &nbsp; │ │
<br>
&nbsp;├───────┤ │
<br>
&nbsp;│ &nbsp;BP &nbsp; │ │
<br>
&nbsp;├───────┤ │
<br>
&nbsp;│ &nbsp;DI &nbsp; │ │
<br>
&nbsp;├───────┤ ├─ Registers at point of
<br>
&nbsp;│ &nbsp;SI &nbsp; │ │ &nbsp;original Int 21H call
<br>
&nbsp;├───────┤ │
<br>
&nbsp;│ &nbsp;DX &nbsp; │ │
<br>
&nbsp;├───────┤ │
<br>
&nbsp;│ &nbsp;CX &nbsp; │ │
<br>
&nbsp;├───────┤ │
<br>
&nbsp;│ &nbsp;BX &nbsp; │ │
<br>
&nbsp;├───────┤ │
<br>
&nbsp;│ &nbsp;AX &nbsp; │ │
<br>
&nbsp;├───────┤═╡
<br>
&nbsp;│ Flags │ │
<br>
&nbsp;├───────┤ │
<br>
&nbsp;│ &nbsp;CS &nbsp; │ ├─ Return address for
<br>
&nbsp;├───────┤ │ &nbsp;Int 24H handler
<br>
&nbsp;│ &nbsp;IP &nbsp; │ │
<br>
&nbsp;└──────┘─┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp;└───── SS:SP on entry to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int 24H handler
<br>
<br>
&nbsp;Figure 8-8. &nbsp;The stack at entry to a critical-error handler.
<br>
<br>
&nbsp;The critical-error handler should return to MS-DOS by executing an IRET,
<br>
&nbsp;passing one of the following action codes in the AL register:
<br>
<br>
&nbsp;Code &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Ignore the error (MS-DOS acts as though the original
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function call had succeeded).
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Retry the operation.
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Terminate the process that encountered the error.
<br>
&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Fail the function (an error code is returned to the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; requesting process). Versions 3.1 and later only.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The critical-error handler should preserve all other registers and must
<br>
&nbsp;not modify the device-driver header pointed to by BP:SI. A skeleton
<br>
&nbsp;example of a critical-error handler is shown in Figure 8-9.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; prompt message used by
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; critical-error handler
<br>
&nbsp;prompt &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf,'Critical Error Occurred: '
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Abort, Retry, Ignore, Fail? $'
<br>
<br>
&nbsp;keys &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'aArRiIfF' &nbsp; &nbsp; &nbsp;; possible user response keys
<br>
&nbsp;keys_len equ $-keys &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (both cases of each allowed)
<br>
<br>
&nbsp;codes &nbsp; db &nbsp; &nbsp; &nbsp;2,2,1,1,0,0,3,3 ; codes returned to MS-DOS kernel
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; for corresponding response keys
<br>
<br>
&nbsp;;
<br>
&nbsp;; This code is executed during program's initialization
<br>
&nbsp;; to install the new critical-error handler.
<br>
&nbsp;;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save our data segment
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg int24 &nbsp; &nbsp;; DS:DX = handler address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset int24
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,2524h &nbsp; &nbsp; &nbsp; &nbsp;; function 25h = set vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;;
<br>
&nbsp;; This is the replacement critical-error handler. It
<br>
&nbsp;; prompts the user for Abort, Retry, Ignore, or Fail, and
<br>
&nbsp;; returns the appropriate code to the MS-DOS kernel.
<br>
&nbsp;;
<br>
<br>
&nbsp;int24 &nbsp; proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; entered from MS-DOS kernel
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bp
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;es
<br>
&nbsp;int24a: mov &nbsp; &nbsp; ax,seg prompt &nbsp; ; display prompt for user
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; using function 9 (print string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; terminated by $ character)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset prompt
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,9
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get user's response
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; function 1 = read one character
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset keys &nbsp;; look up code for response key
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,keys_len
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cld
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;repne scasb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; int24a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; prompt again if bad response
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set AL = action code for MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; according to key that was entered:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 0 = ignore, 1 = retry, 2 = abort,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 3 = fail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,[di+keys_len-1]
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; es &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bp
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; exit critical-error handler
<br>
<br>
&nbsp;int24 &nbsp; endp
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 8-9. &nbsp;A skeleton example of a replacement critical-error handler.
<br>
<br>
<br>
Example Programs: DUMP.ASM and DUMP.C
<br>
<br>
&nbsp;The programs DUMP.ASM (Figure 8-10) and DUMP.C (Figure 8-11) are
<br>
&nbsp;parallel examples of the use of the handle file and record functions. The
<br>
&nbsp;assembly-language version, in particular, illustrates features of a
<br>
&nbsp;well-behaved MS-DOS utility:
<br>
<br>
&nbsp;■ &nbsp;The program checks the version of MS-DOS to ensure that all the
<br>
&nbsp; &nbsp; functions it is going to use are really available.
<br>
<br>
&nbsp;■ &nbsp;The program parses the drive, path, and filename from the command tail
<br>
&nbsp; &nbsp; in the program segment prefix.
<br>
<br>
&nbsp;■ &nbsp;The program uses buffered I/O for speed.
<br>
<br>
&nbsp;■ &nbsp;The program sends error messages to the standard error device.
<br>
<br>
&nbsp;■ &nbsp;The program sends normal program output to the standard output device,
<br>
&nbsp; &nbsp; so that the dump output appears by default on the system console but
<br>
&nbsp; &nbsp; can be redirected to other character devices (such as the line printer)
<br>
&nbsp; &nbsp; or to a file.
<br>
<br>
&nbsp;The same features are incorporated into the C version of the program, but
<br>
&nbsp;some of them are taken care of behind the scenes by the C runtime library.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;dump
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page &nbsp; &nbsp;55,132
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;title &nbsp; DUMP--display file contents
<br>
<br>
&nbsp;;
<br>
&nbsp;; &nbsp;DUMP--Display contents of file in hex and ASCII
<br>
&nbsp;;
<br>
&nbsp;; &nbsp;Build: &nbsp; C&gt;MASM DUMP;
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C&gt;LINK DUMP;
<br>
&nbsp;;
<br>
&nbsp;; &nbsp;Usage: &nbsp; C&gt;DUMP unit:\path\filename.exe [ &gt;device ]
<br>
&nbsp;;
<br>
&nbsp;; &nbsp;Copyright (C) 1988 Ray Duncan
<br>
&nbsp;;
<br>
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII line feed
<br>
&nbsp;tab &nbsp; &nbsp; equ &nbsp; &nbsp; 09h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII tab code
<br>
&nbsp;blank &nbsp; equ &nbsp; &nbsp; 20h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII space code
<br>
<br>
&nbsp;cmd &nbsp; &nbsp; equ &nbsp; &nbsp; 80h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; buffer for command tail
<br>
<br>
&nbsp;blksize equ &nbsp; &nbsp; 16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; input file record size
<br>
<br>
&nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard input handle
<br>
&nbsp;stdout &nbsp;equ &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp;stderr &nbsp;equ &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard error handle
<br>
&nbsp;_TEXT &nbsp; segment word public 'CODE'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assume &nbsp;cs:_TEXT,ds:_DATA,es:_DATA,ss:STACK
<br>
<br>
&nbsp;dump &nbsp; &nbsp;proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; entry point from MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save DS:0000 for final
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to MS-DOS, in case
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch can't be used
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp;; make our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; addressable via DS register
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; check MS-DOS version
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,3000h &nbsp; &nbsp; &nbsp; &nbsp;; function 30h = get version
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; major version 2 or later?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jae &nbsp; &nbsp; dump1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; yes, proceed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if MS-DOS 1.x, display
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; error message and exit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg3 &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 9 = print string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; then exit the old way
<br>
<br>
&nbsp;dump1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; check if filename present
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset cmd &nbsp; ; ES:BX = command tail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;argc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; count command arguments
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; are there 2 arguments?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;dump2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; yes, proceed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; missing filename, display
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; error message and exit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg2 &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg2_len &nbsp; &nbsp; ; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; dump9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; go display it
<br>
<br>
&nbsp;dump2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get address of filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AX = argument number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ES:BX still = command tail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;argv &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns ES:BX = address,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and AX = length
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset fname ; copy filename to buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; CX = length
<br>
&nbsp;dump3: &nbsp;mov &nbsp; &nbsp; al,es:[bx] &nbsp; &nbsp; &nbsp;; copy one byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; [di],al
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bump string pointers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop &nbsp; &nbsp;dump3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; loop until string done
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; byte ptr [di],0 ; add terminal null byte
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; make our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; addressable by ES too
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now open the file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,3d00h &nbsp; &nbsp; &nbsp; &nbsp;; function 3dh = open file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; mode 0 = read only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname ; DS:DX = filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnc &nbsp; &nbsp; dump4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, open successful
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; open failed, display
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; error message and exit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg1 &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg1_len &nbsp; &nbsp; ; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; dump9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; go display it
<br>
<br>
&nbsp;dump4: &nbsp;mov &nbsp; &nbsp; fhandle,ax &nbsp; &nbsp; &nbsp;; save file handle
<br>
<br>
&nbsp;dump5: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read block of file data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,fhandle &nbsp; &nbsp; &nbsp;; BX = file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,blksize &nbsp; &nbsp; &nbsp;; CX = record length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fbuff ; DS:DX = buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 3fh = read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; flen,ax &nbsp; &nbsp; &nbsp; &nbsp; ; save actual length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; end of file reached?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; dump6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, proceed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; word ptr fptr,0 ; was this the first read?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; dump8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, exit normally
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display empty file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; message and exit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg4 &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg4_len &nbsp; &nbsp; ; CX = length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; dump9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; go display it
<br>
&nbsp;dump6: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display heading at
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; each 128-byte boundary
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;test &nbsp; &nbsp;fptr,07fh &nbsp; &nbsp; &nbsp; ; time for a heading?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; dump7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, proceed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display a heading
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset hdg &nbsp; ; DS:DX = heading address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,hdg_len &nbsp; &nbsp; &nbsp;; CX = heading length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; BX = standard output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;dump7: &nbsp;call &nbsp; &nbsp;conv &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert binary record
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to formatted ASCII
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display formatted output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fout &nbsp;; DX:DX = output address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,fout_len &nbsp; &nbsp; ; CX = output length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; BX = standard output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; dump5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; go get another record
<br>
<br>
&nbsp;dump8: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; close input file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,fhandle &nbsp; &nbsp; &nbsp;; BX = file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 3eh = close
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch = terminate,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;dump9: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display message on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; standard error device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stderr &nbsp; &nbsp; &nbsp; ; standard error handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c01h &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch = terminate,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code = 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;dump &nbsp; &nbsp;endp
<br>
&nbsp;conv &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert block of data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; from input file
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset fout &nbsp;; clear output format
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,fout_len-2 &nbsp; ; area to blanks
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,blank
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rep stosb
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset fout &nbsp;; convert file offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,fptr &nbsp; &nbsp; &nbsp; &nbsp; ; to ASCII for output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;w2a
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; init buffer pointer
<br>
<br>
&nbsp;conv1: &nbsp;mov &nbsp; &nbsp; al,[fbuff+bx] &nbsp; ; fetch byte from buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset foutb ; point to output area
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; format ASCII part...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; store '.' as default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; byte ptr [di+bx],'.'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,blank &nbsp; &nbsp; &nbsp; &nbsp;; in range 20h-7eh?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jb &nbsp; &nbsp; &nbsp;conv2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, not alphanumeric
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,7eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; in range 20h-7eh?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ja &nbsp; &nbsp; &nbsp;conv2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, not alphanumeric
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; [di+bx],al &nbsp; &nbsp; &nbsp;; store ASCII character
<br>
<br>
&nbsp;conv2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; format hex part...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset fouta ; point to output area
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; di,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; base addr + (offset*3)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; di,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; di,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;b2a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; convert byte to hex
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; advance through record
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; bx,flen &nbsp; &nbsp; &nbsp; &nbsp; ; entire record converted?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; conv1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, get another byte
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; update file pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; word ptr fptr,blksize
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;conv &nbsp; &nbsp;endp
<br>
&nbsp;w2a &nbsp; &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert word to hex ASCII
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call with AX = value
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DI = addr for string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns AX, DI, CX destroyed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save copy of value
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,ah
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;b2a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; convert upper byte
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get back copy
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;b2a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; convert lower byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;w2a &nbsp; &nbsp; endp
<br>
<br>
&nbsp;b2a &nbsp; &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert byte to hex ASCII
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call with AL = binary value
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DI = addr for string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns &nbsp; AX, DI, CX modified
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub &nbsp; &nbsp; ah,ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; clear upper byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cl,16
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;div &nbsp; &nbsp; cl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; divide byte by 16
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;ascii &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; quotient becomes the first
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stosb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,ah
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;ascii &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; remainder becomes the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stosb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; second ASCII character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;b2a &nbsp; &nbsp; endp
<br>
<br>
&nbsp;ascii &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert value 0-0fh in AL
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; into &quot;hex ASCII&quot; character
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; al,'0' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; offset to range 0-9
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,'9' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; is it &gt; 9?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jle &nbsp; &nbsp; ascii2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; no, jump
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; al,'A'-'9'-1 &nbsp; &nbsp;; offset to range A-F,
<br>
<br>
&nbsp;ascii2: ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return AL = ASCII char
<br>
<br>
&nbsp;ascii &nbsp; endp
<br>
<br>
&nbsp;argc &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; count command-line arguments
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call with ES:BX = command line
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns &nbsp; AX = argument count
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save original BX and CX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; for later
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; force count &gt;= 1
<br>
<br>
&nbsp;argc1: &nbsp;mov &nbsp; &nbsp; cx,-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set flag = outside argument
<br>
<br>
&nbsp;argc2: &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; point to next character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr es:[bx],cr
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;argc3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; exit if carriage return
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr es:[bx],blank
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;argc1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; outside argument if ASCII blank
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr es:[bx],tab
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;argc1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; outside argument if ASCII tab
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; otherwise not blank or tab,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jcxz &nbsp; &nbsp;argc2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if already inside argument
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; else found argument, count it
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;not &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set flag = inside argument
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; argc2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and look at next character
<br>
<br>
&nbsp;argc3: &nbsp;pop &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore original BX and CX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return AX = argument count
<br>
<br>
&nbsp;argc &nbsp; &nbsp;endp
<br>
<br>
&nbsp;argv &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get address &amp; length of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; command line argument
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call with ES:BX = command line
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AX &nbsp; &nbsp;= argument #
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns &nbsp; ES:BX = address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AX &nbsp; &nbsp;= length
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save original CX and DI
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;di
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;ax,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is it argument 0?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;argv8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; yes, jump to get program name
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ah,ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; initialize argument counter
<br>
<br>
&nbsp;argv1: &nbsp;mov &nbsp; &nbsp; cx,-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set flag = outside argument
<br>
&nbsp;argv2: &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; point to next character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr es:[bx],cr
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;argv7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; exit if carriage return
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr es:[bx],blank
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;argv1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; outside argument if ASCII blank
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr es:[bx],tab
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;argv1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; outside argument if ASCII tab
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if not blank or tab...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jcxz &nbsp; &nbsp;argv2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if already inside argument
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; else count arguments found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ah,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is this the one we're looking for?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;argv4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; yes, go find its length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;not &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; no, set flag = inside argument
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; argv2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and look at next character
<br>
<br>
&nbsp;argv4: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; found desired argument, now
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; determine its length...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save param starting address
<br>
<br>
&nbsp;argv5: &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; point to next character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr es:[bx],cr
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;argv6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; found end if carriage return
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr es:[bx],blank
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;argv6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; found end if ASCII blank
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr es:[bx],tab
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; argv5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; found end if ASCII tab
<br>
<br>
&nbsp;argv6: &nbsp;xchg &nbsp; &nbsp;bx,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set ES:BX = argument address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub &nbsp; &nbsp; ax,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and AX = argument length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; argvx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to caller
<br>
<br>
&nbsp;argv7: &nbsp;xor &nbsp; &nbsp; ax,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set AX = 0, argument not found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; argvx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to caller
<br>
<br>
&nbsp;argv8: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; special handling for argv = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,3000h &nbsp; &nbsp; &nbsp; &nbsp;; check if DOS 3.0 or later
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (force AL = 0 in case DOS 1)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jb &nbsp; &nbsp; &nbsp;argv7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; DOS 1 or 2, return null param
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,es:[2ch] &nbsp; &nbsp; ; get environment segment from PSP
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; di,di &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; find the program name by
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; first skipping over all the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; environment variables...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cld
<br>
&nbsp;argv9: &nbsp;repne scasb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; scan for double null (can't use
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scasb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; SCASW since might be odd addr)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; argv9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; loop if it was a single null
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; di,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; skip count word in environment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,di &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save program name address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; now find its length...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;repne scasb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; scan for another null byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;not &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert CX to length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dec &nbsp; &nbsp; cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return length in AX
<br>
<br>
&nbsp;argvx: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; common exit point
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; di &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore original CX and DI
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to caller
<br>
<br>
&nbsp;argv &nbsp; &nbsp;endp
<br>
<br>
&nbsp;_TEXT &nbsp; &nbsp;ends
<br>
<br>
&nbsp;_DATA &nbsp; segment word public 'DATA'
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;64 dup (0) &nbsp; &nbsp; &nbsp;; buffer for input filespec
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; token from PCDOS for input file
<br>
<br>
&nbsp;flen &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; actual length read
<br>
<br>
&nbsp;fptr &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; relative address in file
<br>
<br>
&nbsp;fbuff &nbsp; db &nbsp; &nbsp; &nbsp;blksize dup (?) ; data from input file
<br>
<br>
&nbsp;fout &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'nnnn' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; formatted output area
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;blank,blank
<br>
&nbsp;fouta &nbsp; db &nbsp; &nbsp; &nbsp;16 dup ('nn',blank)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;blank
<br>
&nbsp;foutb &nbsp; db &nbsp; &nbsp; &nbsp;16 dup (blank),cr,lf
<br>
&nbsp;fout_len equ &nbsp; &nbsp;$-fout
<br>
<br>
&nbsp;hdg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;cr,lf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; heading for each 128 bytes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;7 dup (blank) &nbsp; ; of formatted output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'8 &nbsp;9 &nbsp;A &nbsp;B &nbsp;C &nbsp;D &nbsp;E &nbsp;F',cr,lf
<br>
&nbsp;hdg_len equ &nbsp; &nbsp; $-hdg
<br>
&nbsp;msg1 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'dump: file not found'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp;msg1_len equ &nbsp; &nbsp;$-msg1
<br>
<br>
&nbsp;msg2 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'dump: missing file name'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp;msg2_len equ &nbsp; &nbsp;$-msg2
<br>
<br>
&nbsp;msg3 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'dump: wrong MS-DOS version'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf,'$'
<br>
<br>
&nbsp;msg4 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'dump: empty file'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp;msg4_len equ &nbsp; &nbsp;$-msg4
<br>
<br>
&nbsp;_DATA &nbsp; ends
<br>
<br>
&nbsp;STACK &nbsp; segment para stack 'STACK'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;64 dup (?)
<br>
<br>
&nbsp;STACK &nbsp; ends
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end &nbsp; &nbsp; dump
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 8-10. &nbsp;The assembly-language version: DUMP.ASM.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;DUMP.C &nbsp; &nbsp; &nbsp;Displays the binary contents of a file in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hex and ASCII on the standard output device.
<br>
<br>
&nbsp; &nbsp; &nbsp;Compile: &nbsp; &nbsp;C&gt;CL DUMP.C
<br>
<br>
&nbsp; &nbsp; &nbsp;Usage: &nbsp; &nbsp; &nbsp;C&gt;DUMP unit:path\filename.ext
<br>
<br>
&nbsp; &nbsp; &nbsp;Copyright (C) 1988 Ray Duncan
<br>
&nbsp;*/
<br>
<br>
&nbsp;#include &lt;stdio.h&gt;
<br>
&nbsp;#include &lt;io.h&gt;
<br>
&nbsp;#include &lt;fcntl.h&gt;
<br>
&nbsp;#define REC_SIZE 16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* input file record size &nbsp; &nbsp;*/
<br>
<br>
&nbsp;main(int argc, char *argv[])
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;int fd; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* input file handle &nbsp; &nbsp; &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp; &nbsp;int status = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* status from file read &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;long fileptr = 0L; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* current file byte offset &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;char filebuf[REC_SIZE]; &nbsp; &nbsp; &nbsp; /* data from file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
<br>
&nbsp; &nbsp; &nbsp;if(argc != 2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* abort if missing filename */
<br>
&nbsp; &nbsp; &nbsp;{ &nbsp; fprintf(stderr,&quot;\ndump: wrong number of parameters\n&quot;);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit(1);
<br>
&nbsp; &nbsp; &nbsp;}
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* open file in binary mode,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abort if open fails &nbsp; &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;if((fd = open(argv[1],O_RDONLY | O_BINARY) ) == -1)
<br>
&nbsp; &nbsp; &nbsp;{ &nbsp; fprintf(stderr, &quot;\ndump: can't find file %s \n&quot;, argv[1]);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit(1);
<br>
&nbsp; &nbsp; &nbsp;}
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* read and dump records
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; until end of file &nbsp; &nbsp; &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;while((status = read(fd,filebuf,REC_SIZE) ) != 0)
<br>
&nbsp; &nbsp; &nbsp;{ &nbsp; dump_rec(filebuf, fileptr, status);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fileptr += REC_SIZE;
<br>
&nbsp; &nbsp; &nbsp;}
<br>
<br>
&nbsp; &nbsp; &nbsp;close(fd); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* close input file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;exit(0); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* return success code &nbsp; &nbsp; &nbsp; */
<br>
&nbsp;}
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;Display record (16 bytes) in hex and ASCII on standard output
<br>
&nbsp;*/
<br>
<br>
&nbsp;dump_rec(char *filebuf, long fileptr, int length)
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;int i; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* index to current record &nbsp; */
<br>
<br>
&nbsp; &nbsp; &nbsp;if(fileptr % 128 == 0) &nbsp; &nbsp; &nbsp; &nbsp;/* display heading if needed */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot;\n\n &nbsp; &nbsp; &nbsp; 0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;8 &nbsp;9 &nbsp;A &nbsp;B &nbsp;C &nbsp;D &nbsp;E &nbsp;F&quot;);
<br>
<br>
&nbsp; &nbsp; &nbsp;printf(&quot;\n%04lX &quot;,fileptr); &nbsp; /* display file offset &nbsp; &nbsp; &nbsp; */
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* display hex equivalent of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; each byte from file &nbsp; &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;for(i = 0; i &lt; length; i++)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot; %02X&quot;, (unsigned char) filebuf[i]);
<br>
<br>
&nbsp; &nbsp; &nbsp;if(length != 16) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* spaces if partial record &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=0; i&lt;(16-length); i++) printf(&quot; &nbsp; &quot;);
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* display ASCII equivalent of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; each byte from file &nbsp; &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;printf(&quot; &nbsp;&quot;);
<br>
&nbsp; &nbsp; &nbsp;for(i = 0; i &lt; length; i++)
<br>
&nbsp; &nbsp; &nbsp;{ &nbsp; if(filebuf[i] &lt; 32 || filebuf[i] &gt; 126) putchar('.');
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else putchar(filebuf[i]);
<br>
&nbsp; &nbsp; &nbsp;}
<br>
&nbsp;}
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 8-11. &nbsp;The C version: DUMP.C.
<br>
<br>
&nbsp;The assembly-language version of the DUMP program contains a number of
<br>
&nbsp;subroutines that you may find useful in your own programming efforts.
<br>
&nbsp;These include the following:
<br>
<br>
&nbsp;Subroutine &nbsp;Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;argc &nbsp; &nbsp; &nbsp; &nbsp;Returns the number of command-line arguments.
<br>
&nbsp;argv &nbsp; &nbsp; &nbsp; &nbsp;Returns the address and length of a particular command-line
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;argument.
<br>
&nbsp;w2a &nbsp; &nbsp; &nbsp; &nbsp; Converts a binary word (16 bits) into hex ASCII for output.
<br>
&nbsp;b2a &nbsp; &nbsp; &nbsp; &nbsp; Converts a binary byte (8 bits) into hex ASCII for output.
<br>
&nbsp;ascii &nbsp; &nbsp; &nbsp; Converts 4 bits into a single hex ASCII character.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It is interesting to compare these two equivalent programs. The C program
<br>
&nbsp;contains only 77 lines, whereas the assembly-language program has 436
<br>
&nbsp;lines. Clearly, the C source code is less complex and easier to maintain.
<br>
&nbsp;On the other hand, if size and efficiency are important, the DUMP.EXE file
<br>
&nbsp;generated by the C compiler is 8563 bytes, whereas the assembly-language
<br>
&nbsp;DUMP.EXE file is only 1294 bytes and runs twice as fast as the C program.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 9 &nbsp;Volumes and Directories
<br>
<br>
&nbsp;Each file in an MS-DOS system is uniquely identified by its name and its
<br>
&nbsp;location. The location, in turn, has two components: the logical drive
<br>
&nbsp;that contains the file and the directory on that drive where the filename
<br>
&nbsp;can be found.
<br>
<br>
&nbsp;Logical drives are specified by a single letter followed by a colon (for
<br>
&nbsp;example, A:). The number of logical drives in a system is not necessarily
<br>
&nbsp;the same as the number of physical drives; for example, it is common for
<br>
&nbsp;large fixed-disk drives to be divided into two or more logical drives. The
<br>
&nbsp;key aspect of a logical drive is that it contains a self-sufficient file
<br>
&nbsp;system; that is, it contains one or more directories, zero or more
<br>
&nbsp;complete files, and all the information needed to locate the files and
<br>
&nbsp;directories and to determine which disk space is free and which is already
<br>
&nbsp;in use.
<br>
<br>
&nbsp;Directories are simply lists or catalogs. Each entry in a directory
<br>
&nbsp;consists of the name, size, starting location, attributes, and last
<br>
&nbsp;modification date and time of a file or another directory that the disk
<br>
&nbsp;contains. The detailed information about the location of every block of
<br>
&nbsp;data assigned to a file or directory is in a separate control area on the
<br>
&nbsp;disk called the file allocation table (FAT). (See Chapter 10 for a
<br>
&nbsp;detailed discussion of the internal format of directories and the FAT.)
<br>
<br>
&nbsp;Every disk potentially has two distinct kinds of directories: the root
<br>
&nbsp;directory and all other directories. The root directory is always present
<br>
&nbsp;and has a maximum number of entries, determined when the disk is
<br>
&nbsp;formatted; this number cannot be changed. The subdirectories of the root
<br>
&nbsp;directory, which may or may not be present on a given disk, can be nested
<br>
&nbsp;to any level and can grow to any size (Figure 9-1). This is the
<br>
&nbsp;hierarchical, or tree, directory structure referred to in earlier
<br>
&nbsp;chapters. Every directory has a name, except for the root directory, which
<br>
&nbsp;is designated by a single backslash (\) character.
<br>
<br>
&nbsp;MS-DOS keeps track of a &quot;current drive&quot; for the system and uses this drive
<br>
&nbsp;when a file specification does not include an explicit drive code.
<br>
&nbsp;Similarly, MS-DOS maintains a &quot;current directory&quot; for each logical drive.
<br>
&nbsp;You can select any particular directory on a drive by naming in order──
<br>
&nbsp;either from the root directory or relative to the current directory──the
<br>
&nbsp;directories that lead to its location in the tree structure. Such a list
<br>
&nbsp;of directories, separated by backslash delimiters, is called a path. When
<br>
&nbsp;a complete path from the root directory is prefixed by a logical drive
<br>
&nbsp;code and followed by a filename and extension, the resulting string is a
<br>
&nbsp;fully qualified filename and unambiguously specifies a file.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ┌────────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; Drive &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ identifier │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; └─────┬──────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ┌───────┴────────┐
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ Root directory │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ (volume label) │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; └─┬──┬──┬───┬──┬─┘
<br>
&nbsp; &nbsp; &nbsp; ┌───────────────────┘ &nbsp;│ &nbsp;│ &nbsp; │ &nbsp;└───────────────────┐
<br>
&nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;┌───────────┘ &nbsp;│ &nbsp; └───────────┐ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;┌────┴───┐ ┌────┴──────┐ &nbsp; ┌───┴────┐ &nbsp; ┌──────┴────┐ ┌───┴────┐
<br>
&nbsp;│ File A │ │ Directory │ &nbsp; │ File B │ &nbsp; │ Directory │ │ File C │
<br>
&nbsp;└────────┘ └─┬───────┬─┘ &nbsp; └────────┘ &nbsp; └─┬─────────┘ └─┬──────┘
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ┌─────┘ &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp;┌────┴──────┐ &nbsp; ┌──┴─────┐ &nbsp; &nbsp; &nbsp; &nbsp;┌─────┴──┐ &nbsp; &nbsp; &nbsp;┌───┴────┐
<br>
&nbsp; &nbsp;│ Directory │ &nbsp; │ File D │ &nbsp; &nbsp; &nbsp; &nbsp;│ File E │ &nbsp; &nbsp; &nbsp;│ File F │
<br>
&nbsp; &nbsp;└───────────┘ &nbsp; └────────┘ &nbsp; &nbsp; &nbsp; &nbsp;└────────┘ &nbsp; &nbsp; &nbsp;└────────┘
<br>
<br>
&nbsp;Figure 9-1. &nbsp;An MS-DOS file-system structure.
<br>
<br>
<br>
Drive and Directory Control
<br>
<br>
&nbsp;You can examine, select, create, and delete disk directories interactively
<br>
&nbsp;with the DIR, CHDIR (CD), MKDIR (MD), and RMDIR (RD) commands. You can
<br>
&nbsp;select a new current drive by entering the letter of the desired drive,
<br>
&nbsp;followed by a colon. MS-DOS provides the following Int 21H functions to
<br>
&nbsp;give application programs similar control over drives and directories:
<br>
<br>
&nbsp;Function &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Select current drive.
<br>
&nbsp;19H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get current drive.
<br>
&nbsp;39H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Create directory.
<br>
&nbsp;3AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remove directory.
<br>
&nbsp;3BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Select current directory.
<br>
&nbsp;47H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get current directory.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The two functions that deal with disk drives accept or return a binary
<br>
&nbsp;drive code──0 represents drive A, 1 represents drive B, and so on. This
<br>
&nbsp;differs from most other MS-DOS functions, which use 0 to indicate the
<br>
&nbsp;current drive, 1 for drive A, and so on.
<br>
<br>
&nbsp;The first three directory functions in the preceding list require an
<br>
&nbsp;ASCIIZ string that describes the path to the desired directory. As with
<br>
&nbsp;the handle-based file open and create functions, the address of the ASCIIZ
<br>
&nbsp;string is passed in the DS:DX registers. On return, the carry flag is
<br>
&nbsp;clear if the function succeeds or set if the function failed, with an
<br>
&nbsp;error code in the AX register. The directory functions can fail for a
<br>
&nbsp;variety of reasons, but the most common cause of an error is that some
<br>
&nbsp;element of the indicated path does not exist.
<br>
<br>
&nbsp;The last function in the preceding list, Int 21H Function 47H, allows you
<br>
&nbsp;to obtain an ASCIIZ path for the current directory on the specified or
<br>
&nbsp;default drive. MS-DOS supplies the path string without the drive
<br>
&nbsp;identifier or a leading backslash. Int 21H Function 47H is most commonly
<br>
&nbsp;used with Int 21H Function 19H to build fully qualified filenames. Such
<br>
&nbsp;filenames are desirable because they remain valid if the user changes the
<br>
&nbsp;current drive or directory.
<br>
<br>
&nbsp;Section 2 of this book, &quot;MS-DOS Functions Reference,&quot; gives detailed
<br>
&nbsp;information on the drive and directory control functions.
<br>
<br>
Searching Directories
<br>
<br>
&nbsp;When you request an open operation on a file, you are implicitly
<br>
&nbsp;performing a search of a directory. MS-DOS examines each entry of the
<br>
&nbsp;directory to find a match for the filename you have given as an argument;
<br>
&nbsp;if the file is found, MS-DOS copies certain information from the directory
<br>
&nbsp;into a data structure that it can use to control subsequent read or write
<br>
&nbsp;operations to the file. Thus, if you wish to test for the existence of a
<br>
&nbsp;specific file, you need only perform an open operation and observe whether
<br>
&nbsp;it is successful. (If it is, you should, of course, perform a subsequent
<br>
&nbsp;close operation to avoid needless expenditure of handles.)
<br>
<br>
&nbsp;Sometimes you may need to perform more elaborate searches of a disk
<br>
&nbsp;directory. Perhaps you wish to find all the files with a certain
<br>
&nbsp;extension, a file with a particular attribute, or the names of the
<br>
&nbsp;subdirectories of a certain directory. Although the locations of a disk's
<br>
&nbsp;directories and the specifics of the entries that are found in them are of
<br>
&nbsp;necessity hardware dependent (for example, interpretation of the field
<br>
&nbsp;describing the starting location of a file depends upon the physical disk
<br>
&nbsp;format), MS-DOS does provide functions that will allow examination of a
<br>
&nbsp;disk directory in a hardware-independent fashion.
<br>
<br>
&nbsp;In order to search a disk directory successfully, you must understand two
<br>
&nbsp;types of MS-DOS search services. The first type is the &quot;search for first&quot;
<br>
&nbsp;function, which accepts a file specification──possibly including wildcard
<br>
&nbsp;characters──and looks for the first matching file in the directory of
<br>
&nbsp;interest. If it finds a match, the function fills a buffer owned by the
<br>
&nbsp;requesting program with information about the file; if it does not find a
<br>
&nbsp;match, it returns an error flag.
<br>
<br>
&nbsp;A program can call the second type of search service, called &quot;search for
<br>
&nbsp;next,&quot; only after a successful &quot;search for first.&quot; If the file
<br>
&nbsp;specification that was originally passed to &quot;search for first&quot; included
<br>
&nbsp;wildcard characters and at least one matching file was present, the
<br>
&nbsp;program can call &quot;search for next&quot; as many times as necessary to find all
<br>
&nbsp;additional matching files. Like &quot;search for first,&quot; &quot;search for next&quot;
<br>
&nbsp;returns information about the matched files in a buffer designated by the
<br>
&nbsp;requesting program. When it can find no more matching files, &quot;search for
<br>
&nbsp;next&quot; returns an error flag.
<br>
<br>
&nbsp;As with nearly every other operation, MS-DOS provides two parallel sets of
<br>
&nbsp;directory-searching services:
<br>
<br>
&nbsp;Action &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FCB function &nbsp; &nbsp; &nbsp;Handle function
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Search for first &nbsp; 11H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4EH
<br>
&nbsp;Search for next &nbsp; &nbsp;12H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4FH
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The FCB directory functions allow searches to match a filename and
<br>
&nbsp;extension, both possibly containing wildcard characters, within the
<br>
&nbsp;current directory for the specified or current drive. The handle directory
<br>
&nbsp;functions, on the other hand, allow a program to perform searches within
<br>
&nbsp;any directory on any drive, regardless of the current directory.
<br>
<br>
&nbsp;Searches that use normal FCBs find only normal files. Searches that use
<br>
&nbsp;extended FCBs, or the handle-type functions, can be qualified with file
<br>
&nbsp;attributes. The attribute bits relevant to searches are as follows:
<br>
<br>
&nbsp;Bit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Read-only file
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Hidden file
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System file
<br>
&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Volume label
<br>
&nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Directory
<br>
&nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Archive needed (set when file modified)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The remaining bits of a search function's attribute parameter should be
<br>
&nbsp;zero. When any of the preceding attribute bits are set, the search
<br>
&nbsp;function returns all normal files plus any files with the specified
<br>
&nbsp;attributes, except in the case of the volume-label attribute bit, which
<br>
&nbsp;receives special treatment as described later in this chapter. Note that
<br>
&nbsp;by setting bit 4 you can include directories in a search, exactly as
<br>
&nbsp;though they were files.
<br>
<br>
&nbsp;Both the FCB and handle directory-searching functions require that the
<br>
&nbsp;disk transfer area address be set (with Int 21H Function 1AH), before the
<br>
&nbsp;call to &quot;search for first,&quot; to point to a working buffer for use by
<br>
&nbsp;MS-DOS. The DTA address should not be changed between calls to &quot;search for
<br>
&nbsp;first&quot; and &quot;search for next.&quot; When it finds a matching file, MS-DOS places
<br>
&nbsp;the information about the file in the buffer and then inspects the buffer
<br>
&nbsp;on the next &quot;search for next&quot; call, to determine where to resume the
<br>
&nbsp;search. The format of the data returned in the buffer is different for the
<br>
&nbsp;FCB and handle functions, so read the detailed descriptions in Section 2
<br>
&nbsp;of this book, &quot;MS-DOS Functions Reference,&quot; before attempting to interpret
<br>
&nbsp;the buffer contents.
<br>
<br>
&nbsp;Figures 9-2 and 9-3 provide equivalent examples of searches for all
<br>
&nbsp;files in a given directory that have the .ASM extension, one example using
<br>
&nbsp;the FCB directory functions (Int 21H Functions 11H and 12H) and the
<br>
&nbsp;other using the handle functions (Int 21H Functions 4EH and 4FH). (Both
<br>
&nbsp;programs use the handle write function with the standard output handle to
<br>
&nbsp;display the matched filenames, to avoid introducing tangential differences
<br>
&nbsp;in the listings.)
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;start: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set DTA address for buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; used by search functions
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 1ah = search for first
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; search for first match...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fcb &nbsp; ; DS:DX = FCB address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,11h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 11h = search for first
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; any matches at all?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; exit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; no, quit
<br>
<br>
&nbsp;disp: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; go to a new line...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset crlf &nbsp;; DS:DX = CR-LF string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = string length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display matching file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff+1 ; DS:DX = filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; CX = length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; search for next match...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fcb &nbsp; ; DS:DX = FCB address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,12h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 12h = search for next
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; any more matches?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;disp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; yes, go show filename
<br>
<br>
&nbsp;exit: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; final exit point
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch = terminate,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;crlf &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0dh,0ah &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; linefeed string
<br>
<br>
&nbsp;fcb &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = current
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;8 dup ('?') &nbsp; &nbsp; ; filename = wildcard
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'ASM' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension = ASM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB = zero
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;64 dup (0) &nbsp; &nbsp; &nbsp;; receives search results
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 9-2. &nbsp;Example of an FCB-type directory search using Int 21H
<br>
&nbsp;Functions 11H and 12H. This routine displays the names of all files in
<br>
&nbsp;the current directory that have the .ASM extension.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;start: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set DTA address for buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; used by search functions
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 1ah = search for first
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; search for first match...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname ; DS:DX = wildcard filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = normal file attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 4eh = search for first
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;exit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; quit if no matches at all
<br>
<br>
&nbsp;disp: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; go to a new line...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset crlf &nbsp;; DS:DX = CR-LF string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = string length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; find length of filename...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX will be char count
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:SI = start of name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset buff+30
<br>
<br>
&nbsp;disp1: &nbsp;lodsb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get next character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is it null character?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;disp2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; yes, found end of string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; else count characters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; disp1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and get another
<br>
<br>
&nbsp;disp2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display matching file...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX already contains length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:DX = filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff+30
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; find next matching file...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 4fh = search for next
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnc &nbsp; &nbsp; disp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if another match found
<br>
<br>
&nbsp;exit: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; final exit point
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch = terminate,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;crlf &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0dh,0ah &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; linefeed string
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'*.ASM',0 &nbsp; &nbsp; &nbsp; ; ASCIIZ filename to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; be matched
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;64 dup (0) &nbsp; &nbsp; &nbsp;; receives search results
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 9-3. &nbsp;Example of a handle-type directory search using Int 21H
<br>
&nbsp;Functions 4EH and 4FH. This routine also displays the names of all files
<br>
&nbsp;in the current directory that have a .ASM extension.
<br>
<br>
Moving Files
<br>
<br>
&nbsp;The rename file function that was added in MS-DOS version 2.0, Int 21H
<br>
&nbsp;Function 56H, has the little-advertised capability to move a file from
<br>
&nbsp;one directory to another. The function has two ASCIIZ parameters: the
<br>
&nbsp;&quot;old&quot; and &quot;new&quot; names for the file. If the old and new paths differ,
<br>
&nbsp;MS-DOS moves the file; if the filename or extension components differ,
<br>
&nbsp;MS-DOS renames the file. MS-DOS can carry out both of these actions in the
<br>
&nbsp;same function call.
<br>
<br>
&nbsp;Of course, the old and new directories must be on the same drive, because
<br>
&nbsp;the file's actual data is not moved at all; only the information that
<br>
&nbsp;describes the file is removed from one directory and placed in another
<br>
&nbsp;directory. Function 56H fails if the two ASCIIZ strings include different
<br>
&nbsp;logical-drive codes, if the file is read-only, or if a file with the same
<br>
&nbsp;name and location as the &quot;new&quot; filename already exists.
<br>
<br>
&nbsp;The FCB-based rename file service, Int 21H Function 17H, works only on
<br>
&nbsp;the current directory and cannot be used to move files.
<br>
<br>
<br>
Volume Labels
<br>
<br>
&nbsp;Support for volume labels was first added to MS-DOS in version 2.0. A
<br>
&nbsp;volume label is an optional name of from 1 to 11 characters that the user
<br>
&nbsp;assigns to a disk during a FORMAT operation. You can display a volume
<br>
&nbsp;label with the DIR, TREE, CHKDSK, or VOL command. Beginning with MS-DOS
<br>
&nbsp;version 3.0, you can use the LABEL command to add, display, or alter the
<br>
&nbsp;label after formatting. In MS-DOS version 4, the FORMAT program also
<br>
&nbsp;assigns a semi-random 32-bit binary ID to each disk it formats; you can
<br>
&nbsp;display this value, but you cannot change it.
<br>
<br>
&nbsp;The distinction between volumes and drives is important. A volume label is
<br>
&nbsp;associated with a specific storage medium. A drive identifier (such as A)
<br>
&nbsp;is associated with a physical device that a storage medium can be mounted
<br>
&nbsp;on. In the case of fixed-disk drives, the medium associated with a drive
<br>
&nbsp;identifier does not change (hence the name). In the case of floppy disks
<br>
&nbsp;or other removable media, the disk accessed with a given drive identifier
<br>
&nbsp;might have any volume label or none at all.
<br>
<br>
&nbsp;Hence, volume labels do not take the place of the logical-drive identifier
<br>
&nbsp;and cannot be used as part of a pathname to identify a file. In fact, in
<br>
&nbsp;MS-DOS version 2, the system does not use volume labels internally at all.
<br>
&nbsp;In MS-DOS versions 3.0 and later, a disk driver can use volume labels to
<br>
&nbsp;detect whether the user has replaced a disk while a file is open; this use
<br>
&nbsp;is optional, however, and is not implemented in all systems.
<br>
<br>
&nbsp;MS-DOS volume labels are implemented as a special type of entry in a
<br>
&nbsp;disk's root directory. The entry contains a time-and-date stamp and has an
<br>
&nbsp;attribute value of 8 (i.e., bit 3 set). Except for the attribute, a volume
<br>
&nbsp;label is identical to the directory entry for a file that was created but
<br>
&nbsp;never had any data written into it, and you can manipulate volume labels
<br>
&nbsp;with Int 21H functions much as you manipulate files. However, a volume
<br>
&nbsp;label receives special handling at several levels:
<br>
<br>
&nbsp;■ &nbsp;When you create a volume label after a disk is formatted, MS-DOS always
<br>
&nbsp; &nbsp; places it in the root directory, regardless of the current directory.
<br>
<br>
&nbsp;■ &nbsp;A disk can contain only one volume label; attempts to create additional
<br>
&nbsp; &nbsp; volume labels (even with different names) will fail.
<br>
<br>
&nbsp;■ &nbsp;MS-DOS always carries out searches for volume labels in the root
<br>
&nbsp; &nbsp; directory, regardless of the current directory, and does not also
<br>
&nbsp; &nbsp; return all normal files.
<br>
<br>
&nbsp;In MS-DOS version 2, support for volume labels is not completely
<br>
&nbsp;integrated into the handle file functions, and you must use extended FCBs
<br>
&nbsp;instead to manipulate volume labels. For example, the code in Figure 9-4
<br>
&nbsp;searches for the volume label in the root directory of the current drive.
<br>
&nbsp;You can also change volume labels with extended FCBs and the rename file
<br>
&nbsp;function (Int 21H Function 17H), but you should not attempt to remove an
<br>
&nbsp;existing volume label with Int 21H Function 13H under MS-DOS version 2,
<br>
&nbsp;because this operation can damage the disk's FAT in an unpredictable
<br>
&nbsp;manner.
<br>
<br>
&nbsp;In MS-DOS versions 3.0 and later, you can create a volume label in the
<br>
&nbsp;expected manner, using Int 21H Function 3CH and an attribute of 8, and
<br>
&nbsp;you can use the handle-type &quot;search for first&quot; function (4EH) to obtain
<br>
&nbsp;an existing volume label for a logical drive (Figure 9-5). However, you
<br>
&nbsp;still must use extended FCBs to change a volume label.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;64 dup (?) &nbsp; ; receives search results
<br>
<br>
&nbsp;xfcb &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0ffh &nbsp; &nbsp; &nbsp; &nbsp; ; flag signifying extended FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;5 dup (0) &nbsp; &nbsp;; reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; volume attribute byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive code (0 = current)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;11 dup ('?') ; wildcard filename and extension
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; ; remainder of FCB (not used)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set DTA address for buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; used by search functions
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp;; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; ; function 1ah = set DTA
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; now search for label...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; DS:DX = extended FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset xfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,11h &nbsp; &nbsp; &nbsp; ; function 11h = search for first
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,0ffh &nbsp; &nbsp; &nbsp;; search successful?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;no_label &nbsp; &nbsp; ; jump if no volume label
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 9-4. &nbsp;A volume-label search under MS-DOS version 2, using an
<br>
&nbsp;extended file control block. If the search is successful, the volume label
<br>
&nbsp;is returned in buff, formatted in the filename and extension fields of an
<br>
&nbsp;extended FCB.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;64 dup (?) &nbsp; ; receives search results
<br>
<br>
&nbsp;wildcd &nbsp;db &nbsp; &nbsp; &nbsp;'*.*',0 &nbsp; &nbsp; &nbsp;; wildcard ASCIIZ filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set DTA address for buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; used by search functions
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp;; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; ; function 1ah = set DTA
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; now search for label...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; DS:DX = ASCIIZ string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset wildcd
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,8 &nbsp; &nbsp; &nbsp; &nbsp; ; CX = volume attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4eh &nbsp; &nbsp; &nbsp; ; function 4eh = search for first
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;no_label &nbsp; &nbsp; ; jump if no volume label
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 9-5. &nbsp;A volume-label search under MS-DOS version 3, using the
<br>
&nbsp;handle-type file functions. If the search is successful (carry flag
<br>
&nbsp;returned clear), the volume name is placed at location buff+1EH in the
<br>
&nbsp;form of an ASCIIZ string.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 10 &nbsp;Disk Internals
<br>
<br>
&nbsp;MS-DOS disks are organized according to a rather rigid scheme that is
<br>
&nbsp;easily understood and therefore easily manipulated. Although you will
<br>
&nbsp;probably never need to access the special control areas of a disk
<br>
&nbsp;directly, an understanding of their internal structure leads to a better
<br>
&nbsp;understanding of the behavior and performance of MS-DOS as a whole.
<br>
<br>
&nbsp;From the application programmer's viewpoint, MS-DOS presents disk devices
<br>
&nbsp;as logical volumes that are associated with a drive code (A, B, C, and so
<br>
&nbsp;on) and that have a volume name (optional), a root directory, and from
<br>
&nbsp;zero to many additional directories and files. MS-DOS shields the
<br>
&nbsp;programmer from the physical characteristics of the medium by providing a
<br>
&nbsp;battery of disk services through Int 21H. Using these services, the
<br>
&nbsp;programmer can create, open, read, write, close, and delete files in a
<br>
&nbsp;uniform way, regardless of the disk drive's size, speed, number of
<br>
&nbsp;read/write heads, number of tracks, and so forth.
<br>
<br>
&nbsp;Requests from an application program for file operations actually go
<br>
&nbsp;through two levels of translation before resulting in the physical
<br>
&nbsp;transfer of data between the disk device and random-access memory:
<br>
<br>
&nbsp;1. &nbsp;Beneath the surface, MS-DOS views each logical volume, whether it is
<br>
&nbsp; &nbsp; &nbsp;an entire physical unit such as a floppy disk or only a part of a
<br>
&nbsp; &nbsp; &nbsp;fixed disk, as a continuous sequence of logical sectors, starting at
<br>
&nbsp; &nbsp; &nbsp;sector 0. (A logical disk volume can also be implemented on other
<br>
&nbsp; &nbsp; &nbsp;types of storage. For example, RAM disks map a disk structure onto an
<br>
&nbsp; &nbsp; &nbsp;area of random-access memory.) MS-DOS translates an application
<br>
&nbsp; &nbsp; &nbsp;program's Int 21H file-management requests into requests for transfers
<br>
&nbsp; &nbsp; &nbsp;of logical sectors, using the information found in the volume's
<br>
&nbsp; &nbsp; &nbsp;directories and allocation tables. (For those rare situations where it
<br>
&nbsp; &nbsp; &nbsp;is appropriate, programs can also access logical sectors directly with
<br>
&nbsp; &nbsp; &nbsp;Int 25H and Int 26H.)
<br>
<br>
&nbsp;2. &nbsp;MS-DOS then passes the requests for logical sectors to the disk
<br>
&nbsp; &nbsp; &nbsp;device's driver, which maps them onto actual physical addresses (head,
<br>
&nbsp; &nbsp; &nbsp;track, and sector). Disk drivers are extremely hardware dependent and
<br>
&nbsp; &nbsp; &nbsp;are always written in assembly language for maximum speed. In most
<br>
&nbsp; &nbsp; &nbsp;versions of MS-DOS, a driver for IBM-compatible floppy- and fixed-disk
<br>
&nbsp; &nbsp; &nbsp;drives is built into the MS-DOS BIOS module (IO.SYS) and is always
<br>
&nbsp; &nbsp; &nbsp;loaded during system initialization; you can install additional
<br>
&nbsp; &nbsp; &nbsp;drivers for non-IBM-compatible disk devices by including the
<br>
&nbsp; &nbsp; &nbsp;appropriate DEVICE directives in the CONFIG.SYS file.
<br>
<br>
&nbsp;Each MS-DOS logical volume is divided into several fixed-size control
<br>
&nbsp;areas and a files area (Figure 10-1). The size of each control area
<br>
&nbsp;depends on several factors──the size of the volume and the version of
<br>
&nbsp;FORMAT used to initialize the volume, for example──but all of the
<br>
&nbsp;information needed to interpret the structure of a particular logical
<br>
&nbsp;volume can be found on the volume itself in the boot sector.
<br>
<br>
&nbsp;┌───────────────────────────────────────────────────────┐
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Boot sector &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved area &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;├───────────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; File allocation table #1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;├───────────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Possible additional copies of FAT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;├───────────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Root directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;├───────────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Files area &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;└───────────────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 10-1. &nbsp;Map of a typical MS-DOS logical volume. The boot sector
<br>
&nbsp;(logical sector 0) contains the OEM identification, BIOS parameter block
<br>
&nbsp;(BPB), and disk bootstrap. The remaining sectors are divided among an
<br>
&nbsp;optional reserved area, one or more copies of the file allocation table,
<br>
&nbsp;the root directory, and the files area.
<br>
<br>
<br>
The Boot Sector
<br>
<br>
&nbsp;Logical sector 0, known as the boot sector, contains all of the critical
<br>
&nbsp;information regarding the disk medium's characteristics (Figure 10-2).
<br>
&nbsp;The first byte in the sector is always an 80x86 jump instruction──either a
<br>
&nbsp;normal intrasegment JMP (opcode 0E9H) followed by a 16-bit displacement or
<br>
&nbsp;a &quot;short&quot; JMP (opcode 0EBH) followed by an 8-bit displacement and then by
<br>
&nbsp;an NOP (opcode 90H). If neither of these two JMP opcodes is present, the
<br>
&nbsp;disk has not been formatted or was not formatted for use with MS-DOS. (Of
<br>
&nbsp;course, the presence of the JMP opcode does not in itself ensure that the
<br>
&nbsp;disk has an MS-DOS format.)
<br>
<br>
&nbsp;Following the initial JMP instruction is an 8-byte field that is reserved
<br>
&nbsp;by Microsoft for OEM identification. The disk-formatting program, which is
<br>
&nbsp;specialized for each brand of computer, disk controller, and medium, fills
<br>
&nbsp;in this area with the name of the computer manufacturer and the
<br>
&nbsp;manufacturer's internal MS-DOS version number.
<br>
<br>
&nbsp;00H ┌───────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; E9 XX XX or EB XX 90 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;03H ├───────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OEM name and version &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (8 bytes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;OBH ├───────────────────────────────────────────────┤─┐
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bytes per sector (2 bytes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ │
<br>
&nbsp;ODH ├───────────────────────────────────────────────┤ │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; Sectors per allocation unit (1 byte) &nbsp; &nbsp; &nbsp;│ │
<br>
&nbsp;0EH ├───────────────────────────────────────────────┤ │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; Reserved sectors, starting at 0 (2 bytes) &nbsp; │ │
<br>
&nbsp;10H ├───────────────────────────────────────────────┤ │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of FATs (1 byte) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ B
<br>
&nbsp;11H ├───────────────────────────────────────────────┤ P
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp;Number of root-directory entries (2 bytes) &nbsp; │ B
<br>
&nbsp;13H ├───────────────────────────────────────────────┤ │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; Total sectors in logical volume (2 bytes) &nbsp; │ │
<br>
&nbsp;15H ├───────────────────────────────────────────────┤ │ MS-DOS
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Media descriptor byte &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ │ version 2.0
<br>
&nbsp;16H ├───────────────────────────────────────────────┤ │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;Number of sectors per FAT (2 bytes) &nbsp; &nbsp; &nbsp;│ │
<br>
&nbsp;18H ├───────────────────────────────────────────────┤═╡
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sectors per track (2 bytes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ │
<br>
&nbsp;1AH ├───────────────────────────────────────────────┤ │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Number of heads (2 bytes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ │ MS-DOS
<br>
&nbsp;1CH ├───────────────────────────────────────────────┤ │ version 3.0
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;Number of hidden sectors (4 bytes) &nbsp; &nbsp; &nbsp; │═╡
<br>
&nbsp;20H ├───────────────────────────────────────────────┤ │ MS-DOS
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp;Total sectors in logical volume &nbsp; &nbsp; &nbsp; &nbsp;│ │ version 4.0
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;(MS-DOS 4.0 and volume size &gt;32 MB) &nbsp; &nbsp; &nbsp;│ │
<br>
&nbsp;24H ├───────────────────────────────────────────────┤═╡
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Physical drive number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ │
<br>
&nbsp;25H ├───────────────────────────────────────────────┤ │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ │
<br>
&nbsp;26H ├───────────────────────────────────────────────┤ │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; Extended boot signature record (29H) &nbsp; &nbsp; &nbsp;│ │ Additional
<br>
&nbsp;27H ├───────────────────────────────────────────────┤ │ MS-DOS 4.0
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32-bit binary volume ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ │ information
<br>
&nbsp;2BH ├───────────────────────────────────────────────┤ │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Volume label (11 bytes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ │
<br>
&nbsp;36H ├───────────────────────────────────────────────┤ │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved (8 bytes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ │
<br>
&nbsp;3EH ├───────────────────────────────────────────────┤─┘
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bootstrap &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp;└───────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 10-2. &nbsp;Map of the boot sector of an MS-DOS disk. Note the JMP at
<br>
&nbsp;offset 0, the OEM identification field, the MS-DOS version 2 compatible
<br>
&nbsp;BIOS parameter block (bytes 0BH─17H), the three additional WORD fields for
<br>
&nbsp;MS-DOS version 3, the double-word number-of-sectors field and 32-bit
<br>
&nbsp;binary volume ID for MS-DOS version 4.0, and the bootstrap code.
<br>
<br>
&nbsp;The third major component of the boot sector is the BIOS parameter block
<br>
&nbsp;(BPB) in bytes 0BH through 17H. (Additional fields are present in MS-DOS
<br>
&nbsp;versions 3.0 and later.) This data structure describes the physical disk
<br>
&nbsp;characteristics and allows the device driver to calculate the proper
<br>
&nbsp;physical disk address for a given logical-sector number; it also contains
<br>
&nbsp;information that is used by MS-DOS and various system utilities to
<br>
&nbsp;calculate the address and size of each of the disk control areas (file
<br>
&nbsp;allocation tables and root directory).
<br>
<br>
&nbsp;The final element of the boot sector is the disk bootstrap routine. The
<br>
&nbsp;disk bootstrap is usually read into memory by the ROM bootstrap, which is
<br>
&nbsp;executed automatically when the computer is turned on. The ROM bootstrap
<br>
&nbsp;is usually just smart enough to home the head of the disk drive (move it
<br>
&nbsp;to track 0), read the first physical sector into RAM at a predetermined
<br>
&nbsp;location, and jump to it. The disk bootstrap is more sophisticated. It
<br>
&nbsp;calculates the physical disk address of the beginning of the files area,
<br>
&nbsp;reads the files containing the operating system into memory, and transfers
<br>
&nbsp;control to the BIOS module at location 0070:0000H. (See Chapter 2.)
<br>
<br>
&nbsp;Figures 10-3 and 10-4 show a partial hex dump and disassembly of a
<br>
&nbsp;PC-DOS 3.3 floppy-disk boot sector.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;8 &nbsp;9 &nbsp;A &nbsp;B &nbsp;C &nbsp;D &nbsp;E &nbsp;F
<br>
&nbsp;0000 &nbsp;EB 34 90 49 42 4D 20 20 33 2E 33 00 02 02 01 00 &nbsp;.4.IBM &nbsp;3.3.....
<br>
&nbsp;0010 &nbsp;02 70 00 D0 02 FD 02 00 09 00 02 00 00 00 00 00 &nbsp;.p..............
<br>
&nbsp;0020 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 12 &nbsp;................
<br>
&nbsp;0030 &nbsp;00 00 00 00 01 00 FA 33 C0 8E D0 BC 00 7C 16 07 &nbsp;.......3.....|..
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;01C0 &nbsp;0D 0A 44 69 73 6B 20 42 6F 6F 74 20 66 61 69 6C &nbsp;..Disk Boot fail
<br>
&nbsp;01D0 &nbsp;75 72 65 0D 0A 00 49 42 4D 42 49 4F 20 20 43 4F &nbsp;ure...IBMBIO &nbsp;CO
<br>
&nbsp;01E0 &nbsp;4D 49 42 4D 44 4F 53 20 20 43 4F 4D 00 00 00 00 &nbsp;MIBMDOS &nbsp;COM....
<br>
&nbsp;01F0 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 AA &nbsp;..............U.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 10-3. &nbsp;Partial hex dump of the boot sector (track 0, head 0, sector
<br>
&nbsp;1) of a PC-DOS version 3.3 floppy disk. This sector contains the OEM
<br>
&nbsp;identification, a copy of the BIOS parameter block describing the medium,
<br>
&nbsp;and the bootstrap routine that reads the BIOS into memory and transfers
<br>
&nbsp;control to it. See also Figures 10-2 and 10-4.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; $+54 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump to bootstrap
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nop
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'IBM &nbsp;3.3' &nbsp; &nbsp; &nbsp;; OEM identification
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; BIOS parameter block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;512 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; bytes per sector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; sectors per cluster
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; reserved sectors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; number of FATs
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;112 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; root directory entries
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;720 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; total sectors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0fdh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; media descriptor byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; sectors per FAT
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; sectors per track
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; number of heads
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; hidden sectors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 10-4. &nbsp;Partial disassembly of the boot sector shown in Figure
<br>
&nbsp;10-3.
<br>
<br>
<br>
The Reserved Area
<br>
<br>
&nbsp;The boot sector is actually part of a reserved area that can span from one
<br>
&nbsp;to several sectors. The reserved-sectors word in the BPB, at offset 0EH in
<br>
&nbsp;the boot sector, describes the size of this area. Remember that the number
<br>
&nbsp;in the BPB field includes the boot sector itself, so if the value is 1 (as
<br>
&nbsp;it is on IBM PC floppy disks), the length of the reserved area is actually
<br>
&nbsp;0 sectors.
<br>
<br>
<br>
The File Allocation Table
<br>
<br>
&nbsp;When a file is created or extended, MS-DOS assigns it groups of disk
<br>
&nbsp;sectors from the files area in powers of 2. These are known as allocation
<br>
&nbsp;units or clusters. The number of sectors per cluster for a given medium is
<br>
&nbsp;defined in the BPB and can be found at offset 0DH in the disk's boot
<br>
&nbsp;sector. Below are some example cluster sizes:
<br>
<br>
&nbsp;Disk type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Power of 2 &nbsp; &nbsp;Sectors/cluster
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;5.25&quot; 180 KB floppy disk &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1
<br>
&nbsp;5.25&quot; 360 KB floppy disk &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2
<br>
&nbsp;PC/AT fixed disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4
<br>
&nbsp;PC/XT fixed disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The file allocation table (FAT) is divided into fields that correspond
<br>
&nbsp;directly to the assignable clusters on the disk. These fields are 12 bits
<br>
&nbsp;in MS-DOS versions 1 and 2 and may be either 12 bits or 16 bits in
<br>
&nbsp;versions 3.0 and later, depending on the size of the medium (12 bits if
<br>
&nbsp;the disk contains fewer than 4087 clusters, 16 bits otherwise).
<br>
<br>
&nbsp;The first two fields in the FAT are always reserved. On IBM-compatible
<br>
&nbsp;media, the first 8 bits of the first reserved FAT entry contain a copy of
<br>
&nbsp;the media descriptor byte, which is also found in the BPB in the boot
<br>
&nbsp;sector. The second, third, and (if applicable) fourth bytes, which
<br>
&nbsp;constitute the remainder of the first two reserved FAT fields, always
<br>
&nbsp;contain 0FFH. The currently defined IBM-format media descriptor bytes are
<br>
&nbsp;as follows:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MS-DOS version
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; where first
<br>
&nbsp;Descriptor &nbsp; &nbsp; Medium &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;supported
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0F0H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.5&quot; floppy disk, 2-sided, 18-sector &nbsp; &nbsp; &nbsp; &nbsp;3.3
<br>
&nbsp;0F8H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Fixed disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;0F9H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25&quot; floppy disk, 2-sided, 15-sector &nbsp; &nbsp; &nbsp; 3.0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.5&quot; floppy disk, 2-sided, 9-sector &nbsp; &nbsp; &nbsp; &nbsp; 3.2
<br>
&nbsp;0FCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25&quot; floppy disk, 1-sided, 9-sector &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;0FDH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25&quot; floppy disk, 2-sided, 9-sector &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8&quot; floppy disk, 1-sided, single-density
<br>
&nbsp;0FEH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25&quot; floppy disk, 1-sided, 8-sector &nbsp; &nbsp; &nbsp; &nbsp;1.0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8&quot; floppy disk, 1-sided, single-density
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8&quot; floppy disk, 2-sided, double-density
<br>
&nbsp;0FFH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25&quot; floppy disk, 2-sided, 8-sector &nbsp; &nbsp; &nbsp; &nbsp;1.1
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The remainder of the FAT entries describe the use of their corresponding
<br>
&nbsp;disk clusters. The contents of the FAT fields are interpreted as follows:
<br>
<br>
&nbsp;Value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;(0)000H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cluster available
<br>
&nbsp;(F)FF0─(F)FF6H &nbsp; &nbsp; Reserved cluster
<br>
&nbsp;(F)FF7H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bad cluster, if not part of chain
<br>
&nbsp;(F)FF8─(F)FFFH &nbsp; &nbsp; Last cluster of file
<br>
&nbsp;(X)XXX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next cluster in file
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Each file's entry in a directory contains the number of the first cluster
<br>
&nbsp;assigned to that file, which is used as an entry point into the FAT. From
<br>
&nbsp;the entry point on, each FAT slot contains the cluster number of the next
<br>
&nbsp;cluster in the file, until a last-cluster mark is encountered.
<br>
<br>
&nbsp;At the computer manufacturer's option, MS-DOS can maintain two or more
<br>
&nbsp;identical copies of the FAT on each volume. MS-DOS updates all copies
<br>
&nbsp;simultaneously whenever files are extended or the directory is modified.
<br>
&nbsp;If access to a sector in a FAT fails due to a read error, MS-DOS tries the
<br>
&nbsp;other copies until a successful disk read is obtained or all copies are
<br>
&nbsp;exhausted. Thus, if one copy of the FAT becomes unreadable due to wear or
<br>
&nbsp;a software accident, the other copies may still make it possible to
<br>
&nbsp;salvage the files on the disk. As part of its procedure for checking the
<br>
&nbsp;integrity of a disk, the CHKDSK program compares the multiple copies
<br>
&nbsp;(usually two) of the FAT to make sure they are all readable and
<br>
&nbsp;consistent.
<br>
<br>
<br>
The Root Directory
<br>
<br>
&nbsp;Following the file allocation tables is an area known in MS-DOS versions
<br>
&nbsp;2.0 and later as the root directory. (Under MS-DOS version 1, it was the
<br>
&nbsp;only directory on the disk.) The root directory contains 32-byte entries
<br>
&nbsp;that describe files, other directories, and the optional volume label
<br>
&nbsp;(Figure 10-5). An entry beginning with the byte value E5H is available
<br>
&nbsp;for reuse; it represents a file or directory that has been erased. An
<br>
&nbsp;entry beginning with a null (zero) byte is the logical end-of-directory;
<br>
&nbsp;that entry and all subsequent entries have never been used.
<br>
<br>
&nbsp;00H ┌──────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Filename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │ Note 1
<br>
&nbsp;08H ├──────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Extension &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;0BH ├──────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp;File attribute &nbsp; &nbsp; &nbsp; &nbsp;│ Note 2
<br>
&nbsp;0CH ├──────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;16H ├──────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ Time created or last updated │ Note 3
<br>
&nbsp;18H ├──────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ Date created or last updated │ Note 4
<br>
&nbsp;1AH ├──────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; Starting cluster &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;1CH ├──────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;File size, 4 bytes &nbsp; &nbsp; &nbsp;│ Note 5
<br>
&nbsp;20H └──────────────────────────────┘
<br>
<br>
&nbsp;Figure 10-5. &nbsp;Format of a single entry in a disk directory. Total length
<br>
&nbsp;is 32 bytes (20H bytes).
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Notes for Figure 10-5
<br>
&nbsp; &nbsp;1. &nbsp;The first byte of the filename field of a directory entry may
<br>
&nbsp; &nbsp; &nbsp; &nbsp;contain the following special information:
<br>
<br>
&nbsp; &nbsp;Value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Directory entry has never been used; end of occupied
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;portion of directory.
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; First character of filename is actually E5H.
<br>
&nbsp; &nbsp;2EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry is an alias for the current or parent directory.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If the next byte is also 2EH, the cluster field
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;contains the cluster number of the parent directory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(zero if the parent directory is the root directory).
<br>
&nbsp; &nbsp;E5H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; File has been erased.
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;2. &nbsp;The attribute byte of the directory entry is mapped as follows:
<br>
<br>
&nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read-only; attempts to open file for write or to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;delete file will fail.
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hidden file; excluded from normal searches.
<br>
&nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System file; excluded from normal searches.
<br>
&nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Volume label; can exist only in root directory.
<br>
&nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Directory; excluded from normal searches.
<br>
&nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Archive bit; set whenever file is modified.
<br>
&nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved.
<br>
&nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved.
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;3. &nbsp;The time field is encoded as follows:
<br>
<br>
&nbsp; &nbsp;Bits &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contents
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H─04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Binary number of 2-second increments (0─29,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;corresponding to 0─58 seconds)
<br>
&nbsp; &nbsp;05H─0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Binary number of minutes (0─59)
<br>
&nbsp; &nbsp;0BH─0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Binary number of hours (0─23)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;4. &nbsp;The date field is encoded as follows:
<br>
<br>
&nbsp; &nbsp;Bits &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contents
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H─04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Day of month (1─31)
<br>
&nbsp; &nbsp;05H─08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Month (1─12)
<br>
&nbsp; &nbsp;09H─0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Year (relative to 1980)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;5. &nbsp;The file-size field is interpreted as a 4-byte integer, with the
<br>
&nbsp; &nbsp; &nbsp; &nbsp;low-order 2 bytes of the number stored first.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The root directory has a number of special properties. Its size and
<br>
&nbsp;position are fixed and are determined by the FORMAT program when a disk is
<br>
&nbsp;initialized. This information can be obtained from the boot sector's BPB.
<br>
&nbsp;If the disk is bootable, the first two entries in the root directory
<br>
&nbsp;always describe the files containing the MS-DOS BIOS and the MS-DOS
<br>
&nbsp;kernel. The disk bootstrap routine uses these entries to bring the
<br>
&nbsp;operating system into memory and start it up.
<br>
<br>
&nbsp;Figure 10-6 shows a partial hex dump of the first sector of the root
<br>
&nbsp;directory on a bootable PC-DOS 3.3 floppy disk.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;8 &nbsp;9 &nbsp;A &nbsp;B &nbsp;C &nbsp;D &nbsp;E &nbsp;F
<br>
&nbsp;0000 &nbsp;49 42 4D 42 49 4F 20 20 43 4F 4D 27 00 00 00 00 &nbsp;IBMBIO &nbsp;COM'....
<br>
&nbsp;0010 &nbsp;00 00 00 00 00 00 00 60 72 0E 02 00 54 56 00 00 &nbsp;.......'r...TV..
<br>
&nbsp;0020 &nbsp;49 42 4D 44 4F 53 20 20 43 4F 4D 27 00 00 00 00 &nbsp;IBMDOS &nbsp;COM'....
<br>
&nbsp;0030 &nbsp;00 00 00 00 00 00 00 60 71 0E 18 00 CF 75 00 00 &nbsp;.......'q....u..
<br>
&nbsp;0040 &nbsp;43 4F 4D 4D 41 4E 44 20 43 4F 4D 20 00 00 00 00 &nbsp;COMMAND COM ....
<br>
&nbsp;0050 &nbsp;00 00 00 00 00 00 00 60 71 0E 36 00 DB 62 00 00 &nbsp;.......'q.6..b..
<br>
&nbsp;0060 &nbsp;42 4F 4F 54 44 49 53 4B 20 20 20 28 00 00 00 00 &nbsp;BOOTDISK &nbsp; (....
<br>
&nbsp;0070 &nbsp;00 00 00 00 00 00 A1 00 21 00 00 00 00 00 00 00 &nbsp;........!.......
<br>
&nbsp;0080 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &nbsp;................
<br>
&nbsp;0090 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &nbsp;................
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 10-6. &nbsp;Partial hex dump of the first sector of the root directory
<br>
&nbsp;for a PC-DOS 3.3 disk containing the three system files and a volume
<br>
&nbsp;label.
<br>
<br>
<br>
The Files Area
<br>
<br>
&nbsp;The remainder of the volume after the root directory is known as the files
<br>
&nbsp;area. MS-DOS views the sectors in this area as a pool of clusters, each
<br>
&nbsp;containing one or more logical sectors, depending on the disk format. Each
<br>
&nbsp;cluster has a corresponding entry in the FAT that describes its current
<br>
&nbsp;use: available, reserved, assigned to a file, or unusable (because of
<br>
&nbsp;defects in the medium). Because the first two fields of the FAT are
<br>
&nbsp;reserved, the first cluster in the files area is assigned the number 2.
<br>
<br>
&nbsp;When a file is extended under versions 1 and 2, MS-DOS searches the FAT
<br>
&nbsp;from the beginning until it finds a free cluster (designated by a zero FAT
<br>
&nbsp;field); it then changes that FAT field to a last-cluster mark and updates
<br>
&nbsp;the previous last cluster of the file's chain to point to the new last
<br>
&nbsp;cluster. Under versions 3.0 and later, however, MS-DOS searches the FAT
<br>
&nbsp;from the most recently allocated cluster; this reduces file fragmentation
<br>
&nbsp;and improves overall access times.
<br>
<br>
&nbsp;Directories other than the root directory are simply a special type of
<br>
&nbsp;file. Their storage is allocated from the files area, and their contents
<br>
&nbsp;are 32-byte entries──in the same format as those used in the root
<br>
&nbsp;directory──that describe files or other directories. Directory entries
<br>
&nbsp;that describe other directories contain an attribute byte with bit 4 set,
<br>
&nbsp;zero in the file-length field, and the date and time that the directory
<br>
&nbsp;was created (Figure 10-7). The first cluster field points, of course, to
<br>
&nbsp;the first cluster in the files area that belongs to the directory. (The
<br>
&nbsp;directory's other clusters can be found only by tracing through the FAT.)
<br>
<br>
&nbsp;All directories except the root directory contain two special directory
<br>
&nbsp;entries with the names . and ... MS-DOS puts these entries in place when
<br>
&nbsp;it creates a directory, and they cannot be deleted. The . entry is an
<br>
&nbsp;alias for the current directory; its cluster field points to the cluster
<br>
&nbsp;in which it is found. The .. entry is an alias for the directory's parent
<br>
&nbsp;(the directory immediately above it in the tree structure); its cluster
<br>
&nbsp;field points to the first cluster of the parent directory. If the parent
<br>
&nbsp;is the root directory, the cluster field of the .. entry contains zero
<br>
&nbsp;(Figure 10-8).
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;0080 &nbsp;4D 59 44 49 52 20 20 20 20 20 20 10 00 00 00 00 &nbsp;MYDIR &nbsp; &nbsp; &nbsp;.....
<br>
&nbsp;0090 &nbsp;00 00 00 00 00 00 87 9A 9B 0A 2A 00 00 00 00 00 &nbsp;..........*.....
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 10-7. &nbsp;Extract from the root directory of an MS-DOS disk, showing
<br>
&nbsp;the entry for a subdirectory named MYDIR. Bit 4 in the attribute byte is
<br>
&nbsp;set, the cluster field points to the first cluster of the subdirectory
<br>
&nbsp;file, the date and time stamps are valid, but the file length is zero.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;8 &nbsp;9 &nbsp;A &nbsp;B &nbsp;C &nbsp;D &nbsp;E &nbsp;F
<br>
&nbsp;0000 &nbsp;2E 20 20 20 20 20 20 20 20 20 20 10 00 00 00 00 &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; .....
<br>
&nbsp;0010 &nbsp;00 00 00 00 00 00 87 9A 9B 0A 2A 00 00 00 00 00 &nbsp;..........*.....
<br>
&nbsp;0020 &nbsp;2E 2E 20 20 20 20 20 20 20 20 20 10 00 00 00 00 &nbsp;.. &nbsp; &nbsp; &nbsp; &nbsp;.....
<br>
&nbsp;0030 &nbsp;00 00 00 00 00 00 87 9A 9B 0A 00 00 00 00 00 00 &nbsp;................
<br>
&nbsp;0040 &nbsp;4D 59 46 49 4C 45 20 20 44 41 54 20 00 00 00 00 &nbsp;MYFILE &nbsp;DAT ....
<br>
&nbsp;0050 &nbsp;00 00 00 00 00 00 98 9A 9B 0A 2B 00 15 00 00 00 &nbsp;..........+.....
<br>
&nbsp;0060 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &nbsp;................
<br>
&nbsp;0070 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &nbsp;................
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 10-8. &nbsp;Hex dump of the first block of the directory MYDIR. Note the
<br>
&nbsp;. and .. entries. This directory contains exactly one file, MYFILE.DAT.
<br>
<br>
<br>
Interpreting the File Allocation Table
<br>
<br>
&nbsp;Now that we understand how the disk is structured, let's see how we can
<br>
&nbsp;use this knowledge to find a FAT position from a cluster number.
<br>
<br>
&nbsp;If the FAT has 12-bit entries, use the following procedure:
<br>
<br>
&nbsp;1. &nbsp;Use the directory entry to find the starting cluster of the file in
<br>
&nbsp; &nbsp; &nbsp;question.
<br>
<br>
&nbsp;2. &nbsp;Multiply the cluster number by 1.5.
<br>
<br>
&nbsp;3. &nbsp;Use the integral part of the product as the offset into the FAT and
<br>
&nbsp; &nbsp; &nbsp;move the word at that offset into a register. Remember that a FAT
<br>
&nbsp; &nbsp; &nbsp;position can span a physical disk-sector boundary.
<br>
<br>
&nbsp;4. &nbsp;If the product is a whole number, AND the register with 0FFFH.
<br>
<br>
&nbsp;5. &nbsp;Otherwise, &quot;logical shift&quot; the register right 4 bits.
<br>
<br>
&nbsp;6. &nbsp;If the result is a value from 0FF8H through 0FFFH, the file has no
<br>
&nbsp; &nbsp; &nbsp;more clusters. Otherwise, the result is the number of the next cluster
<br>
&nbsp; &nbsp; &nbsp;in the file.
<br>
<br>
&nbsp;On disks with at least 4087 clusters formatted under MS-DOS version 3.0 or
<br>
&nbsp;later, the FAT entries use 16 bits, and the extraction of a cluster number
<br>
&nbsp;from the table is much simpler:
<br>
<br>
&nbsp;1. &nbsp;Use the directory entry to find the starting cluster of the file in
<br>
&nbsp; &nbsp; &nbsp;question.
<br>
<br>
&nbsp;2. &nbsp;Multiply the cluster number by 2.
<br>
<br>
&nbsp;3. &nbsp;Use the product as the offset into the FAT and move the word at that
<br>
&nbsp; &nbsp; &nbsp;offset into a register.
<br>
<br>
&nbsp;4. &nbsp;If the result is a value from 0FFF8H through 0FFFFH, the file has no
<br>
&nbsp; &nbsp; &nbsp;more clusters. Otherwise, the result is the number of the next cluster
<br>
&nbsp; &nbsp; &nbsp;in the file.
<br>
<br>
&nbsp;To convert cluster numbers to logical sectors, subtract 2, multiply the
<br>
&nbsp;result by the number of sectors per cluster, and add the logical-sector
<br>
&nbsp;number of the beginning of the data area (this can be calculated from the
<br>
&nbsp;information in the BPB).
<br>
<br>
&nbsp;As an example, let's work out the disk location of the file IBMBIO.COM,
<br>
&nbsp;which is the first entry in the directory shown in Figure 10-6. First, we
<br>
&nbsp;need some information from the BPB, which is in the boot sector of the
<br>
&nbsp;medium. (See Figures 10-3 and 10-4.) The BPB tells us that there are
<br>
<br>
&nbsp;■ &nbsp;512 bytes per sector
<br>
<br>
&nbsp;■ &nbsp;2 sectors per cluster
<br>
<br>
&nbsp;■ &nbsp;2 sectors per FAT
<br>
<br>
&nbsp;■ &nbsp;2 FATs
<br>
<br>
&nbsp;■ &nbsp;112 entries in the root directory
<br>
<br>
&nbsp;From the BPB information, we can calculate the starting logical-sector
<br>
&nbsp;number of each of the disk's control areas and the files area by
<br>
&nbsp;constructing a table, as follows:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Length &nbsp; &nbsp; &nbsp; Sector
<br>
&nbsp;Area &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sectors) &nbsp; &nbsp;numbers
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Boot sector &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H
<br>
&nbsp;2 FATs * 2 sectors/FAT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H─04H
<br>
&nbsp;112 directory entries &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H─0BH
<br>
&nbsp; &nbsp;*32 bytes/entry
<br>
&nbsp; &nbsp;/512 bytes/sector
<br>
&nbsp;Total sectors occupied by bootstrap, FATs, and &nbsp; 12
<br>
&nbsp;root directory
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Therefore, the first sector of the files area is 12 (0CH).
<br>
<br>
&nbsp;The word at offset 01AH in the directory entry for IBMBIO.COM gives us the
<br>
&nbsp;starting cluster number for that file: cluster 2. To find the
<br>
&nbsp;logical-sector number of the first block in the file, we can follow the
<br>
&nbsp;procedure given earlier:
<br>
<br>
&nbsp;1. &nbsp;Cluster number - 2 = 2 - 2 = 0.
<br>
<br>
&nbsp;2. &nbsp;Multiply by sectors per cluster = 0 * 2 = 0.
<br>
<br>
&nbsp;3. &nbsp;Add logical-sector number of start of the files area = 0 + 0CH = 0CH.
<br>
<br>
&nbsp;So the calculated sector number of the beginning of the file IBMBIO.COM is
<br>
&nbsp;0CH, which is exactly what we expect knowing that the FORMAT program
<br>
&nbsp;always places the system files in contiguous sectors at the beginning of
<br>
&nbsp;the data area.
<br>
<br>
&nbsp;Now let's trace IBMBIO.COM's chain through the file allocation table
<br>
&nbsp;(Figures 10-9 and 10-10). This will be a little tedious, but a detailed
<br>
&nbsp;understanding of the process is crucial. In an actual program, we would
<br>
&nbsp;first read the boot sector using Int 25H, then calculate the address of
<br>
&nbsp;the FAT from the contents of the BPB, and finally read the FAT into
<br>
&nbsp;memory, again using Int 25H.
<br>
<br>
&nbsp;From IBMBIO.COM's directory entry, we already know that the first cluster
<br>
&nbsp;in the file is cluster 2. To examine that cluster's entry in the FAT, we
<br>
&nbsp;multiply the cluster number by 1.5, which gives 0003H as the FAT offset,
<br>
&nbsp;and fetch the word at that offset (which contains 4003H). Because the
<br>
&nbsp;product of the cluster and 1.5 is a whole number, we AND the word from the
<br>
&nbsp;FAT with 0FFFH, yielding the number 3, which is the number of the second
<br>
&nbsp;cluster assigned to the file.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;8 &nbsp;9 &nbsp;A &nbsp;B &nbsp;C &nbsp;D &nbsp;E &nbsp;F
<br>
&nbsp;0000 &nbsp;FD FF FF 03 40 00 05 60 00 07 80 00 09 A0 00 0B &nbsp;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7658585858365858">[email&#160;protected]</a>'........
<br>
&nbsp;0010 &nbsp;C0 00 0D E0 00 0F 00 01 11 20 01 13 40 01 15 60 &nbsp;......... <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e7c9c9a7c9c9">[email&#160;protected]</a>'
<br>
&nbsp;0020 &nbsp;01 17 F0 FF 19 A0 01 1B C0 01 1D E0 01 1F 00 02 &nbsp;................
<br>
&nbsp;0030 &nbsp;21 20 02 23 40 02 25 60 02 27 80 02 29 A0 02 2B &nbsp;! .#@.%'.'..)..+
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 10-9. &nbsp;Hex dump of the first block of the file allocation table
<br>
&nbsp;(track 0, head 0, sector 2) for the PC-DOS 3.3 disk whose root directory
<br>
&nbsp;is shown in Figure 10-6. Notice that the first byte of the FAT contains
<br>
&nbsp;the media descriptor byte for a 5.25-inch, 2-sided, 9-sector floppy disk.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;getfat &nbsp; &nbsp;proc &nbsp; &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp;; extracts the FAT field
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; for a given cluster
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call &nbsp; &nbsp;AX = cluster #
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp;DS:BX = addr of FAT
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns AX = FAT field
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; other registers unchanged
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp; &nbsp;bx &nbsp; &nbsp; &nbsp; &nbsp;; save affected registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp; &nbsp;cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; &nbsp; cx,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shl &nbsp; &nbsp; &nbsp; ax,1 &nbsp; &nbsp; &nbsp;; cluster * 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; &nbsp; ax,cx &nbsp; &nbsp; ; cluster * 3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;test &nbsp; &nbsp; &nbsp;ax,1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pushf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save remainder in Z flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; &nbsp; ax,1 &nbsp; &nbsp; &nbsp;; cluster * 1.5
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; &nbsp; bx,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; &nbsp; ax,[bx]
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;popf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; was cluster * 1.5 whole number?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; &nbsp; getfat1 &nbsp; ; no, jump
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; &nbsp; ax,0fffh &nbsp;; yes, isolate bottom 12 bits
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; &nbsp; getfat2
<br>
&nbsp;getfat1: &nbsp;mov &nbsp; &nbsp; &nbsp; cx,4 &nbsp; &nbsp; &nbsp;; shift word right 4 bits
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; &nbsp; ax,cx
<br>
&nbsp;getfat2: &nbsp;pop &nbsp; &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp;; restore registers and exit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; &nbsp; bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
&nbsp;getfat &nbsp; &nbsp;endp
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 10-10. &nbsp;Assembly-language procedure to access the file allocation
<br>
&nbsp;table (assumes 12-bit FAT fields). Given a cluster number, the procedure
<br>
&nbsp;returns the contents of that cluster's FAT entry in the AX register. This
<br>
&nbsp;simple example ignores the fact that FAT entries can span sector
<br>
&nbsp;boundaries.
<br>
<br>
&nbsp;To examine cluster 3's entry in the FAT, we multiply 3 by 1.5, which gives
<br>
 &nbsp;4.5, and fetch the word at offset 0004H (which contains 0040H). Because
<br>
&nbsp;the product of 3 and 1.5 is not a whole number, we shift the word right
<br>
&nbsp;4 bits, yielding the number 4, which is the number of the third cluster
<br>
&nbsp;assigned to IBMBIO.COM.
<br>
<br>
&nbsp;In this manner, we can follow the chain through the FAT until we come to a
<br>
&nbsp;cluster (number 23, in this case) whose FAT entry contains the value
<br>
&nbsp;0FFFH, which is an end-of-file marker in FATs with 12-bit entries.
<br>
<br>
&nbsp;We have now established that the file IBMBIO.COM contains clusters 2
<br>
&nbsp;through 23 (02H─17H), from which we can calculate that logical sectors 0CH
<br>
&nbsp;through 38H are assigned to the file. Of course, the last cluster may be
<br>
&nbsp;only partially filled with actual data; the portion of the last cluster
<br>
&nbsp;used is the remainder of the file's size in bytes (found in the directory
<br>
&nbsp;entry) divided by the bytes per cluster.
<br>
<br>
<br>
Fixed-Disk Partitions
<br>
<br>
&nbsp;Fixed disks have another layer of organization beyond the logical volume
<br>
&nbsp;structure already discussed: partitions. The FDISK utility divides a fixed
<br>
&nbsp;disk into one or more partitions consisting of an integral number of
<br>
&nbsp;cylinders. Each partition can contain an independent file system and, for
<br>
&nbsp;that matter, its own copy of an operating system.
<br>
<br>
&nbsp;The first physical sector on a fixed disk (track 0, head 0, sector 1)
<br>
&nbsp;contains the master boot record, which is laid out as follows:
<br>
<br>
&nbsp;Bytes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contents
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;000─1BDH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved
<br>
&nbsp;1BE─1CDH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Partition #1 descriptor
<br>
&nbsp;1CE─1DDH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Partition #2 descriptor
<br>
&nbsp;1DE─1EDH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Partition #3 descriptor
<br>
&nbsp;1EE─1FDH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Partition #4 descriptor
<br>
&nbsp;1FE─1FFH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Signature word (AA55H)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The partition descriptors in the master boot record define the size,
<br>
&nbsp;location, and type of each partition, as follows:
<br>
<br>
&nbsp;Byte(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contents
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Active flag (0 = not bootable, 80H = bootable)
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Starting head
<br>
&nbsp;02H─03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Starting cylinder/sector
<br>
&nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Partition type
<br>
&nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;not used
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FAT file system, 12-bit FAT entries
<br>
&nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FAT file system, 16-bit FAT entries
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;extended partition
<br>
&nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;huge partition&quot; (MS-DOS versions 4.0 and later)
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Ending head
<br>
&nbsp;06H─07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Ending cylinder/sector
<br>
&nbsp;08H─0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Starting sector for partition, relative to beginning of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; disk
<br>
&nbsp;0CH─0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Partition length in sectorsThe active flag, which
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indicates that the partition is bootable, can be set on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; only one partition at a time.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;MS-DOS treats partition types 1, 4, and 6 as normal logical volumes and
<br>
&nbsp;assigns them their own drive identifiers during the system boot process.
<br>
&nbsp;Partition type 5 can contain multiple logical volumes and has a special
<br>
&nbsp;extended boot record that describes each volume. The FORMAT utility
<br>
&nbsp;initializes MS-DOS fixed-disk partitions, creating the file system within
<br>
&nbsp;the partition (boot record, file allocation table, root directory, and
<br>
&nbsp;files area) and optionally placing a bootable copy of the operating system
<br>
&nbsp;in the file system.
<br>
<br>
&nbsp;Figure 10-11 contains a partial hex dump of a master block from a fixed
<br>
&nbsp;disk formatted under PC-DOS version 3.3. This dump illustrates the
<br>
&nbsp;partition descriptors for a normal partition with a 16-bit FAT and an
<br>
&nbsp;extended partition.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0000 &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; .
<br>
&nbsp;0180 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<br>
&nbsp;0190 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<br>
&nbsp;01A0 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<br>
&nbsp;01B0 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 01
<br>
&nbsp;01C0 &nbsp;01 00 04 04 D1 02 11 00 00 00 EE FF 00 00 00 00
<br>
&nbsp;01D0 &nbsp;C1 04 05 04 D1 FD 54 00 01 00 02 53 00 00 00 00
<br>
&nbsp;01E0 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<br>
&nbsp;01F0 &nbsp;00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 AA
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 10-11. &nbsp;A partial hex dump of a master block from a fixed disk
<br>
&nbsp;formatted under PC-DOS version 3.3. This disk contains two partitions. The
<br>
&nbsp;first partition has a 16-bit FAT and is marked &quot;active&quot; to indicate that
<br>
&nbsp;it contains a bootable copy of PC-DOS. The second partition is an
<br>
&nbsp;&quot;extended&quot; partition. The third and fourth partition entries are not used
<br>
&nbsp;in this example.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 11 &nbsp;Memory Management
<br>
<br>
&nbsp;Current versions of MS-DOS can manage as much as 1 megabyte of contiguous
<br>
&nbsp;random-access memory. On IBM PCs and compatibles, the memory occupied by
<br>
&nbsp;MS-DOS and other programs starts at address 0000H and may reach as high as
<br>
&nbsp;address 09FFFFH; this 640 KB area of RAM is sometimes referred to as
<br>
&nbsp;conventional memory. Memory above this address is reserved for ROM
<br>
&nbsp;hardware drivers, video refresh buffers, and the like. Computers that are
<br>
&nbsp;not IBM compatible may use other memory layouts.
<br>
<br>
&nbsp;The RAM area under the control of MS-DOS is divided into two major
<br>
&nbsp;sections:
<br>
<br>
&nbsp;■ &nbsp;The operating-system area
<br>
<br>
&nbsp;■ &nbsp;The transient-program area
<br>
<br>
&nbsp;The operating-system area starts at address 0000H──that is, it occupies
<br>
&nbsp;the lowest portion of RAM. It holds the interrupt vector table, the
<br>
&nbsp;operating system proper and its tables and buffers, any additional
<br>
&nbsp;installable drivers specified in the CONFIG.SYS file, and the resident
<br>
&nbsp;part of the COMMAND.COM command interpreter. The amount of memory occupied
<br>
&nbsp;by the operating-system area varies with the version of MS-DOS used, the
<br>
&nbsp;number of disk buffers, the size of installed device drivers, and so
<br>
&nbsp;forth.
<br>
<br>
&nbsp;The transient-program area (TPA), sometimes called the memory arena, is
<br>
&nbsp;the remainder of memory above the operating-system area. The memory arena
<br>
&nbsp;is dynamically allocated in blocks called arena entries. Each arena entry
<br>
&nbsp;has a special control structure called an arena header, and all of the
<br>
&nbsp;arena headers are chained together. Three MS-DOS Int 21H functions allow
<br>
&nbsp;programs to allocate, resize, and release blocks of memory from the TPA:
<br>
<br>
&nbsp;Function &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;48H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Allocate memory block.
<br>
&nbsp;49H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Release memory block.
<br>
&nbsp;4AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Resize memory block.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;MS-DOS itself uses these functions when loading a program from disk at the
<br>
&nbsp;request of COMMAND.COM or another program. The EXEC function, which is the
<br>
&nbsp;MS-DOS program loader, calls Int 21H Function 48H to allocate a memory
<br>
&nbsp;block for the loaded program's environment and another for the program
<br>
&nbsp;itself and its program segment prefix. It then reads the program from the
<br>
&nbsp;disk into the assigned memory area. When the program terminates, MS-DOS
<br>
&nbsp;calls Int 21H Function 49H to release all memory owned by the program.
<br>
<br>
&nbsp;Transient programs can also employ the MS-DOS memory-management functions
<br>
&nbsp;to dynamically manage the memory available in the TPA. Proper use of these
<br>
&nbsp;functions is one of the most important criteria of whether a program is
<br>
&nbsp;well behaved under MS-DOS. Well-behaved programs are most likely to be
<br>
&nbsp;portable to future versions of the operating system and least likely to
<br>
&nbsp;cause interference with other processes under multitasking user interfaces
<br>
&nbsp;such as Microsoft Windows.
<br>
<br>
<br>
Using the Memory-Allocation Functions
<br>
<br>
&nbsp;The memory-allocation functions have two common uses:
<br>
<br>
&nbsp;■ &nbsp;To shrink a program's initial memory allocation so that there is enough
<br>
&nbsp; &nbsp; room to load and execute another program under its control.
<br>
<br>
&nbsp;■ &nbsp;To dynamically allocate additional memory required by the program and
<br>
&nbsp; &nbsp; to release the same memory when it is no longer needed.
<br>
<br>
Shrinking the Initial Memory Allocation
<br>
<br>
&nbsp;Although many MS-DOS application programs simply assume they own all
<br>
&nbsp;memory, this assumption is a relic of MS-DOS version 1 (and CP/M), which
<br>
&nbsp;could support only one active process at a time. Well-behaved MS-DOS
<br>
&nbsp;programs take pains to modify only memory that they actually own and to
<br>
&nbsp;release any memory that they don't need.
<br>
<br>
&nbsp;Unfortunately, under current versions of MS-DOS, the amount of memory that
<br>
&nbsp;a program will own is not easily predicted in advance. It turns out that
<br>
&nbsp;the amount of memory allocated to a program when it is first loaded
<br>
&nbsp;depends upon two factors:
<br>
<br>
&nbsp;■ &nbsp;The type of file the program is loaded from
<br>
<br>
&nbsp;■ &nbsp;The amount of memory available in the TPA
<br>
<br>
&nbsp;MS-DOS always allocates all of the largest available memory block in the
<br>
&nbsp;TPA to programs loaded from .COM (memory-image) files. Because .COM
<br>
&nbsp;programs contain no file header that can pass segment and memory-use
<br>
&nbsp;information to MS-DOS, MS-DOS simply assumes the worst case and gives such
<br>
&nbsp;a program everything. MS-DOS will load the program as long as there is an
<br>
&nbsp;available memory block as large as the size of the file plus 256 bytes for
<br>
&nbsp;the PSP and 2 bytes for the stack. The .COM program, when it receives
<br>
&nbsp;control, must determine whether enough memory is available to carry out
<br>
&nbsp;its functions.
<br>
<br>
&nbsp;MS-DOS uses more complicated rules to allocate memory to programs loaded
<br>
&nbsp;from .EXE files. First, of course, a memory block large enough to hold the
<br>
&nbsp;declared code, data, and stack segments must be available in the TPA. In
<br>
&nbsp;addition, the linker sets two fields in a .EXE file's header to inform
<br>
&nbsp;MS-DOS about the program's memory requirements. The first field,
<br>
&nbsp;MIN_ALLOC, defines the minimum number of paragraphs required by the
<br>
&nbsp;program, in addition to those for the code, data, and stack segments. The
<br>
&nbsp;second, MAX_ALLOC, defines the maximum number of paragraphs of additional
<br>
&nbsp;memory the program would use if they were available.
<br>
<br>
&nbsp;When loading a .EXE file, MS-DOS first attempts to allocate the number of
<br>
&nbsp;paragraphs in MAX_ALLOC plus the number of paragraphs required by the
<br>
&nbsp;program itself. If that much memory is not available, MS-DOS assigns all
<br>
&nbsp;of the largest available block to the program, provided that this is at
<br>
&nbsp;least the amount specified by MIN_ALLOC plus the size of the program
<br>
&nbsp;image. If that condition is not satisfied, the program cannot be executed.
<br>
<br>
&nbsp;After a .COM or .EXE program is loaded and running, it can use Int 21H
<br>
&nbsp;Function 4AH (Resize Memory Block) to release all the memory it does not
<br>
&nbsp;immediately need. This is conveniently done right after the program
<br>
&nbsp;receives control from MS-DOS, by calling the resize function with the
<br>
&nbsp;segment of the program's PSP in the ES register and the number of
<br>
&nbsp;paragraphs that the program requires to run in the BX register (Figure
<br>
&nbsp;11-1).
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;org &nbsp; &nbsp; 100h
<br>
<br>
&nbsp;main &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; entry point from MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS, ES = PSP address
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; sp,offset stk &nbsp; ; COM program must move
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; stack to safe area
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; release extra memory...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 4Ah =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; resize memory block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; BX = paragraphs to keep
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,(offset stk - offset main + 10FH) / 16
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if resize failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;main &nbsp; &nbsp;endp
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;64 dup (?) &nbsp; &nbsp; &nbsp;; new stack area
<br>
&nbsp;stk &nbsp; &nbsp; equ &nbsp; &nbsp; $ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; new base of stack
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end &nbsp; &nbsp; main &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; defines entry point
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 11-1. &nbsp;An example of a .COM program releasing excess memory after
<br>
&nbsp;it receives control from MS-DOS. Int 21H Function 4AH is called with ES
<br>
&nbsp;pointing to the program's PSP and BX containing the number of paragraphs
<br>
&nbsp;that the program needs to execute. In this case, the new size for the
<br>
&nbsp;program's memory block is calculated as the program image size plus the
<br>
&nbsp;size of the PSP (256 bytes), rounded up to the next paragraph. .EXE
<br>
&nbsp;programs use similar code.
<br>
<br>
Dynamic Allocation of Additional Memory
<br>
<br>
&nbsp;When a well-behaved program needs additional memory space──for an I/O
<br>
&nbsp;buffer or an array of intermediate results, for example──it can call Int
<br>
&nbsp;21H Function 48H (Allocate Memory Block) with the desired number of
<br>
&nbsp;paragraphs. If a sufficiently large block of unallocated memory is
<br>
&nbsp;available, MS-DOS returns the segment address of the base of the assigned
<br>
&nbsp;area and clears the carry flag (0), indicating that the function was
<br>
&nbsp;successful.
<br>
<br>
&nbsp;If no unallocated block of sufficient size is available, MS-DOS sets the
<br>
&nbsp;carry flag (1), returns an error code in the AX register, and returns the
<br>
&nbsp;size (in paragraphs) of the largest block available in the BX register
<br>
&nbsp;(Figure 11-2). In this case, no memory has yet been allocated. The
<br>
&nbsp;program can use the value returned in the BX register to determine whether
<br>
&nbsp;it can continue in a &quot;degraded&quot; fashion, with less memory. If it can, it
<br>
&nbsp;must call Int 21H Function 48H again to allocate the smaller memory
<br>
&nbsp;block.
<br>
<br>
&nbsp;When the MS-DOS memory manager is searching the chain of arena headers to
<br>
&nbsp;satisfy a memory-allocation request, it can use one of the following
<br>
&nbsp;strategies:
<br>
<br>
&nbsp;■ &nbsp;First fit: Use the arena entry at the lowest address that is large
<br>
&nbsp; &nbsp; enough to satisfy the request.
<br>
<br>
&nbsp;■ &nbsp;Best fit: Use the smallest arena entry that will satisfy the request,
<br>
&nbsp; &nbsp; regardless of its location.
<br>
<br>
&nbsp;■ &nbsp;Last fit: Use the arena entry at the highest address that is large
<br>
&nbsp; &nbsp; enough to satisfy the request.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; ah,48h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; function 48h = allocate mem block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; bx,0800h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 800h paragraphs = 32 KB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if allocation failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; buff_seg,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save segment of allocated block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; es,buff_seg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ES:DI = address of block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; di,di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; cx,08000h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; store 32,768 bytes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; al,0ffh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; fill buffer with -1s
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cld
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rep &nbsp; stosb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now perform fast fill
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; cx,08000h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; length to write, bytes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; bx,handle &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; handle for prev opened file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; ds,buff_seg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; let DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; dx,0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; restore our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if write failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; es,buff_seg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ES = seg of prev allocated block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; ah,49h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; function 49h = release mem block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if release failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;error: &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;handle &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; file handle
<br>
&nbsp;buff_seg &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; segment of allocated block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 11-2. &nbsp;Example of dynamic memory allocation. The program requests a
<br>
&nbsp;32 KB memory block from MS-DOS, fills it with -1s, writes it to disk, and
<br>
&nbsp;then releases it.
<br>
<br>
&nbsp;If the arena entry selected is larger than the size requested, MS-DOS
<br>
&nbsp;divides it into two parts: one block of the size requested, which is
<br>
&nbsp;assigned to the program that called Int 21H Function 48H, and an unowned
<br>
&nbsp;block containing the remaining memory.
<br>
<br>
&nbsp;The default MS-DOS allocation strategy is first fit. However, under MS-DOS
<br>
&nbsp;versions 3.0 and later, an application program can change the strategy
<br>
&nbsp;with Int 21H Function 58H.
<br>
<br>
&nbsp;When a program is through with an allocated memory block, it should use
<br>
&nbsp;Int 21H Function 49H to release the block. If it does not, MS-DOS will
<br>
&nbsp;automatically release all memory allocations for the program when it
<br>
&nbsp;terminates.
<br>
<br>
<br>
Arena Headers
<br>
<br>
&nbsp;Microsoft has not officially documented the internal structure of arena
<br>
&nbsp;headers for the outside world at present. This is probably to deter
<br>
&nbsp;programmers from trying to manipulate their memory allocations directly
<br>
&nbsp;instead of through the MS-DOS functions provided for that purpose.
<br>
<br>
&nbsp;Arena headers have identical structures in MS-DOS versions 2 and 3. They
<br>
&nbsp;are 16 bytes (one paragraph) and are located immediately before the memory
<br>
&nbsp;area that they control (Figure 11-3). An arena header contains the
<br>
&nbsp;following information:
<br>
<br>
&nbsp;■ &nbsp;A byte signifying whether the header is a member or the last entry in
<br>
&nbsp; &nbsp; the entire chain of such headers
<br>
<br>
&nbsp;■ &nbsp;A word indicating whether the area it controls is available or whether
<br>
&nbsp; &nbsp; it already belongs to a program (if the latter, the word points to the
<br>
&nbsp; &nbsp; program's PSP)
<br>
<br>
&nbsp;■ &nbsp;A word indicating the size (in paragraphs) of the controlled memory
<br>
&nbsp; &nbsp; area (arena entry)
<br>
<br>
&nbsp;MS-DOS inspects the chain of arena headers whenever the program requests a
<br>
&nbsp;memory-block allocation, modification, or release function, or when a
<br>
&nbsp;program is EXEC'd or terminated. If any of the blocks appear to be
<br>
&nbsp;corrupted or if the chain is broken, MS-DOS displays the dreaded message
<br>
<br>
&nbsp;Memory allocation error
<br>
<br>
&nbsp;and halts the system.
<br>
<br>
&nbsp;In the example illustrated in Figure 11-3, COMMAND.COM originally loaded
<br>
&nbsp;PROGRAM1.COM into the TPA and, because it was a .COM file, COMMAND.COM
<br>
&nbsp;allocated it all of the TPA, controlled by arena header #1. PROGRAM1.COM
<br>
&nbsp;then used Int 21H Function 4AH (Resize Memory Block) to shrink its memory
<br>
&nbsp;allocation to the amount it actually needed to run and loaded and executed
<br>
&nbsp;PROGRAM2.EXE with the EXEC function (Int 21H Function 4BH). The EXEC
<br>
&nbsp;function obtained a suitable amount of memory, controlled by arena header
<br>
&nbsp;#2, and loaded PROGRAM2.EXE into it. PROGRAM2.EXE, in turn, needed some
<br>
&nbsp;additional memory to store some intermediate results, so it called Int 21H
<br>
&nbsp;Function 48H (Allocate Memory Block) to obtain the area controlled by
<br>
&nbsp;arena header #3. The highest arena header (#4) controls all of the
<br>
&nbsp;remaining TPA that has not been allocated to any program.
<br>
<br>
&nbsp;┌─────────────────────────────────────────────────┐ Top of RAM
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; Unowned RAM controlled by header #4 &nbsp; &nbsp; &nbsp; │ &nbsp;controlled by MS-DOS
<br>
&nbsp;├─────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Arena header #4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;├─────────────────────────────────────────────────┤
<br>
&nbsp;│ Memory area controlled by header #3; additional │
<br>
&nbsp;│ &nbsp;storage dynamically allocated by PROGRAM2.EXE &nbsp;│
<br>
&nbsp;├─────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Arena header #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;├─────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp;Memory area controlled by header #2, &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; containing PROGRAM2.EXE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;├─────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Arena header #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;├─────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp;Memory area controlled by header #1, &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; containing PROGRAM1.COM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;├─────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Arena header #1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;└─────────────────────────────────────────────────┘ Bottom of transient-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; program area
<br>
<br>
&nbsp;Figure 11-3. &nbsp;An example diagram of MS-DOS arena headers and the
<br>
&nbsp;transient-program area. The environment blocks and their associated
<br>
&nbsp;headers have been omitted from this figure to increase its clarity.
<br>
<br>
<br>
Lotus/Intel/Microsoft Expanded Memory
<br>
<br>
&nbsp;When the IBM Personal Computer and MS-DOS were first released, the 640 KB
<br>
&nbsp;limit that IBM placed on the amount of RAM that could be directly managed
<br>
&nbsp;by MS-DOS seemed almost unimaginably huge. But as MS-DOS has grown in both
<br>
&nbsp;size and capabilities and the popular applications have become more
<br>
&nbsp;powerful, that 640 KB has begun to seem a bit crowded. Although personal
<br>
&nbsp;computers based on the 80286 and 80386 have the potential to manage up to
<br>
&nbsp;16 megabytes of RAM under operating systems such as MS OS/2 and XENIX,
<br>
&nbsp;this is little comfort to the millions of users of 8086/8088-based
<br>
&nbsp;computers and MS-DOS.
<br>
<br>
&nbsp;At the spring COMDEX in 1985, Lotus Development Corporation and Intel
<br>
&nbsp;Corporation jointly announced the Expanded Memory Specification 3.0 (EMS),
<br>
&nbsp;which was designed to head off rapid obsolescence of the older PCs because
<br>
&nbsp;of limited memory. Shortly afterward, Microsoft announced that it would
<br>
&nbsp;support the EMS and would enhance Microsoft Windows to use the memory made
<br>
&nbsp;available by EMS hardware and software. EMS versions 3.2 and 4.0, released
<br>
&nbsp;in fall 1985 and summer 1987, expanded support for multitasking operating
<br>
&nbsp;systems.
<br>
<br>
&nbsp;The LIM EMS (as it is usually known) has been an enormous success. EMS
<br>
&nbsp;memory boards are available from scores of manufacturers, and &quot;EMS-aware&quot;
<br>
&nbsp;software──especially spreadsheets, disk caches, and terminate-and-stay-
<br>
&nbsp;resident utilities──has become the rule rather than the exception.
<br>
<br>
What Is Expanded Memory?
<br>
<br>
&nbsp;The Lotus/Intel/Microsoft Expanded Memory Specification is a functional
<br>
&nbsp;definition of a bank-switched memory-expansion subsystem. It consists of
<br>
&nbsp;hardware expansion modules and a resident driver program specific to those
<br>
&nbsp;modules. In EMS versions 3.0 and 3.2, the expanded memory is made
<br>
&nbsp;available to application software as 16 KB pages mapped into a contiguous
<br>
&nbsp;64 KB area called the page frame, somewhere above the main memory area
<br>
&nbsp;used by MS-DOS/PC-DOS (0─640 KB). The exact location of the page frame is
<br>
&nbsp;user configurable, so it need not conflict with other hardware options. In
<br>
&nbsp;EMS version 4.0, the pages may be mapped anywhere in memory and can have
<br>
&nbsp;sizes other than 16 KB.
<br>
<br>
&nbsp;The EMS provides a uniform means for applications to access as much as 8
<br>
&nbsp;megabytes of memory (32 megabytes in EMS 4.0). The supporting software,
<br>
&nbsp;which is called the Expanded Memory Manager (EMM), provides a
<br>
&nbsp;hardware-independent interface between application software and the
<br>
&nbsp;expanded memory board(s). The EMM is supplied in the form of an
<br>
&nbsp;installable device driver that you link into the MS-DOS/PC-DOS system by
<br>
&nbsp;adding a line to the CONFIG.SYS file on the system boot disk.
<br>
<br>
&nbsp;Internally, the Expanded Memory Manager consists of two major portions,
<br>
&nbsp;which may be referred to as the driver and the manager. The driver portion
<br>
&nbsp;mimics some of the actions of a genuine installable device driver, in that
<br>
&nbsp;it includes initialization and output status functions and a valid device
<br>
&nbsp;header. The second, and major, portion of the EMM is the true interface
<br>
&nbsp;between application software and the expanded-memory hardware. Several
<br>
&nbsp;classes of services are provided:
<br>
<br>
&nbsp;■ &nbsp;Verification of functionality of hardware and software modules
<br>
<br>
&nbsp;■ &nbsp;Allocation of expanded-memory pages
<br>
<br>
&nbsp;■ &nbsp;Mapping of logical pages into the physical page frame
<br>
<br>
&nbsp;■ &nbsp;Deallocation of expanded-memory pages
<br>
<br>
&nbsp;■ &nbsp;Support for multitasking operating systems
<br>
<br>
&nbsp;Application programs communicate with the EMM directly, by means of
<br>
&nbsp;software Int 67H. MS-DOS versions 3.3 and earlier take no part in (and in
<br>
&nbsp;fact are completely oblivious to) any expanded-memory manipulations that
<br>
&nbsp;may occur. MS-DOS version 4.0 and Microsoft Windows, on the other hand,
<br>
&nbsp;are &quot;EMS-aware&quot; and can use the EMS memory when it is available.
<br>
<br>
&nbsp;Expanded memory should not be confused with extended memory. Extended
<br>
&nbsp;memory is the term used by IBM to refer to the memory at physical
<br>
&nbsp;addresses above 1 megabyte that can be accessed by an 80286 or 80386 CPU
<br>
&nbsp;in protected mode. Current versions of MS-DOS run the 80286 and 80386 in
<br>
&nbsp;real mode (8086-emulation mode), and extended memory is therefore not
<br>
&nbsp;directly accessible.
<br>
<br>
Checking for Expanded Memory
<br>
<br>
&nbsp;An application program can use either of two methods to test for the
<br>
&nbsp;existence of the Expanded Memory Manager:
<br>
<br>
&nbsp;■ &nbsp;Issue an open request (Int 21H Function 3DH) using the guaranteed
<br>
&nbsp; &nbsp; device name of the EMM driver: EMMXXXX0. If the open function succeeds,
<br>
&nbsp; &nbsp; either the driver is present or a file with the same name
<br>
&nbsp; &nbsp; coincidentally exists on the default disk drive. To rule out the
<br>
&nbsp; &nbsp; latter, the application can use IOCTL (Int 21H Function 44H)
<br>
&nbsp; &nbsp; subfunctions 00H and 07H to ensure that EMM is present. In either case,
<br>
&nbsp; &nbsp; the application should then use Int 21H Function 3EH to close the
<br>
&nbsp; &nbsp; handle that was obtained from the open function, so that the handle can
<br>
&nbsp; &nbsp; be reused for another file or device.
<br>
<br>
&nbsp;■ &nbsp;Use the address that is found in the Int 67H vector to inspect the
<br>
&nbsp; &nbsp; device header of the presumed EMM. Interrupt handlers and device
<br>
&nbsp; &nbsp; drivers must use this method. If the EMM is present, the name field at
<br>
&nbsp; &nbsp; offset 0AH of the device header contains the string EMMXXXX0. This
<br>
&nbsp; &nbsp; approach is nearly foolproof and avoids the relatively high overhead of
<br>
&nbsp; &nbsp; an MS-DOS open function. However, it is somewhat less well behaved
<br>
&nbsp; &nbsp; because it involves inspection of memory that does not belong to the
<br>
&nbsp; &nbsp; application.
<br>
<br>
&nbsp;These two methods of testing for the existence of the Expanded Memory
<br>
&nbsp;Manager are illustrated in Figures 11-4 and 11-5.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; attempt to &quot;open&quot; EMM...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;dx,seg emm_name ; DS:DX = address of name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ds,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; of Expanded Memory Manager
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;dx,offset emm_name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ax,3d00h &nbsp; &nbsp; &nbsp; &nbsp;; function 3dh, mode = 00h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; = open, read only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if open failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; open succeeded, be sure
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; it was not a file...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;bx,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; BX = handle from open
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ax,4400h &nbsp; &nbsp; &nbsp; &nbsp;; function 44h subfunction 00h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; = IOCTL get device information
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if IOCTL call failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp;dx,80h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bit 7 = 1 if character device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if it was a file
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; EMM is present, be sure
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; it is available...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (BX still contains handle)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ax,4407h &nbsp; &nbsp; &nbsp; &nbsp;; function 44h subfunction 07h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; = IOCTL get output status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if IOCTL call failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; test device status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; if AL = 0 EMM is not available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; now close handle ...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (BX still contains handle)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,3eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 3eh = close
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if close failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;emm_name &nbsp;db &nbsp; 'EMMXXXX0',0 &nbsp; &nbsp;; guaranteed device name for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Expanded Memory Manager
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 11-4. &nbsp;Testing for the Expanded Memory Manager by means of the
<br>
&nbsp;MS-DOS open and IOCTL functions.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;emm_int &nbsp; equ &nbsp;67h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Expanded Memory Manager
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; software interrupt
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; first fetch contents of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; EMM interrupt vector...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;al,emm_int &nbsp; &nbsp; ; AL = EMM int number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,35h &nbsp; &nbsp; &nbsp; &nbsp; ; function 35h = get vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now ES:BX = handler address
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; assume ES:0000 points
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to base of the EMM...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;di,10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ES:DI = address of name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; field in device header
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:SI = EMM driver name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;si,seg emm_name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ds,si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;si,offset emm_name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;cx,8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; length of name field
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cld
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;repz cmpsb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; compare names...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if driver absent
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
&nbsp;emm_name &nbsp;db &nbsp; 'EMMXXXX0' &nbsp; &nbsp; ; guaranteed device name for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Expanded Memory Manager
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 11-5. &nbsp;Testing for the Expanded Memory Manager by inspection of the
<br>
&nbsp;name field in the driver's device header.
<br>
<br>
<br>
Using Expanded Memory
<br>
<br>
&nbsp;After establishing that the memory-manager software is present, the
<br>
&nbsp;application program communicates with it directly by means of the &quot;user
<br>
&nbsp;interrupt&quot; 67H, bypassing MS-DOS/PC-DOS. The calling sequence for the EMM
<br>
&nbsp;is as follows:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,function &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AH determines service type
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; load other registers with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; values specific to the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; requested service
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;67h
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;In general, AH contains the EMM function number, AL holds the subfunction
<br>
&nbsp;number (if any), BX holds a number of pages (if applicable), and DX
<br>
&nbsp;contains an EMM handle. Registers DS:SI and ES:DI are used to pass the
<br>
&nbsp;addresses of arrays or buffers. Section 4 of this book,
<br>
&nbsp;&quot;Lotus/Intel/Microsoft EMS Functions Reference,&quot; details each of the
<br>
&nbsp;expanded memory functions.
<br>
<br>
&nbsp;Upon return from an EMM function, the AH register contains zero if the
<br>
&nbsp;function was successful; otherwise, it contains an error code with the
<br>
&nbsp;most significant bit set (Figures 11-6 and 11-7). Other values are
<br>
&nbsp;typically returned in the AL and BX registers or in a user-specified
<br>
&nbsp;buffer.
<br>
<br>
<br>
&nbsp;Error code &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Function successful.
<br>
<br>
&nbsp;80H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Internal error in Expanded Memory Manager software
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (could be caused by corrupted memory image of driver).
<br>
<br>
&nbsp;81H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Malfunction in expanded-memory hardware.
<br>
<br>
&nbsp;82H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Memory manager busy.
<br>
<br>
&nbsp;83H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Invalid handle.
<br>
<br>
&nbsp;84H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Function requested by application not defined.
<br>
<br>
&nbsp;85H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;No more handles available.
<br>
<br>
&nbsp;86H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Error in save or restore of mapping context.
<br>
<br>
&nbsp;87H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Allocation request specified more logical pages than
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; physically available in system; no pages allocated.
<br>
<br>
&nbsp;88H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Allocation request specified more logical pages than
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currently available in system (request does not exceed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; physical pages that exist, but some are already
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocated to other handles); no pages allocated.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Zero pages; cannot be allocated.
<br>
<br>
&nbsp;8AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Logical page requested to be mapped located outside
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; range of logical pages assigned to handle.
<br>
<br>
&nbsp;8BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Illegal physical page number in mapping request (not in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; range
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0─3).
<br>
<br>
&nbsp;8CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Page-mapping hardware-state save area full.
<br>
<br>
&nbsp;8DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Save of mapping context failed; save area already
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contains context associated with requested handle.
<br>
<br>
&nbsp;8EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Restore of mapping context failed; save area does not
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contain context for requested handle.
<br>
<br>
&nbsp;8FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Subfunction parameter not defined.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 11-6. &nbsp;Expanded Memory Manager error codes common to EMS versions
<br>
&nbsp;3.0, 3.2, and 4.0. After a call to EMM, the AH register contains zero if
<br>
&nbsp;the function was successful or an error code in the range 80H through 8FH
<br>
&nbsp;if the function failed.
<br>
<br>
<br>
&nbsp;Error code &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;90H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Attribute type not defined.
<br>
<br>
&nbsp;91H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Feature not supported.
<br>
<br>
&nbsp;92H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Source and destination memory regions have same handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and overlap; requested move was performed, but part of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; source region was overwritten.
<br>
<br>
&nbsp;93H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Specified length for source or destination memory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; region is longer than actual allocated length.
<br>
<br>
&nbsp;94H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Conventional-memory region and expanded-memory region
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overlap.
<br>
<br>
&nbsp;95H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Specified offset is outside logical page.
<br>
<br>
&nbsp;96H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Region length exceeds 1 MB.
<br>
<br>
&nbsp;97H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Source and destination memory regions have same handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and overlap; exchange cannot be performed.
<br>
<br>
&nbsp;98H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Memory source and destination types undefined.
<br>
<br>
&nbsp;99H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This error code currently unused.
<br>
<br>
&nbsp;9AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Alternate map or DMA register sets supported, but the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alternate register set specified is not supported.
<br>
<br>
&nbsp;9BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Alternate map or DMA register sets supported, but all
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alternate register sets currently allocated.
<br>
<br>
&nbsp;9CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Alternate map or DMA register sets not supported, and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specified alternate register set not zero.
<br>
<br>
&nbsp;9DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Alternate map or DMA register sets supported, but
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alternate register set specified is either not defined
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or not allocated.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dedicated DMA channels not supported.
<br>
<br>
&nbsp;9FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Dedicated DMA channels supported, but specified DMA
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; channel not supported.
<br>
<br>
&nbsp;A0H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;No handle found for specified name.
<br>
<br>
&nbsp;A1H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Handle with this name already exists.
<br>
<br>
&nbsp;A2H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Memory address wrap; sum of the source or destination
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; region base address and length exceeds 1 MB.
<br>
<br>
&nbsp;A3H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Invalid pointer passed to function, or contents of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; source array corrupted.
<br>
<br>
&nbsp;A4H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Access to function denied by operating system.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 11-7. &nbsp;Expanded Memory Manager error codes unique to EMS version
<br>
&nbsp;4.0. Most of these errors are related to the EMS functions for use by
<br>
&nbsp;operating systems and would not normally be encountered by application
<br>
&nbsp;programs.
<br>
<br>
&nbsp;An application program that uses expanded memory should regard that memory
<br>
&nbsp;as a system resource, like a file or a device, and employ only the
<br>
&nbsp;documented EMM services to allocate, access, and release expanded-memory
<br>
&nbsp;pages. Such a program can use the following general strategy:
<br>
<br>
&nbsp;1. &nbsp;Establish the presence of the Expanded Memory Manager by one of the
<br>
&nbsp; &nbsp; &nbsp;two methods demonstrated in Figures 11-4 and 11-5.
<br>
<br>
&nbsp;2. &nbsp;After the driver is known to be present, check its operational status
<br>
&nbsp; &nbsp; &nbsp;with EMS Function 40H.
<br>
<br>
&nbsp;3. &nbsp;Check the version number of EMM with EMS Function 46H, to ensure that
<br>
&nbsp; &nbsp; &nbsp;all services the application will request are available.
<br>
<br>
&nbsp;4. &nbsp;Obtain the segment of the page frame used by EMM with EMS Function
<br>
&nbsp; &nbsp; &nbsp;41H.
<br>
<br>
&nbsp;5. &nbsp;Allocate the desired number of expanded-memory pages with EMS Function
<br>
&nbsp; &nbsp; &nbsp;43H. If the allocation is successful, EMM returns a handle that the
<br>
&nbsp; &nbsp; &nbsp;application can use to refer to the expanded-memory pages that it
<br>
&nbsp; &nbsp; &nbsp;owns. This step is exactly analogous to opening a file and using the
<br>
&nbsp; &nbsp; &nbsp;handle obtained from the open function for read/write operations on
<br>
&nbsp; &nbsp; &nbsp;the file.
<br>
<br>
&nbsp;6. &nbsp;If the requested number of pages are not available, the application
<br>
&nbsp; &nbsp; &nbsp;can query EMM for the actual number of pages available (EMS Function
<br>
&nbsp; &nbsp; &nbsp;42H) and determine whether it can continue.
<br>
<br>
&nbsp;7. &nbsp;After the application has successfully allocated the needed number of
<br>
&nbsp; &nbsp; &nbsp;expanded-memory pages, it uses EMS Function 44H to map logical pages
<br>
&nbsp; &nbsp; &nbsp;in and out of the physical page frame in order to store and retrieve
<br>
&nbsp; &nbsp; &nbsp;data in expanded memory.
<br>
<br>
&nbsp;8. &nbsp;When the program finishes using its expanded-memory pages, it must
<br>
&nbsp; &nbsp; &nbsp;release them by calling EMS Function 45H. Otherwise, the pages will
<br>
&nbsp; &nbsp; &nbsp;be lost to use by other programs until the system is restarted.
<br>
<br>
&nbsp;Figure 11-8 shows a skeleton program that illustrates this general
<br>
&nbsp;approach.
<br>
<br>
&nbsp;An interrupt handler or device driver that uses EMS follows the same
<br>
&nbsp;general procedure outlined in steps 1 through 8, with a few minor
<br>
&nbsp;variations. It may need to acquire an EMS handle and allocate pages before
<br>
&nbsp;the operating system is fully functional; in particular, you cannot assume
<br>
&nbsp;that the MS-DOS Open File or Device, IOCTL, and Get Interrupt Vector
<br>
&nbsp;functions are available. Thus, such a handler or driver must use a
<br>
&nbsp;modified version of the &quot;get interrupt vector&quot; technique (Figure 11-5) to
<br>
&nbsp;test for the existence of EMM, fetching the contents of the Int 67H vector
<br>
&nbsp;directly.
<br>
<br>
&nbsp;A device driver or interrupt handler typically owns its expanded-memory
<br>
&nbsp;pages permanently (until the system is restarted) and never deallocates
<br>
&nbsp;them. Such a program must also take care to save and restore EMM's
<br>
&nbsp;page-mapping context (EMS Functions 47H and 48H) whenever it accesses
<br>
&nbsp;expanded memory, so that use of EMS by a foreground program will not
<br>
&nbsp;be disturbed.
<br>
<br>
&nbsp;The EMM relies on the good behavior of application software to avoid the
<br>
&nbsp;corruption of expanded memory. If several applications that use expanded
<br>
&nbsp;memory are running under a multitasking manager such as Microsoft Windows
<br>
&nbsp;and one or more of them does not abide strictly by EMM conventions, the
<br>
&nbsp;data of some or all of the applications may be destroyed.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,40h &nbsp; &nbsp; &nbsp; &nbsp; ; test EMM status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;67h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; ah,ah
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if bad status from EMM
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,46h &nbsp; &nbsp; &nbsp; &nbsp; ; check EMM version
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;67h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; ah,ah
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if couldn't get version
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp;al,030h &nbsp; &nbsp; &nbsp; &nbsp;; make sure at least ver 3.0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jb &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if wrong EMM version
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,41h &nbsp; &nbsp; &nbsp; &nbsp; ; get page frame segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;67h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; ah,ah
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if failed to get frame
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;page_frame,bx &nbsp;; save segment of page frame
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,42h &nbsp; &nbsp; &nbsp; &nbsp; ; get number of available pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;67h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; ah,ah
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if get pages error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;total_pages,dx ; save total EMM pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;avail_pages,bx ; save available EMM pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; bx,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; abort if no pages available
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,43h &nbsp; &nbsp; &nbsp; &nbsp; ; try to allocate EMM pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;bx,needed_pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;67h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if allocation is successful
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; ah,ah
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if allocation failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;emm_handle,dx &nbsp;; save handle for allocated pages
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; now we are ready for other
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; processing using EMM pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; map in EMS memory page...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;bx,log_page &nbsp; &nbsp;; BX &lt;- EMS logical page number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;al,phys_page &nbsp; ; AL &lt;- EMS physical page (0-3)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;dx,emm_handle &nbsp;; EMM handle for our pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,44h &nbsp; &nbsp; &nbsp; &nbsp; ; function 44h = map EMS page
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;67h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; ah,ah
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if mapping error
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; program ready to terminate,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; give up allocated EMM pages...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;dx,emm_handle &nbsp;; handle for our pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp;ah,45h &nbsp; &nbsp; &nbsp; &nbsp; ; EMS function 45h = release pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp;67h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; ah,ah
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if release failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 11-8. &nbsp;A program illustrating the general strategy for using
<br>
&nbsp;expanded memory.
<br>
<br>
<br>
Extended Memory
<br>
<br>
&nbsp;Extended memory is RAM storage at addresses above 1 megabyte (100000H)
<br>
&nbsp;that can be accessed by an 80286 or 80386 processor running in protected
<br>
&nbsp;mode. IBM PC/AT─ and PS/2─compatible machines can (theoretically) have as
<br>
&nbsp;much as 15 MB of extended memory installed, in addition to the usual 1 MB
<br>
&nbsp;of conventional memory.
<br>
<br>
&nbsp;Protected-mode operating systems such as Microsoft XENIX or MS OS/2 can
<br>
&nbsp;use extended memory for execution of programs. MS-DOS, on the other hand,
<br>
&nbsp;runs in real mode on an 80286 or 80386, and programs running under its
<br>
&nbsp;control cannot ordinarily execute from extended memory or even address
<br>
&nbsp;that memory for storage of data. However, the ROM BIOS contains two
<br>
&nbsp;routines that allow real-mode programs restricted access to extended
<br>
&nbsp;memory:
<br>
<br>
&nbsp;ROM BIOS function &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Int 15H Function 87H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Move extended-memory block.
<br>
&nbsp;Int 15H Function 88H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get extended-memory size.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;These routines can be used by electronic disks (RAMdisks) and by other
<br>
&nbsp;programs that want to use extended memory for fast storage and retrieval
<br>
&nbsp;of information that would otherwise have to be written to a slower
<br>
&nbsp;physical disk drive. Section 3 of this book, &quot;IBM ROM BIOS and Mouse
<br>
&nbsp;Functions Reference,&quot; documents both of these functions.
<br>
<br>
&nbsp;You should use these ROM BIOS routines with caution. Data stored in
<br>
&nbsp;extended memory is, of course, volatile; it is lost if the machine is
<br>
&nbsp;turned off. The transfer of data to or from extended memory involves a
<br>
&nbsp;switch from real mode to protected mode and back, which is a relatively
<br>
&nbsp;slow process on 80286-based machines; in some cases it is only marginally
<br>
&nbsp;faster than actually reading the data from a fixed disk. In addition,
<br>
&nbsp;programs that use the ROM BIOS extended-memory functions are not
<br>
&nbsp;compatible with the MS-DOS compatibility mode of MS OS/2.
<br>
<br>
&nbsp;Finally, a major deficit in these ROM BIOS functions is that they do not
<br>
&nbsp;make any attempt to arbitrate between two or more programs or drivers that
<br>
&nbsp;are using extended memory for temporary storage. For example, if an
<br>
&nbsp;application program and an installed RAMdisk driver attempt to put data in
<br>
&nbsp;the same area of extended memory, no error will be returned to either
<br>
&nbsp;program, but the data of one or both may be destroyed.
<br>
<br>
&nbsp;Figure 11-9 shows an example of the code necessary to transfer data to
<br>
&nbsp;and from extended memory.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;bmdt &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;30h dup (0) &nbsp; &nbsp; ; block move descriptor table
<br>
<br>
&nbsp;buff1 &nbsp; db &nbsp; &nbsp; &nbsp;80h dup ('?') &nbsp; ; source buffer
<br>
&nbsp;buff2 &nbsp; db &nbsp; &nbsp; &nbsp;80h dup (0) &nbsp; &nbsp; ; destination buffer
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; copy 'buff1' to extended-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; memory address 100000h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DX:AX = destination
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; extended-memory address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,seg buff1 &nbsp; &nbsp;; DS:BX = source conventional-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; memory address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset buff1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,80h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = bytes to move
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,seg bmdt &nbsp; &nbsp; ; ES:SI = block move
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,si &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; descriptor table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset bmdt
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;putblk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; request transfer
<br>
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; fill buff2 from extended-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; memory address 100000h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DX:AX = source extended-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; memory address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,seg buff2 &nbsp; &nbsp;; DS:BX = destination
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; conventional-memory address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset buff2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,80h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = bytes to move
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,seg bmdt &nbsp; &nbsp; ; ES:SI = block move
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,si &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; descriptor table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset bmdt
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;getblk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; request transfer
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;getblk &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer block from extended
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; memory to real memory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DX:AX = source linear 32-bit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; extended-memory address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:BX = segment and offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; destination address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX &nbsp; &nbsp;= length in bytes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ES:SI = block move descriptor
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AH &nbsp; &nbsp;= 0 if transfer OK
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+10h],cx &nbsp;; store length into descriptors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+18h],cx
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; store access rights bytes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; byte ptr es:[si+15h],93h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; byte ptr es:[si+1dh],93h
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+12h],ax &nbsp;; source extended-memory address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+14h],dl
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert destination segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and offset to linear address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; segment * 16
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,16
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mul &nbsp; &nbsp; dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; ax,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; + offset -&gt; linear address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;adc &nbsp; &nbsp; dx,0
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+1ah],ax &nbsp;; store destination address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+1ch],dl
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; cx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert length to words
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,87h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; int 15h function 87h = block move
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 15h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to ROM BIOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to caller
<br>
<br>
&nbsp;getblk &nbsp;endp
<br>
&nbsp;putblk &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; transfer block from real
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; memory to extended memory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DX:AX = dest linear 32-bit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; extended-memory address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:BX = segment and offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; source address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX &nbsp; &nbsp;= length in bytes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ES:SI = block move descriptor
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AH &nbsp; &nbsp;= 0 if transfer OK
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+10h],cx &nbsp;; store length into descriptors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+18h],cx
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; store access rights bytes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; byte ptr es:[si+15h],93h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; byte ptr es:[si+1dh],93h
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+1ah],ax &nbsp;; store destination extended-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+1ch],dl &nbsp;; memory address
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert source segment and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; offset to linear address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; segment * 16
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,16
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mul &nbsp; &nbsp; dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; ax,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; + offset -&gt; linear address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;adc &nbsp; &nbsp; dx,0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+12h],ax &nbsp;; store source address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[si+14h],dl
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; cx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert length to words
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,87h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; int 15h function 87h = block move
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 15h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to ROM BIOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to caller
<br>
<br>
&nbsp;putblk &nbsp;endp
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 11-9. &nbsp;Moving blocks of data between conventional memory and
<br>
&nbsp;extended memory, using the ROM BIOS extended-memory functions. For
<br>
&nbsp;additional information on the format of the block move descriptor table,
<br>
&nbsp;see the entry for Int 15H Function 87H in Section 3 of this book, &quot;IBM
<br>
&nbsp;ROM BIOS and Mouse Functions Reference.&quot; Note that you must specify the
<br>
&nbsp;extended-memory address as a 32-bit linear address rather than as a
<br>
&nbsp;segment and offset.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 12 &nbsp;The EXEC Function
<br>
<br>
&nbsp;The MS-DOS EXEC function (Int 21H Function 4BH) allows a program (called
<br>
&nbsp;the parent) to load any other program (called the child) from a storage
<br>
&nbsp;device, execute it, and then regain control when the child program is
<br>
&nbsp;finished.
<br>
<br>
&nbsp;A parent program can pass information to the child in a command line, in
<br>
&nbsp;default file control blocks, and by means of a set of strings called the
<br>
&nbsp;environment block (discussed later in this chapter). All files or devices
<br>
&nbsp;that the parent opened using the handle file-management functions are
<br>
&nbsp;duplicated in the newly created child task; that is, the child inherits
<br>
&nbsp;all the active handles of the parent task. Any file operations on those
<br>
&nbsp;handles by the child, such as seeks or file I/O, also affect the file
<br>
&nbsp;pointers associated with the parent's handles.
<br>
<br>
&nbsp;MS-DOS suspends execution of the parent program until the child program
<br>
&nbsp;terminates. When the child program finishes its work, it can pass an exit
<br>
&nbsp;code back to the parent, indicating whether it encountered any errors. It
<br>
&nbsp;can also, in turn, load other programs, and so on through many levels of
<br>
&nbsp;control, until the system runs out of memory.
<br>
<br>
&nbsp;The MS-DOS command interpreter, COMMAND.COM, uses the EXEC function to run
<br>
&nbsp;its external commands and other application programs. Many popular
<br>
&nbsp;commercial programs, such as database managers and word processors, use
<br>
&nbsp;EXEC to run other programs (spelling checkers, for example) or to load a
<br>
&nbsp;second copy of COMMAND.COM, thereby allowing the user to list directories
<br>
&nbsp;or copy and rename files without closing all the application files and
<br>
&nbsp;stopping the main work in progress. EXEC can also be used to load program
<br>
&nbsp;overlay segments, although this use is uncommon.
<br>
<br>
<br>
Making Memory Available
<br>
<br>
&nbsp;In order for a parent program to use the EXEC function to load a child
<br>
&nbsp;program, sufficient unallocated memory must be available in the transient
<br>
&nbsp;program area.
<br>
<br>
&nbsp;When the parent itself was loaded, MS-DOS allocated it a variable amount
<br>
&nbsp;of memory, depending upon its original file type──.COM or .EXE──and any
<br>
&nbsp;other information that was available to the loader. (See Chapter 11 for
<br>
&nbsp;further details.) Because the operating system has no foolproof way of
<br>
&nbsp;predicting how much memory any given program will require, it generally
<br>
&nbsp;allocates far more memory to a program than is really necessary.
<br>
<br>
&nbsp;Therefore, a prospective parent program's first action should be to use
<br>
&nbsp;Int 21H Function 4AH (Resize Memory Block) to release any excess memory
<br>
&nbsp;allocation of its own to MS-DOS. In this case, the program should call Int
<br>
&nbsp;21H Function 4AH with the ES register pointing to the program segment
<br>
&nbsp;prefix of the program releasing memory and the BX register containing the
<br>
&nbsp;number of paragraphs of memory to retain for that program. (See Figure
<br>
&nbsp;11-1 for an example.)
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;WARNING
<br>
&nbsp; &nbsp;A .COM program must move its stack to a safe area if it is reducing its
<br>
&nbsp; &nbsp;memory allocation to less than 64 KB.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
Requesting the EXEC Function
<br>
<br>
&nbsp;To load and execute a child program, the parent must execute an Int 21H
<br>
&nbsp;with the registers set up as follows:
<br>
<br>
&nbsp; &nbsp;AH = 4BH
<br>
&nbsp; &nbsp;AL = 00H (subfunction to load child program)
<br>
&nbsp; &nbsp;DS:DX = segment:offset of pathname for child program
<br>
&nbsp; &nbsp;ES:BX = segment:offset of parameter block
<br>
<br>
&nbsp;The parameter block, in turn, contains addresses of other information
<br>
&nbsp;needed by the EXEC function.
<br>
<br>
The Program Name
<br>
<br>
&nbsp;The name of the program to be run, which the calling program provides to
<br>
&nbsp;the EXEC function, must be an unambiguous file specification (no wildcard
<br>
&nbsp;characters) and must include an explicit .COM or .EXE extension. If the
<br>
&nbsp;path and disk drive are not supplied in the program name, MS-DOS uses the
<br>
&nbsp;current directory and default disk drive. (The sequential search for .COM,
<br>
&nbsp;.EXE, and .BAT files in all the locations listed in the PATH variable is
<br>
&nbsp;not a function of EXEC, but rather of the internal logic of COMMAND.COM.)
<br>
<br>
&nbsp;You cannot EXEC a batch file directly; instead, you must EXEC a copy of
<br>
&nbsp;COMMAND.COM and pass the name of the batch file in the command tail, along
<br>
&nbsp;with the /C switch.
<br>
<br>
The Parameter Block
<br>
<br>
&nbsp;The parameter block contains the addresses of four data objects:
<br>
<br>
&nbsp;■ &nbsp;The environment block
<br>
<br>
&nbsp;■ &nbsp;The command tail
<br>
<br>
&nbsp;■ &nbsp;Two default file control blocks
<br>
<br>
&nbsp;The space reserved in the parameter block for the address of the
<br>
&nbsp;environment block is only 2 bytes and holds a segment address. The
<br>
&nbsp;remaining three addresses are all double-word addresses; that is, they are
<br>
&nbsp;4 bytes, with the offset in the first 2 bytes and the segment address in
<br>
&nbsp;the last 2 bytes.
<br>
<br>
&nbsp;The Environment Block
<br>
<br>
&nbsp;Each program that the EXEC function loads inherits a data structure called
<br>
&nbsp;an environment block from its parent. The pointer to the segment of the
<br>
&nbsp;block is at offset 002CH in the PSP. The environment block holds certain
<br>
&nbsp;information used by the system's command interpreter (usually COMMAND.COM)
<br>
&nbsp;and may also hold information to be used by transient programs. It has no
<br>
&nbsp;effect on the operation of the operating system proper.
<br>
<br>
&nbsp;If the environment-block pointer in the EXEC parameter block contains
<br>
&nbsp;zero, the child program acquires a copy of the parent program's
<br>
&nbsp;environment block. Alternatively, the parent program can provide a segment
<br>
&nbsp;pointer to a different or expanded environment. The maximum size of the
<br>
&nbsp;environment block is 32 KB, so very large chunks of information can be
<br>
&nbsp;passed between programs by this mechanism.
<br>
<br>
&nbsp;The environment block for any given program is static, implying that if
<br>
&nbsp;more than one generation of child programs is resident in RAM, each one
<br>
&nbsp;will have a distinct and separate copy of the environment block.
<br>
&nbsp;Furthermore, the environment block for a program that terminates and stays
<br>
&nbsp;resident is not updated by subsequent PATH and SET commands.
<br>
<br>
&nbsp;You will find more details about the environment block later in this
<br>
&nbsp;chapter.
<br>
<br>
&nbsp;The Command Tail
<br>
<br>
&nbsp;MS-DOS copies the command tail into the child program's PSP at offset
<br>
&nbsp;0080H, as described in Chapter 3. The information takes the form of a
<br>
&nbsp;count byte, followed by a string of ASCII characters, terminated by a
<br>
&nbsp;carriage return; the carriage return is not included in the count.
<br>
<br>
&nbsp;The command tail can include filenames, switches, or other parameters.
<br>
&nbsp;From the child program's point of view, the command tail should provide
<br>
&nbsp;the same information that would be present if the program had been run by
<br>
&nbsp;a direct user command at the MS-DOS prompt. EXEC ignores any
<br>
&nbsp;I/O-redirection parameters placed in the command tail; the parent program
<br>
&nbsp;must provide for redirection of the standard devices before the EXEC
<br>
&nbsp;call is made.
<br>
<br>
&nbsp;The Default File Control Blocks
<br>
<br>
&nbsp;MS-DOS copies the two default file control blocks pointed to by the EXEC
<br>
&nbsp;parameter block into the child program's PSP at offsets 005CH and 006CH.
<br>
&nbsp;To emulate the function of COMMAND.COM from the child program's point of
<br>
&nbsp;view, the parent program should use Int 21H Function 29H (the system
<br>
&nbsp;parse-filename service) to parse the first two parameters of the command
<br>
&nbsp;tail into the default file control blocks before invoking the EXEC
<br>
&nbsp;function.
<br>
<br>
&nbsp;File control blocks are not much use under MS-DOS versions 2 and 3,
<br>
&nbsp;because they do not support the hierarchical file structure, but some
<br>
&nbsp;application programs do inspect them as a quick way to get at the first
<br>
&nbsp;two switches or other parameters in the command tail. Chapter 8 discusses
<br>
&nbsp;file control blocks in more detail.
<br>
<br>
<br>
Returning from the EXEC Function
<br>
<br>
&nbsp;In MS-DOS version 2, the EXEC function destroys the contents of all
<br>
&nbsp;registers except the code segment (CS) and instruction pointer (IP).
<br>
&nbsp;Therefore, before making the EXEC call, the parent program must push the
<br>
&nbsp;contents of any other registers that are important onto the stack and then
<br>
&nbsp;save the stack segment (SS) and stack pointer (SP) registers in variables.
<br>
&nbsp;Upon return from a successful EXEC call (that is, the child program has
<br>
&nbsp;finished executing), the parent program should reload SS and SP from the
<br>
&nbsp;variables where they were saved and then pop the other saved registers off
<br>
&nbsp;the stack. In MS-DOS versions 3.0 and later, the stack and other registers
<br>
&nbsp;are preserved across the EXEC call in the usual fashion.
<br>
<br>
&nbsp;Finally, the parent can use Int 21H Function 4DH to obtain the
<br>
&nbsp;termination type and return code of the child program.
<br>
<br>
&nbsp;The EXEC function will fail under the following conditions:
<br>
<br>
&nbsp;■ &nbsp;Not enough unallocated memory is available to load and execute the
<br>
&nbsp; &nbsp; requested program file.
<br>
<br>
&nbsp;■ &nbsp;The requested program can't be found on the disk.
<br>
<br>
&nbsp;■ &nbsp;The transient portion of COMMAND.COM in highest RAM (which contains the
<br>
&nbsp; &nbsp; actual loader) has been destroyed and not enough free memory is
<br>
&nbsp; &nbsp; available to reload it (PC-DOS version 2 only).
<br>
<br>
&nbsp;Figure 12-1 summarizes the calling convention for function 4BH. Figure
<br>
&nbsp;12-2 shows a skeleton of a typical EXEC call. This particular example
<br>
&nbsp;uses the EXEC function to load and run the MS-DOS utility CHKDSK.COM. The
<br>
&nbsp;SHELL.ASM program listing later in this chapter (Figure 12-5) presents a
<br>
&nbsp;more complete example that includes the use of Int 21H Function 4AH to
<br>
&nbsp;free unneeded memory.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Called with:
<br>
<br>
&nbsp; &nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 4BH
<br>
&nbsp; &nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = function type
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 00 = load and execute program
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 03 = load overlay
<br>
&nbsp; &nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp;= segment:offset of parameter block
<br>
&nbsp; &nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp;= segment:offset of program specification
<br>
<br>
&nbsp;Returns:
<br>
<br>
&nbsp;If call succeeded
<br>
<br>
&nbsp;Carry flag clear. In MS-DOS version 2, all registers except for CS:IP may
<br>
&nbsp;be destroyed. In MS-DOS versions 3.0 and later, registers are preserved in
<br>
&nbsp;the usual fashion.
<br>
<br>
&nbsp;If call failed
<br>
<br>
&nbsp;Carry flag set and AX = error code.
<br>
<br>
&nbsp;Parameter block format:
<br>
<br>
&nbsp;If AL = 0 (load and execute program)
<br>
<br>
&nbsp; &nbsp;Bytes 0─1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment pointer, environment block
<br>
&nbsp; &nbsp;Bytes 2─3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= offset of command-line tail
<br>
&nbsp; &nbsp;Bytes 4─5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment of command-line tail
<br>
&nbsp; &nbsp;Bytes 6─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= offset of first file control block to be copied
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; into new PSP + 5CH
<br>
&nbsp; &nbsp;Bytes 8─9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment of first file control block
<br>
&nbsp; &nbsp;Bytes 10─11 &nbsp; &nbsp; &nbsp; &nbsp;= offset of second file control block to be copied
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; into new PSP + 6CH
<br>
&nbsp; &nbsp;Bytes 12─13 &nbsp; &nbsp; &nbsp; &nbsp;= segment of second file control block
<br>
<br>
&nbsp;If AL = 3 (load overlay)
<br>
<br>
&nbsp; &nbsp;Bytes 0─1 &nbsp; &nbsp;= segment address where file will be loaded
<br>
&nbsp; &nbsp;Bytes 2─3 &nbsp; &nbsp;= relocation factor to apply to loaded image
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 12-1. &nbsp;Calling convention for the EXEC function (Int 21H Function
<br>
&nbsp;4BH).
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;egu &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; stkseg,ss &nbsp; &nbsp; &nbsp; ; save stack pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; stkptr,sp
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset pname ; DS:DX = program name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset pars &nbsp;; ES:BX = param block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4b00h &nbsp; &nbsp; &nbsp; &nbsp;; function 4bh, subfunction 00h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp;; make our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; addressable again
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,ax
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cli &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (for bug in some 8088s)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ss,stkseg &nbsp; &nbsp; &nbsp; ; restore stack pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; sp,stkptr
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sti &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (for bug in some 8088s)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if EXEC failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;stkseg &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; original SS contents
<br>
&nbsp;stkptr &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; original SP contents
<br>
<br>
&nbsp;pname &nbsp; db &nbsp; &nbsp; &nbsp;'\CHKDSK.COM',0 ; pathname of child program
<br>
<br>
&nbsp;pars &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;envir &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; environment segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;cmdline &nbsp; &nbsp; &nbsp; &nbsp; ; command line for child
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;fcb1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; file control block #1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;fcb2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; file control block #2
<br>
<br>
&nbsp;cmdline db &nbsp; &nbsp; &nbsp;4,' *.*',cr &nbsp; &nbsp; ; command line for child
<br>
<br>
&nbsp;fcb1 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file control block #1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;11 dup ('?')
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0)
<br>
&nbsp;fcb2 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file control block #2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;11 dup (' ')
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0)
<br>
<br>
<br>
&nbsp;envir &nbsp; segment para 'ENVIR' &nbsp; &nbsp;; environment segment
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'PATH=',0 &nbsp; &nbsp; &nbsp; ; empty search path
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; location of COMMAND.COM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'COMSPEC=A:\COMMAND.COM',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; end of environment
<br>
<br>
&nbsp;envir &nbsp; ends
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 12-2. &nbsp;A brief example of the use of the MS-DOS EXEC call, with all
<br>
&nbsp;necessary variables and command blocks. Note the protection of the
<br>
&nbsp;registers for MS-DOS version 2 and the masking of interrupts during
<br>
&nbsp;loading of SS:SP to circumvent a bug in some early 8088 CPUs.
<br>
<br>
<br>
More About the Environment Block
<br>
<br>
&nbsp;The environment block is always paragraph aligned (starts at an address
<br>
&nbsp;that is a multiple of 16 bytes) and contains a series of ASCIIZ strings.
<br>
&nbsp;Each of the strings takes the following form:
<br>
<br>
&nbsp; &nbsp;NAME=PARAMETER
<br>
<br>
&nbsp;An additional zero byte (Figure 12-3) indicates the end of the entire set
<br>
&nbsp;of strings. Under MS-DOS version 3, the block of environment strings and
<br>
&nbsp;the extra zero byte are followed by a word count and the complete drive,
<br>
&nbsp;path, filename, and extension used by EXEC to load the program.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;8 &nbsp;9 &nbsp;A &nbsp;B &nbsp;C &nbsp;D &nbsp;E &nbsp;F 0123456789ABCDEF
<br>
&nbsp;0000 43 4F 4D 53 50 45 43 3D 43 3A 5C 43 4F 4D 4D 41 COMSPEC=C:\COMMA
<br>
&nbsp;0010 4E 44 2E 43 4F 4D 00 50 52 4F 4D 50 54 3D 24 70 NDcom.PROMPT=$p
<br>
&nbsp;0020 24 5F 24 64 20 20 20 24 74 24 68 24 68 24 68 24 $_$d &nbsp; $t$h$h$h$
<br>
&nbsp;0030 68 24 68 24 68 20 24 71 24 71 24 67 00 50 41 54 h$h$h $q$q$g.PAT
<br>
&nbsp;0040 48 3D 43 3A 5C 53 59 53 54 45 4D 3B 43 3A 5C 41 H=C:\SYSTEM;C:\A
<br>
&nbsp;0050 53 4D 3B 43 3A 5C 57 53 3B 43 3A 5C 45 54 48 45 SM;C:\WS;C:\ETHE
<br>
&nbsp;0060 52 4E 45 54 3B 43 3A 5C 46 4F 52 54 48 5C 50 43 RNET;C:\FORTH\PC
<br>
&nbsp;0070 33 31 3B 00 00 01 00 43 3A 5C 46 4F 52 54 48 5C 31;....C:\FORTH\
<br>
&nbsp;0080 50 43 33 31 5C 46 4F 52 54 48 2E 43 4F 4D 00 20 PC31\FORTH.COM.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 12-3. &nbsp;Dump of a typical environment block under MS-DOS version 3.
<br>
&nbsp;This particular example contains the default COMSPEC parameter and two
<br>
&nbsp;relatively complex PATH and PROMPT control strings that were set up by
<br>
&nbsp;entries in the user's AUTOEXEC file. Note the path and file specification
<br>
&nbsp;of the executing program following the double zeros at offset 0073H that
<br>
&nbsp;denote the end of the environment block.
<br>
<br>
&nbsp;Under normal conditions, the environment block inherited by a program will
<br>
&nbsp;contain at least three strings:
<br>
<br>
&nbsp; &nbsp;COMSPEC=variable
<br>
&nbsp; &nbsp;PATH=variable
<br>
&nbsp; &nbsp;PROMPT=variable
<br>
<br>
&nbsp;MS-DOS places these three strings into the environment block at system
<br>
&nbsp;initialization, during the interpretation of SHELL, PATH, and PROMPT
<br>
&nbsp;directives in the CONFIG.SYS and AUTOEXEC.BAT files. The strings tell the
<br>
&nbsp;MS-DOS command interpreter, COMMAND.COM, the location of its executable
<br>
&nbsp;file (to enable it to reload the transient portion), where to search for
<br>
&nbsp;executable external commands or program files, and the format of the user
<br>
&nbsp;prompt.
<br>
<br>
&nbsp;You can add other strings to the environment block, either interactively
<br>
&nbsp;or in batch files, with the SET command. Transient programs can use these
<br>
&nbsp;strings for informational purposes. For example, the Microsoft C Compiler
<br>
&nbsp;looks in the environment block for INCLUDE, LIB, and TMP strings to tell
<br>
&nbsp;it where to find its #include files and library files and where to build
<br>
&nbsp;its temporary working files.
<br>
<br>
<br>
Example Programs: SHELL.C and SHELL.ASM
<br>
<br>
&nbsp;As a practical example of use of the MS-DOS EXEC function, I have included
<br>
&nbsp;a small command interpreter called SHELL, with equivalent Microsoft C
<br>
&nbsp;(Figure 12-4) and Microsoft Macro Assembler (Figure 12-5) source code.
<br>
&nbsp;The source code for the assembly-language version is considerably more
<br>
&nbsp;complex than the code for the C version, but the names and functionality
<br>
&nbsp;of the various procedures are quite parallel.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;SHELL.C &nbsp; &nbsp; Simple extendable command interpreter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for MS-DOS versions 2.0 and later
<br>
<br>
&nbsp; &nbsp; &nbsp;Copyright 1988 Ray Duncan
<br>
<br>
&nbsp; &nbsp; &nbsp;Compile: &nbsp; &nbsp;C&gt;CL SHELL.C
<br>
<br>
&nbsp; &nbsp; &nbsp;Usage: &nbsp; &nbsp; &nbsp;C&gt;SHELL
<br>
&nbsp;*/
<br>
&nbsp;#include &lt;stdio.h&gt;
<br>
&nbsp;#include &lt;process.h&gt;
<br>
&nbsp;#include &lt;stdlib.h&gt;
<br>
&nbsp;#include &lt;signal.h&gt;
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* macro to return number of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elements in a structure &nbsp;*/
<br>
&nbsp;#define dim(x) (sizeof(x) / sizeof(x[0]))
<br>
<br>
&nbsp;unsigned intrinsic(char *); &nbsp; &nbsp; &nbsp; &nbsp; /* function prototypes &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp;void extrinsic(char *);
<br>
&nbsp;void get_cmd(char *);
<br>
&nbsp;void get_comspec(char *);
<br>
&nbsp;void break_handler(void);
<br>
&nbsp;void cls_cmd(void);
<br>
&nbsp;void dos_cmd(void);
<br>
&nbsp;void exit_cmd(void);
<br>
<br>
&nbsp;struct cmd_table { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* intrinsic commands table */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char *cmd_name;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp;(*cmd_fxn)();
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; commands[] =
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &quot;CLS&quot;, &nbsp; cls_cmd,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;DOS&quot;, &nbsp; dos_cmd,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;EXIT&quot;, &nbsp;exit_cmd, };
<br>
<br>
&nbsp;static char com_spec[64]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* COMMAND.COM filespec &nbsp; &nbsp; */
<br>
<br>
&nbsp;main(int argc, char *argv[])
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;char inp_buf[80]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* keyboard input buffer &nbsp; &nbsp;*/
<br>
<br>
&nbsp; &nbsp; &nbsp;get_comspec(com_spec); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* get COMMAND.COM filespec */
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* register new handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for Ctrl-C interrupts &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;if(signal(SIGINT, break_handler) == (int(*)()) -1)
<br>
&nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fputs(&quot;Can't capture Control-C Interrupt&quot;, stderr);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit(1);
<br>
&nbsp; &nbsp; &nbsp;}
<br>
<br>
&nbsp; &nbsp; &nbsp;while(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* main interpreter loop &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;get_cmd(inp_buf); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* get a command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (! intrinsic(inp_buf) ) &nbsp;/* if it's intrinsic,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run its subroutine &nbsp; &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extrinsic(inp_buf); &nbsp; &nbsp; &nbsp;/* else pass to COMMAND.COM */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
<br>
&nbsp;}
<br>
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;Try to match user's command with intrinsic command
<br>
&nbsp; &nbsp; &nbsp;table. If a match is found, run the associated routine
<br>
&nbsp; &nbsp; &nbsp;and return true; else return false.
<br>
&nbsp;*/
<br>
<br>
&nbsp;unsigned intrinsic(char *input_string)
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;int i, j; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* some scratch variables &nbsp; */
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* scan off leading blanks &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;while(*input_string == '\x20') input_string++ ;
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* search command table &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;for(i=0; i &lt; dim(commands); i++)
<br>
&nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;j = strcmp(commands[i].cmd_name, input_string);
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(j == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* if match, run routine &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(*commands[i].cmd_fxn)();
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return(1); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* and return true &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
<br>
&nbsp; &nbsp; &nbsp;}
<br>
&nbsp; &nbsp; &nbsp;return(0); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* no match, return false &nbsp; */
<br>
&nbsp;}
<br>
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;Process an extrinsic command by passing it
<br>
&nbsp; &nbsp; &nbsp;to an EXEC'd copy of COMMAND.COM.
<br>
&nbsp;*/
<br>
<br>
&nbsp;void extrinsic(char *input_string)
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;int status;
<br>
&nbsp; &nbsp; &nbsp;status = system(input_string); &nbsp; &nbsp; &nbsp;/* call EXEC function &nbsp; */
<br>
<br>
&nbsp; &nbsp; &nbsp;if(status) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* if failed, display
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error message &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fputs(&quot;\nEXEC of COMMAND.COM failed\n&quot;, stderr);
<br>
&nbsp;}
<br>
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;Issue prompt, get user's command from standard input,
<br>
&nbsp; &nbsp; &nbsp;fold it to uppercase.
<br>
&nbsp;*/
<br>
<br>
&nbsp;void get_cmd(char *buffer)
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;printf(&quot;\nsh: &quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* display prompt &nbsp; &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;gets(buffer); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* get keyboard entry &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;strupr(buffer); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fold to uppercase &nbsp; &nbsp;*/
<br>
&nbsp;}
<br>
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;Get the full path and file specification for COMMAND.COM
<br>
&nbsp; &nbsp; &nbsp;from the COMSPEC variable in the environment.
<br>
&nbsp;*/
<br>
<br>
&nbsp;void get_comspec(char *buffer)
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;strcpy(buffer, getenv(&quot;COMSPEC&quot;));
<br>
<br>
&nbsp; &nbsp; &nbsp;if(buffer[0] == NULL)
<br>
&nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fputs(&quot;\nNo COMSPEC in environment\n&quot;, stderr);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit(1);
<br>
&nbsp; &nbsp; &nbsp;}
<br>
&nbsp;}
<br>
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;This Ctrl-C handler keeps SHELL from losing control.
<br>
&nbsp; &nbsp; &nbsp;It just reissues the prompt and returns.
<br>
&nbsp;*/
<br>
&nbsp;void break_handler(void)
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;signal(SIGINT, break_handler); &nbsp; &nbsp; &nbsp;/* reset handler &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;printf(&quot;\nsh: &quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* display prompt &nbsp; &nbsp; &nbsp; */
<br>
&nbsp;}
<br>
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;These are the subroutines for the intrinsic commands.
<br>
&nbsp;*/
<br>
<br>
&nbsp;void cls_cmd(void) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* CLS command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;printf(&quot;\033[2J&quot;); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* ANSI escape sequence */
<br>
&nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* to clear screen &nbsp; &nbsp; &nbsp;*/
<br>
<br>
&nbsp;void dos_cmd(void) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* DOS command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;int status;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* run COMMAND.COM &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;status = spawnlp(P_WAIT, com_spec, com_spec, NULL);
<br>
<br>
&nbsp; &nbsp; &nbsp;if (status)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fputs(&quot;\nEXEC of COMMAND.COM failed\n&quot;,stderr);
<br>
&nbsp;}
<br>
<br>
&nbsp;void exit_cmd(void) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* EXIT command &nbsp; &nbsp; &nbsp; &nbsp; */
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;exit(0); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* terminate SHELL &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp;}
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 12-4. &nbsp;SHELL.C: A table-driven command interpreter written in
<br>
&nbsp;Microsoft C.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;shell
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page &nbsp; &nbsp;55,132
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;title &nbsp; SHELL.ASM--simple MS-DOS shell
<br>
&nbsp;;
<br>
&nbsp;; SHELL.ASM &nbsp; &nbsp; Simple extendable command interpreter
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for MS-DOS versions 2.0 and later
<br>
&nbsp;;
<br>
&nbsp;; Copyright 1988 by Ray Duncan
<br>
&nbsp;;
<br>
&nbsp;; Build: &nbsp; &nbsp; &nbsp; &nbsp;C&gt;MASM SHELL;
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C&gt;LINK SHELL;
<br>
&nbsp;;
<br>
&nbsp;; Usage: &nbsp; &nbsp; &nbsp; &nbsp;C&gt;SHELL;
<br>
&nbsp;;
<br>
<br>
&nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard input handle
<br>
&nbsp;stdout &nbsp;equ &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp;stderr &nbsp;equ &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard error handle
<br>
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII linefeed
<br>
&nbsp;blank &nbsp; equ &nbsp; &nbsp; 20h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII blank code
<br>
&nbsp;escape &nbsp;equ &nbsp; &nbsp; 01bh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ASCII escape code
<br>
<br>
&nbsp;_TEXT &nbsp; segment word public 'CODE'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assume &nbsp;cs:_TEXT,ds:_DATA,ss:STACK
<br>
<br>
&nbsp;shell &nbsp; proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; at entry DS = ES = PSP
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; make our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; addressable
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,es:[002ch] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get environment segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; env_seg,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; from PSP and save it
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; release unneeded memory...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ES already = PSP segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,100h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; BX = paragraphs needed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 4ah = resize block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnc &nbsp; &nbsp; shell1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if resize OK
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; resize failed, display
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg1_length &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; error message and exit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; shell4
<br>
<br>
&nbsp;shell1: call &nbsp; &nbsp;get_comspec &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get COMMAND.COM filespec
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnc &nbsp; &nbsp; shell2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if it was found
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; COMSPEC not found in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg3_length &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; environment, display error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; shell4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; message and exit
<br>
&nbsp;shell2: mov &nbsp; &nbsp; dx,offset shell3 &nbsp; &nbsp; &nbsp; &nbsp;; set Ctrl-C vector (int 23h)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,cs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; for this program's handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; DS:DX = handler address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,2523h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 25h = set vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; make our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; addressable again
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,ax
<br>
<br>
&nbsp;shell3: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; main interpreter loop
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;get_cmd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get a command from user
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;intrinsic &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check if intrinsic function
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnc &nbsp; &nbsp; shell3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; yes, it was processed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;extrinsic &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, pass it to COMMAND.COM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; shell3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; then get another command
<br>
<br>
&nbsp;shell4: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; come here if error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stderr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; BX = standard error handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c01h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch = terminate with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code = 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;shell &nbsp; endp
<br>
<br>
<br>
<br>
&nbsp;intrinsic proc &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; decode user entry against
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; the table &quot;COMMANDS&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if match, run the routine,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and return carry = false
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if no match, carry = true
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return carry = true
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset commands &nbsp; &nbsp; &nbsp;; DS:SI = command table
<br>
<br>
&nbsp;intr1: &nbsp;cmp &nbsp; &nbsp; byte ptr [si],0 &nbsp; &nbsp; &nbsp; &nbsp; ; end of table?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;intr7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, end of table found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset inp_buf &nbsp; &nbsp; &nbsp; ; no, let DI = addr of user input
<br>
<br>
&nbsp;intr2: &nbsp;cmp &nbsp; &nbsp; byte ptr [di],blank &nbsp; &nbsp; ; scan off any leading blanks
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; intr3
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; di &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; found blank, go past it
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; intr2
<br>
<br>
&nbsp;intr3: &nbsp;mov &nbsp; &nbsp; al,[si] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; next character from table
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; end of string?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;intr4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, entire string matched
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,[di] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; compare to input character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; intr6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, found mismatch
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; si &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; advance string pointers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; intr3
<br>
<br>
&nbsp;intr4: &nbsp;cmp &nbsp; &nbsp; byte ptr [di],cr &nbsp; &nbsp; &nbsp; &nbsp;; be sure user's entry
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;intr5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is the same length...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr [di],blank &nbsp; &nbsp; ; next character in entry
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; intr6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; must be blank or return
<br>
<br>
&nbsp;intr5: &nbsp;call &nbsp; &nbsp;word ptr [si+1] &nbsp; &nbsp; &nbsp; &nbsp; ; run the command routine
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;clc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return carry flag = false
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; as success flag
<br>
<br>
&nbsp;intr6: &nbsp;lodsb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; look for end of this
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; command string (null byte)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; intr6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; not end yet, loop
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; si,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; skip over routine address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; intr1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; try to match next command
<br>
<br>
&nbsp;intr7: &nbsp;stc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; command not matched, exit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; with carry = true
<br>
<br>
&nbsp;intrinsic endp
<br>
&nbsp;extrinsic proc &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; process extrinsic command
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; by passing it to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; COMMAND.COM with a
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &quot; /C &quot; command tail
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,cr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; find length of command
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,cmd_tail_length &nbsp; &nbsp; &nbsp;; by scanning for carriage
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset cmd_tail+1 &nbsp; &nbsp;; return
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cld
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;repnz scasb
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,di &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; calculate command-tail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub &nbsp; &nbsp; ax,offset cmd_tail+2 &nbsp; &nbsp;; length without carriage
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cmd_tail,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return, and store it
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set command-tail address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr par_cmd,offset cmd_tail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;exec &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and run COMMAND.COM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;extrinsic endp
<br>
<br>
<br>
&nbsp;get_cmd proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; prompt user, get command
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display the shell prompt
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset prompt &nbsp; &nbsp; &nbsp; &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,prompt_length &nbsp; &nbsp; &nbsp; &nbsp;; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; BX = standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get entry from user
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset inp_buf &nbsp; &nbsp; &nbsp; ; DS:DX = input buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,inp_buf_length &nbsp; &nbsp; &nbsp; ; CX = max length to read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard input handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 3fh = read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset inp_buf &nbsp; &nbsp; &nbsp; ; fold lowercase characters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,inp_buf_length &nbsp; &nbsp; &nbsp; ; in entry to uppercase
<br>
&nbsp;gcmd1: &nbsp;cmp &nbsp; &nbsp; byte ptr [si],'a' &nbsp; &nbsp; &nbsp; ; check if 'a-z'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jb &nbsp; &nbsp; &nbsp;gcmd2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, not in range
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr [si],'z' &nbsp; &nbsp; &nbsp; ; check if 'a-z'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ja &nbsp; &nbsp; &nbsp;gcmd2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, not in range
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub &nbsp; &nbsp; byte ptr [si],'a'-'A' &nbsp; ; convert to uppercase
<br>
<br>
&nbsp;gcmd2: &nbsp;inc &nbsp; &nbsp; si &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; advance through entry
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop &nbsp; &nbsp;gcmd1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to caller
<br>
<br>
&nbsp;get_cmd endp
<br>
<br>
<br>
<br>
&nbsp;get_comspec proc near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get location of COMMAND.COM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; from environment &quot;COMSPEC=&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns carry = false
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if COMSPEC found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns carry = true
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if no COMSPEC
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset com_var &nbsp; &nbsp; &nbsp; ; DS:SI = string to match...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;get_env &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; search environment block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;gcsp2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if COMSPEC not found
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ES:DI points past &quot;=&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset com_spec &nbsp; &nbsp; &nbsp;; DS:SI = local buffer
<br>
<br>
&nbsp;gcsp1: &nbsp;mov &nbsp; &nbsp; al,es:[di] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; copy COMSPEC variable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; [si],al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; to local buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; null char? (turns off carry)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; gcsp1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, get next character
<br>
<br>
&nbsp;gcsp2: &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to caller
<br>
<br>
&nbsp;get_comspec endp
<br>
<br>
<br>
&nbsp;get_env proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; search environment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call DS:SI = &quot;NAME=&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; uses contents of &quot;ENV_SEG&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns carry = false and ES:DI
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; pointing to parameter if found,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns carry = true if no match
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,env_seg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get environment segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; di,di &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; initialize env offset
<br>
<br>
&nbsp;genv1: &nbsp;mov &nbsp; &nbsp; bx,si &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; initialize pointer to name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr es:[di],0 &nbsp; &nbsp; &nbsp;; end of environment?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; genv2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, end not found
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no match, return carry set
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;genv2: &nbsp;mov &nbsp; &nbsp; al,[bx] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get character from name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; end of name? (turns off carry)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;genv3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; yes, name matched
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,es:[di] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; compare to environment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; genv4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if match failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; advance environment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; di &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and name pointers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; genv2
<br>
<br>
&nbsp;genv3: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; match found, carry = clear,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ES:DI = variable
<br>
<br>
&nbsp;genv4: &nbsp;xor &nbsp; &nbsp; al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; scan forward in environment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; for zero byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cld
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;repnz &nbsp; scasb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; genv1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; go compare next string
<br>
<br>
&nbsp;get_env endp
<br>
<br>
<br>
&nbsp;exec &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call MS-DOS EXEC function
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to run COMMAND.COM
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; stkseg,ss &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save stack pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; stkptr,sp
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now run COMMAND.COM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset com_spec &nbsp; &nbsp; &nbsp;; DS:DX = filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset par_blk &nbsp; &nbsp; &nbsp; ; ES:BX = parameter block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4b00h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 4bh = EXEC
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; subfunction 0 =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; load and execute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; make data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; addressable again
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,ax
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cli &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (for bug in some 8088s)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ss,stkseg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; restore stack pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; sp,stkptr
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sti &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (for bug in some 8088s)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnc &nbsp; &nbsp; exec1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if no errors
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display error message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg2_length &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stderr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; BX = standard error handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;exec1: &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to caller
<br>
<br>
&nbsp;exec &nbsp; &nbsp;endp
<br>
<br>
<br>
<br>
&nbsp;cls_cmd proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; intrinsic CLS command
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset cls_str &nbsp; &nbsp; &nbsp; ; send the ANSI escape
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,cls_str_length &nbsp; &nbsp; &nbsp; ; sequence to clear
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; the screen
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;cls_cmd endp
<br>
<br>
<br>
&nbsp;dos_cmd proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; intrinsic DOS command
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set null command tail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr par_cmd,offset nultail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;exec &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and run COMMAND.COM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;dos_cmd endp
<br>
&nbsp;exit_cmd proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; intrinsic EXIT command
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call MS-DOS terminate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; function with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code of zero
<br>
&nbsp;exit_cmd endp
<br>
<br>
&nbsp;_TEXT &nbsp; ends
<br>
<br>
<br>
&nbsp;STACK &nbsp; segment para stack 'STACK' &nbsp; &nbsp; &nbsp;; declare stack segment
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;64 dup (?)
<br>
<br>
&nbsp;STACK &nbsp; ends
<br>
<br>
&nbsp;_DATA &nbsp; segment word public 'DATA'
<br>
<br>
&nbsp;commands equ $ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &quot;intrinsic&quot; commands table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; each entry is ASCIIZ string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; followed by the offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; of the procedure to be
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; executed for that command
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'CLS',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;cls_cmd
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DOS',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;dos_cmd
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'EXIT',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;exit_cmd
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; end of table
<br>
<br>
&nbsp;com_var db &nbsp; &nbsp; &nbsp;'COMSPEC=',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; environment variable
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; COMMAND.COM filespec
<br>
&nbsp;com_spec db &nbsp; &nbsp; 80 dup (0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; from environment COMSPEC=
<br>
<br>
&nbsp;nultail db &nbsp; &nbsp; &nbsp;0,cr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; null command tail for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; invoking COMMAND.COM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; as another shell
<br>
<br>
&nbsp;cmd_tail db &nbsp; &nbsp; 0,' /C ' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; command tail for invoking
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; COMMAND.COM as a transient
<br>
&nbsp;inp_buf db &nbsp; &nbsp; &nbsp;80 dup (0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; command line from standard input
<br>
<br>
&nbsp;inp_buf_length equ $-inp_buf
<br>
&nbsp;cmd_tail_length equ $-cmd_tail-1
<br>
<br>
&nbsp;prompt &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf,'sh: ' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; SHELL's user prompt
<br>
&nbsp;prompt_length equ $-prompt
<br>
<br>
&nbsp;env_seg dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; segment of environment block
<br>
<br>
&nbsp;msg1 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Unable to release memory.'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp;msg1_length equ $-msg1
<br>
<br>
&nbsp;msg2 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'EXEC of COMMAND.COM failed.'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp;msg2_length equ $-msg2
<br>
<br>
&nbsp;msg3 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'No COMSPEC variable in environment.'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp;msg3_length equ $-msg3
<br>
<br>
&nbsp;cls_str db &nbsp; &nbsp; &nbsp;escape,'[2J' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ANSI escape sequence
<br>
&nbsp;cls_str_length equ $-cls_str &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to clear the screen
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; EXEC parameter block
<br>
&nbsp;par_blk dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; environment segment
<br>
&nbsp;par_cmd dd &nbsp; &nbsp; &nbsp;cmd_tail &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; command line
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;fcb1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; file control block #1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;fcb2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; file control block #2
<br>
<br>
&nbsp;fcb1 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file control block #1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;11 dup (' ')
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0)
<br>
<br>
&nbsp;fcb2 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file control block #2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;11 dup (' ')
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0)
<br>
<br>
&nbsp;stkseg &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; original SS contents
<br>
&nbsp;stkptr &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; original SP contents
<br>
<br>
&nbsp;_DATA &nbsp; ends
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end &nbsp; &nbsp; shell
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 12-5. &nbsp;SHELL.ASM: A simple table-driven command interpreter written
<br>
&nbsp;in Microsoft Macro Assembler.
<br>
<br>
&nbsp;The SHELL program is table driven and can easily be extended to provide a
<br>
&nbsp;powerful customized user interface for almost any application. When SHELL
<br>
&nbsp;takes control of the system, it displays the prompt
<br>
<br>
&nbsp;sh:
<br>
<br>
&nbsp;and waits for input from the user. After the user types a line terminated
<br>
&nbsp;by a carriage return, SHELL tries to match the first token in the line
<br>
&nbsp;against its table of internal (intrinsic) commands. If it finds a match,
<br>
&nbsp;it calls the appropriate subroutine. If it does not find a match, it calls
<br>
&nbsp;the MS-DOS EXEC function and passes the user's input to COMMAND.COM with
<br>
&nbsp;the /C switch, essentially using COMMAND.COM as a transient command
<br>
&nbsp;processor under its own control.
<br>
<br>
&nbsp;As supplied in these listings, SHELL &quot;knows&quot; exactly three internal
<br>
&nbsp;commands:
<br>
<br>
&nbsp;Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;CLS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Uses the ANSI standard control sequence to clear the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; display screen and home the cursor.
<br>
&nbsp;DOS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Runs a copy of COMMAND.COM.
<br>
&nbsp;EXIT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exits SHELL, returning control of the system to the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next lower command interpreter.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;You can quickly add new intrinsic commands to either the C version or the
<br>
&nbsp;assembly-language version of SHELL. Simply code a procedure with the
<br>
&nbsp;appropriate action and insert the name of that procedure, along with the
<br>
&nbsp;text string that defines the command, into the table COMMANDS. In
<br>
&nbsp;addition, you can easily prevent SHELL from passing certain &quot;dangerous&quot;
<br>
&nbsp;commands (such as MKDIR or ERASE) to COMMAND.COM simply by putting the
<br>
&nbsp;names of the commands to be screened out into the intrinsic command table
<br>
&nbsp;with the address of a subroutine that prints an error message.
<br>
<br>
&nbsp;To summarize, the basic flow of both versions of the SHELL program is
<br>
&nbsp;as follows:
<br>
<br>
&nbsp;1. &nbsp;The program calls MS-DOS Int 21H Function 4AH (Resize Memory Block)
<br>
&nbsp; &nbsp; &nbsp;to shrink its memory allocation, so that the maximum possible space
<br>
&nbsp; &nbsp; &nbsp;will be available for COMMAND.COM if it is run as an overlay. (This is
<br>
&nbsp; &nbsp; &nbsp;explicit in the assembly-language version only. To keep the example
<br>
&nbsp; &nbsp; &nbsp;code simple, the number of paragraphs to be reserved is coded as a
<br>
&nbsp; &nbsp; &nbsp;generous literal value, rather than being figured out at runtime from
<br>
&nbsp; &nbsp; &nbsp;the size and location of the various program segments.)
<br>
<br>
&nbsp;2. &nbsp;The program searches the environment for the COMSPEC variable, which
<br>
&nbsp; &nbsp; &nbsp;defines the location of an executable copy of COMMAND.COM. If it can't
<br>
&nbsp; &nbsp; &nbsp;find the COMSPEC variable, it prints an error message and exits.
<br>
<br>
&nbsp;3. &nbsp;The program puts the address of its own handler in the Ctrl-C vector
<br>
&nbsp; &nbsp; &nbsp;(Int 23H) so that it won't lose control if the user enters a Ctrl-C
<br>
&nbsp; &nbsp; &nbsp;or a Ctrl-Break.
<br>
<br>
&nbsp;4. &nbsp;The program issues a prompt to the standard output device.
<br>
<br>
&nbsp;5. &nbsp;The program reads a buffered line from the standard input device to
<br>
&nbsp; &nbsp; &nbsp;get the user's command.
<br>
<br>
&nbsp;6. &nbsp;The program matches the first blank-delimited token in the line
<br>
&nbsp; &nbsp; &nbsp;against its table of intrinsic commands. If it finds a match, it
<br>
&nbsp; &nbsp; &nbsp;executes the associated procedure.
<br>
<br>
&nbsp;7. &nbsp;If the program does not find a match in the table of intrinsic
<br>
&nbsp; &nbsp; &nbsp;commands, it synthesizes a command-line tail by appending the user's
<br>
&nbsp; &nbsp; &nbsp;input to the /C switch and then EXECs a copy of COMMAND.COM, passing
<br>
&nbsp; &nbsp; &nbsp;the address of the synthesized command tail in the EXEC parameter
<br>
&nbsp; &nbsp; &nbsp;block.
<br>
<br>
&nbsp;8. &nbsp;The program repeats steps 4 through 7 until the user enters the
<br>
&nbsp; &nbsp; &nbsp;command EXIT, which is one of the intrinsic commands, and which causes
<br>
&nbsp; &nbsp; &nbsp;SHELL to terminate execution.
<br>
<br>
&nbsp;In its present form, SHELL allows COMMAND.COM to inherit a full copy of
<br>
&nbsp;the current environment. However, in some applications it may be helpful,
<br>
&nbsp;or safer, to pass a modified copy of the environment block so that the
<br>
&nbsp;secondary copy of COMMAND.COM will not have access to certain information.
<br>
<br>
<br>
Using EXEC to Load Overlays
<br>
<br>
&nbsp;Loading overlays with the EXEC function is much less complex than using
<br>
&nbsp;EXEC to run another program. The overlay can be constructed as either a
<br>
&nbsp;memory image (.COM) or relocatable (.EXE) file and need not be the same
<br>
&nbsp;type as the program that loads it. The main program, called the root
<br>
&nbsp;segment, must carry out the following steps to load and execute an
<br>
&nbsp;overlay:
<br>
<br>
&nbsp;1. &nbsp;Make a memory block available to receive the overlay. The program that
<br>
&nbsp; &nbsp; &nbsp;calls EXEC must own the memory block for the overlay.
<br>
<br>
&nbsp;2. &nbsp;Set up the overlay parameter block to be passed to the EXEC function.
<br>
&nbsp; &nbsp; &nbsp;This block contains the segment address of the block that will receive
<br>
&nbsp; &nbsp; &nbsp;the overlay, plus a segment relocation value to be applied to the
<br>
&nbsp; &nbsp; &nbsp;contents of the overlay file (if it is a .EXE file). These are
<br>
&nbsp; &nbsp; &nbsp;normally the same value.
<br>
<br>
&nbsp;3. &nbsp;Call the MS-DOS EXEC function to load the overlay by issuing an Int
<br>
&nbsp; &nbsp; &nbsp;21H with the registers set up as follows:
<br>
<br>
&nbsp; &nbsp; &nbsp;AH = 4BH
<br>
&nbsp; &nbsp; &nbsp;AL = 03H (EXEC subfunction to load overlay)
<br>
&nbsp; &nbsp; &nbsp;DS:DX = segment:offset of overlay file pathname
<br>
&nbsp; &nbsp; &nbsp;ES:BX = segment:offset of overlay parameter block
<br>
<br>
&nbsp; &nbsp; &nbsp;Upon return from the EXEC function, the carry flag is clear if the
<br>
&nbsp; &nbsp; &nbsp;overlay was found and loaded. The carry flag is set if the file could
<br>
&nbsp; &nbsp; &nbsp;not be found or if some other error occurred.
<br>
<br>
&nbsp;4. &nbsp;Execute the code within the overlay by transferring to it with a far
<br>
&nbsp; &nbsp; &nbsp;call. The overlay should be designed so that either the entry point or
<br>
&nbsp; &nbsp; &nbsp;a pointer to the entry point is at the beginning of the module after
<br>
&nbsp; &nbsp; &nbsp;it is loaded. This technique allows you to maintain the root and
<br>
&nbsp; &nbsp; &nbsp;overlay modules separately, because the root module does not contain
<br>
&nbsp; &nbsp; &nbsp;any &quot;magical&quot; knowledge of addresses within the overlay segment.
<br>
<br>
&nbsp;To prevent users from inadvertently running an overlay directly from the
<br>
&nbsp;command line, you should assign overlay files an extension other than .COM
<br>
&nbsp;or .EXE. It is most convenient to relate overlays to their root segment by
<br>
&nbsp;assigning them the same filename but a different extension, such as .OVL
<br>
&nbsp;or .OV1, .OV2, and so on.
<br>
<br>
&nbsp;Figure 12-6 shows the use of EXEC to load and execute an overlay.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; allocate memory for overlay
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,1000h &nbsp; &nbsp; &nbsp; &nbsp;; get 64 KB (4096 paragraphs)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,48h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 48h = allocate block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if allocation failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; pars,ax &nbsp; &nbsp; &nbsp; &nbsp; ; set load address for overlay
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; pars+2,ax &nbsp; &nbsp; &nbsp; ; set relocation segment for overlay
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set segment of entry point
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr entry+2,ax
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; stkseg,ss &nbsp; &nbsp; &nbsp; ; save root's stack pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; stkptr,sp
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set ES = DS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,ax
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset oname ; DS:DX = overlay pathname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset pars &nbsp;; ES:BX = parameter block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4b03h &nbsp; &nbsp; &nbsp; &nbsp;; function 4bh, subfunction 03h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp;; make our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; addressable again
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,ax
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cli &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (for bug in some early 8088s)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ss,stkseg &nbsp; &nbsp; &nbsp; ; restore stack pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; sp,stkptr
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sti &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (for bug in some early 8088s)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if EXEC failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; otherwise EXEC succeeded...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;dword ptr entry ; now call the overlay
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;oname &nbsp; db &nbsp; &nbsp; &nbsp;'OVERLAY.OVL',0 ; pathname of overlay file
<br>
<br>
&nbsp;pars &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; load address (segment) for file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; relocation (segment) for file
<br>
<br>
&nbsp;entry &nbsp; dd &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; entry point for overlay
<br>
<br>
&nbsp;stkseg &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save SS register
<br>
&nbsp;stkptr &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save SP register
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 12-6. &nbsp;A code skeleton for loading and executing an overlay with
<br>
&nbsp;the EXEC function. The overlay file may be in either .COM or .EXE format.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 13 &nbsp;Interrupt Handlers
<br>
<br>
&nbsp;Interrupts are signals that cause the computer's central processing unit
<br>
&nbsp;to suspend what it is doing and transfer to a program called an interrupt
<br>
&nbsp;handler. Special hardware mechanisms that are designed for maximum speed
<br>
&nbsp;force the transfer. The interrupt handler determines the cause of the
<br>
&nbsp;interrupt, takes the appropriate action, and then returns control to the
<br>
&nbsp;original process that was suspended.
<br>
<br>
&nbsp;Interrupts are typically caused by events external to the central
<br>
&nbsp;processor that require immediate attention, such as the following:
<br>
<br>
&nbsp;■ &nbsp;Completion of an I/O operation
<br>
<br>
&nbsp;■ &nbsp;Detection of a hardware failure
<br>
<br>
&nbsp;■ &nbsp;&quot;Catastrophes&quot; (power failures, for example)
<br>
<br>
&nbsp;In order to service interrupts more efficiently, most modern processors
<br>
&nbsp;support multiple interrupt types, or levels. Each type usually has a
<br>
&nbsp;reserved location in memory, called an interrupt vector, that specifies
<br>
&nbsp;where the interrupt-handler program for that interrupt type is located.
<br>
&nbsp;This design speeds processing of an interrupt because the computer can
<br>
&nbsp;transfer control directly to the appropriate routine; it does not need a
<br>
&nbsp;central routine that wastes precious machine cycles determining the cause
<br>
&nbsp;of the interrupt. The concept of interrupt types also allows interrupts to
<br>
&nbsp;be prioritized, so that if several interrupts occur simultaneously, the
<br>
&nbsp;most important one can be processed first.
<br>
<br>
&nbsp;CPUs that support interrupts must also have the capability to block
<br>
&nbsp;interrupts while they are executing critical sections of code. Sometimes
<br>
&nbsp;the CPU can block interrupt levels selectively, but more frequently the
<br>
&nbsp;effect is global. While an interrupt is being serviced, the CPU masks all
<br>
&nbsp;other interrupts of the same or lower priority until the active handler
<br>
&nbsp;has completed its execution; similarly, it can preempt the execution of a
<br>
&nbsp;handler if a different interrupt with higher priority requires service.
<br>
&nbsp;Some CPUs can even draw a distinction between selectively masking
<br>
&nbsp;interrupts (they are recognized, but their processing is deferred) and
<br>
&nbsp;simply disabling them (the interrupt is thrown away).
<br>
<br>
&nbsp;The creation of interrupt handlers has traditionally been considered one
<br>
&nbsp;of the most arcane of programming tasks, suitable only for the elite cadre
<br>
&nbsp;of system hackers. In reality, writing an interrupt handler is, in itself,
<br>
&nbsp;straightforward. Although the exact procedure must, of course, be
<br>
&nbsp;customized for the characteristics of the particular CPU and operating
<br>
&nbsp;system, the guidelines on the following page are applicable to almost any
<br>
&nbsp;computer system.
<br>
<br>
&nbsp;A program preparing to handle interrupts must do the following:
<br>
<br>
&nbsp;1. &nbsp;Disable interrupts, if they were previously enabled, to prevent them
<br>
&nbsp; &nbsp; &nbsp;from occurring while interrupt vectors are being modified.
<br>
<br>
&nbsp;2. &nbsp;Initialize the vector for the interrupt of interest to point to the
<br>
&nbsp; &nbsp; &nbsp;program's interrupt handler.
<br>
<br>
&nbsp;3. &nbsp;Ensure that, if interrupts were previously disabled, all other vectors
<br>
&nbsp; &nbsp; &nbsp;point to some valid handler routine.
<br>
<br>
&nbsp;4. &nbsp;Enable interrupts again.
<br>
<br>
&nbsp;The interrupt handler itself must follow a simple but rigid sequence of
<br>
&nbsp;steps:
<br>
<br>
&nbsp;1. &nbsp;Save the system context (registers, flags, and anything else that the
<br>
&nbsp; &nbsp; &nbsp;handler will modify and that wasn't saved automatically by the CPU).
<br>
<br>
&nbsp;2. &nbsp;Block any interrupts that might cause interference if they were
<br>
&nbsp; &nbsp; &nbsp;allowed to occur during this handler's processing. (This is often done
<br>
&nbsp; &nbsp; &nbsp;automatically by the computer hardware.)
<br>
<br>
&nbsp;3. &nbsp;Enable any interrupts that should still be allowed to occur during
<br>
&nbsp; &nbsp; &nbsp;this handler's processing.
<br>
<br>
&nbsp;4. &nbsp;Determine the cause of the interrupt.
<br>
<br>
&nbsp;5. &nbsp;Take the appropriate action for the interrupt: receive and store data
<br>
&nbsp; &nbsp; &nbsp;from the serial port, set a flag to indicate the completion of a
<br>
&nbsp; &nbsp; &nbsp;disk-sector transfer, and so forth.
<br>
<br>
&nbsp;6. &nbsp;Restore the system context.
<br>
<br>
&nbsp;7. &nbsp;Reenable any interrupt levels that were blocked during this handler's
<br>
&nbsp; &nbsp; &nbsp;execution.
<br>
<br>
&nbsp;8. &nbsp;Resume execution of the interrupted process.
<br>
<br>
&nbsp;As in writing any other program, the key to success in writing an
<br>
&nbsp;interrupt handler is to program defensively and cover all the bases. The
<br>
&nbsp;main reason interrupt handlers have acquired such a mystical reputation is
<br>
&nbsp;that they are so difficult to debug when they contain obscure errors.
<br>
&nbsp;Because interrupts can occur asynchronously──that is, because they can be
<br>
&nbsp;caused by external events without regard to the state of the currently
<br>
&nbsp;executing process──bugs in interrupt handlers can cause the system as a
<br>
&nbsp;whole to behave quite unpredictably.
<br>
<br>
<br>
Interrupts and the Intel 80x86 Family
<br>
<br>
&nbsp;The Intel 80x86 family of microprocessors supports 256 levels of
<br>
&nbsp;prioritized interrupts, which can be triggered by three types of events:
<br>
<br>
&nbsp;■ &nbsp;Internal hardware interrupts
<br>
<br>
&nbsp;■ &nbsp;External hardware interrupts
<br>
<br>
&nbsp;■ &nbsp;Software interrupts
<br>
<br>
Internal Hardware Interrupts
<br>
<br>
&nbsp;Internal hardware interrupts, sometimes called faults, are generated by
<br>
&nbsp;certain events encountered during program execution, such as an attempt to
<br>
&nbsp;divide by zero. The assignment of such events to certain interrupt numbers
<br>
&nbsp;is wired into the processor and is not modifiable (Figure 13-1).
<br>
<br>
<br>
&nbsp;Interrupt &nbsp;Vector &nbsp; &nbsp;Interrupt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8086/88 &nbsp; &nbsp;80286 &nbsp; &nbsp; 80386
<br>
&nbsp;level &nbsp; &nbsp; &nbsp;address &nbsp; trigger
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp;00H─03H &nbsp; Divide-by-zero &nbsp; &nbsp; &nbsp; x &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp;04H─07H &nbsp; Single step &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp;08H─0BH &nbsp; Nonmaskable &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interrupt (NMI)
<br>
&nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp;0CH─0FH &nbsp; Breakpoint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp;10H─13H &nbsp; Overflow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp;14H─17H &nbsp; BOUND exceeded &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp;18H─1BH &nbsp; Invalid opcode &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp;1CH─1FH &nbsp; Processor extension &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not available
<br>
&nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp;20H─23H &nbsp; Double fault &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp;24H─27H &nbsp; Segment overrun &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp;28H─2BH &nbsp; Invalid task-state &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment
<br>
&nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp;2CH─2FH &nbsp; Segment not present &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp;30H─33H &nbsp; Stack segment &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overrun
<br>
&nbsp;0DH &nbsp; &nbsp; &nbsp; &nbsp;34H─37H &nbsp; General protection &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fault
<br>
&nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp;38H─3BH &nbsp; Page fault &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x
<br>
&nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp;3CH─3FH &nbsp; Reserved
<br>
&nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp;40H─43H &nbsp; Numeric coprocessor &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x &nbsp; &nbsp; &nbsp; &nbsp; x
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error
<br>
&nbsp;11H─1FH &nbsp; &nbsp;44H─7FH &nbsp; Reserved
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 13-1. &nbsp;Internal interrupts (faults) on the Intel 8086/88, 80286,
<br>
&nbsp;and 80386 microprocessors.
<br>
<br>
External Hardware Interrupts
<br>
<br>
&nbsp;External hardware interrupts are triggered by peripheral device
<br>
&nbsp;controllers or by coprocessors such as the 8087/80287. These can be tied
<br>
&nbsp;to either the CPU's nonmaskable-interrupt (NMI) pin or its
<br>
&nbsp;maskable-interrupt (INTR) pin. The NMI line is usually reserved for
<br>
&nbsp;interrupts caused by such catastrophic events as a memory parity error or
<br>
&nbsp;a power failure.
<br>
<br>
&nbsp;Instead of being wired directly to the CPU, the interrupts from external
<br>
&nbsp;devices can be channeled through a device called the Intel 8259A
<br>
&nbsp;Programmable Interrupt Controller (PIC). The CPU controls the PIC through
<br>
&nbsp;a set of I/O ports, and the PIC, in turn, signals the CPU through the INTR
<br>
&nbsp;pin. The PIC allows the interrupts from specific devices to be enabled and
<br>
&nbsp;disabled, and their priorities to be adjusted, under program control.
<br>
<br>
&nbsp;A single PIC can handle only eight levels of interrupts. However, PICs can
<br>
&nbsp;be cascaded together in a treelike structure to handle as many levels as
<br>
&nbsp;desired. For example, 80286- and 80386-based machines with a
<br>
&nbsp;PC/AT-compatible architecture use two PICs wired together to obtain 16
<br>
&nbsp;individually configurable levels of interrupts.
<br>
<br>
&nbsp;INTR interrupts can be globally enabled and disabled with the CPU's STI
<br>
&nbsp;and CLI instructions. As you would expect, these instructions have no
<br>
&nbsp;effect on interrupts received on the CPU's NMI pin.
<br>
<br>
&nbsp;The manufacturer of the computer system and/or the manufacturer of the
<br>
&nbsp;peripheral device assigns external devices to specific 8259A PIC interrupt
<br>
&nbsp;levels. These assignments are realized as physical electrical connections
<br>
&nbsp;and cannot be modified by software.
<br>
<br>
Software Interrupts
<br>
<br>
&nbsp;Any program can trigger software interrupts synchronously simply by
<br>
&nbsp;executing an INT instruction. MS-DOS uses Interrupts 20H through 3FH to
<br>
&nbsp;communicate with its modules and with application programs. (For instance,
<br>
&nbsp;the MS-DOS function dispatcher is reached by executing an Int 21H.) The
<br>
&nbsp;IBM PC ROM BIOS and application software use other interrupts, with either
<br>
&nbsp;higher or lower numbers, for various purposes (Figure 13-2). These
<br>
&nbsp;assignments are simply conventions and are not wired into the hardware in
<br>
&nbsp;any way.
<br>
<br>
<br>
&nbsp;Interrupt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Usage &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Machine
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Divide-by-zero &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Single step &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NMI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Breakpoint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Overflow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS PrintScreen &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOUND exceeded &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invalid opcode &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 80287/80387 not present &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AT, PS/2
<br>
&nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ0 timer tick &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Double fault &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ1 keyboard &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 80287/80387 segment overrun &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AT, PS/2
<br>
&nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ2 reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IRQ2 cascade from slave 8259A PIC &nbsp; &nbsp;AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invalid task-state segment (TSS) &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ3 serial communications (COM2) &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Segment not present &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AT, PS/2
<br>
&nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ4 serial communications (COM1) &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Stack segment overflow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;0DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ5 fixed disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IRQ5 parallel printer (LPT2) &nbsp; &nbsp; &nbsp; &nbsp; AT
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; General protection fault &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ6 floppy disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page fault &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ7 parallel printer (LPT1) &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS video driver &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Numeric coprocessor fault &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AT, PS/2
<br>
&nbsp;11H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS equipment check &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;12H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS conventional-memory size &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp;13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS disk driver &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS communications driver &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS cassette driver &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ROM BIOS I/O system extensions &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS keyboard driver &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;17H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS printer driver &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp;18H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BASIC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp;19H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS bootstrap &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS time of day &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;1BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS Ctrl-Break &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp;1CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS timer tick &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp;1DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS video parameter table &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;1EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS floppy-disk parameters &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp;1FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS font (characters 80H─FFH) &nbsp; PC, AT, PS/2
<br>
&nbsp;20H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS terminate process
<br>
&nbsp;21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS function dispatcher
<br>
&nbsp;22H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS terminate address
<br>
&nbsp;23H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS Ctrl-C handler address
<br>
&nbsp;24H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS critical-error handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address
<br>
&nbsp;25H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS absolute disk read
<br>
&nbsp;26H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS absolute disk write
<br>
&nbsp;27H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS terminate and stay resident
<br>
&nbsp;28H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS idle interrupt
<br>
&nbsp;29H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS reserved
<br>
&nbsp;2AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS network redirector
<br>
&nbsp;2BH─2EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS reserved
<br>
&nbsp;2FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS multiplex interrupt
<br>
&nbsp;30H─3FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS reserved
<br>
&nbsp;40H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS floppy-disk driver (if &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed disk installed)
<br>
&nbsp;41H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS fixed-disk parameters &nbsp; &nbsp; &nbsp; PC
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ROM BIOS fixed-disk parameters &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (drive 0)
<br>
&nbsp;42H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS default video driver (if &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EGA installed)
<br>
&nbsp;43H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EGA, MCGA, VGA character table &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;44H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS font (characters 00H─7FH) &nbsp; PCjr
<br>
&nbsp;46H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS fixed-disk parameters &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (drive 1)
<br>
&nbsp;4AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BIOS alarm handler &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;5AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cluster adapter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT
<br>
&nbsp;5BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used by cluster program &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT
<br>
&nbsp;60H─66H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;User interrupts &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp;67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LIM EMS driver &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;68H─6FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unassigned
<br>
&nbsp;70H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ8 CMOS real-time clock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AT, PS/2
<br>
&nbsp;71H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ9 software diverted to IRQ2 &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;72H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ10 reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;73H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ11 reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;74H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ12 reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IRQ12 mouse &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PS/2
<br>
&nbsp;75H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ13 numeric coprocessor &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AT, PS/2
<br>
&nbsp;76H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ14 fixed-disk controller &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AT, PS/2
<br>
&nbsp;77H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IRQ15 reserved &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AT, PS/2
<br>
&nbsp;78H─7FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unassigned
<br>
&nbsp;80H─F0H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BASIC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC, AT, PS/2
<br>
&nbsp;F1H─FFH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Not used &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC, AT, PS/2
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 13-2. &nbsp;Interrupts with special significance on the IBM PC, PC/AT,
<br>
&nbsp;and PS/2 and compatible computers. Note that the IBM ROM BIOS uses several
<br>
&nbsp;interrupts in the range 00H─1FH, even though they were reserved by Intel
<br>
&nbsp;for CPU faults. IRQ numbers refer to Intel 8259A PIC priority levels.
<br>
<br>
The Interrupt-Vector Table
<br>
<br>
&nbsp;The bottom 1024 bytes of system memory are called the interrupt-vector
<br>
&nbsp;table. Each 4-byte position in the table corresponds to an interrupt type
<br>
&nbsp;(0 through 0FFH) and contains the segment and offset of the interrupt
<br>
&nbsp;handler for that level. Interrupts 0 through 1FH (the lowest levels) are
<br>
&nbsp;used for internal hardware interrupts; MS-DOS uses Interrupts 20H through
<br>
&nbsp;3FH; all the other interrupts are available for use by either external
<br>
&nbsp;hardware devices or system drivers and application software.
<br>
<br>
&nbsp;When an 8259A PIC or other device interrupts the CPU by means of the INTR
<br>
&nbsp;pin, it must also place the interrupt type as an 8-bit number (0 through
<br>
&nbsp;0FFH) on the system bus, where the CPU can find it. The CPU then
<br>
&nbsp;multiplies this number by 4 to find the memory address of the interrupt
<br>
&nbsp;vector to be used.
<br>
<br>
Servicing an Interrupt
<br>
<br>
&nbsp;When the CPU senses an interrupt, it pushes the program status word (which
<br>
&nbsp;defines the various CPU flags), the code segment (CS) register, and the
<br>
&nbsp;instruction pointer (IP) onto the machine stack and disables the interrupt
<br>
&nbsp;system. It then uses the 8-bit number that was jammed onto the system bus
<br>
&nbsp;by the interrupting device to fetch the address of the handler from the
<br>
&nbsp;vector table and resumes execution at that address.
<br>
<br>
&nbsp;Usually the handler immediately reenables the interrupt system (to allow
<br>
&nbsp;higher-priority interrupts to occur), saves any registers it is going to
<br>
&nbsp;use, and then processes the interrupt as quickly as possible. Some
<br>
&nbsp;external devices also require a special acknowledgment signal so that they
<br>
&nbsp;will know the interrupt has been recognized.
<br>
<br>
&nbsp;If the interrupt was funneled through an 8259A PIC, the handler must send
<br>
&nbsp;a special code called end of interrupt (EOI) to the PIC through its
<br>
&nbsp;control port to tell it when interrupt processing is completed. (The EOI
<br>
&nbsp;has no effect on the CPU itself.) Finally, the handler executes the
<br>
&nbsp;special IRET (INTERRUPT RETURN) instruction that restores the original
<br>
&nbsp;state of the CPU flags, the CS register, and the instruction pointer
<br>
&nbsp;(Figure 13-3).
<br>
<br>
&nbsp;Whether an interrupt was triggered by an external device or forced by
<br>
&nbsp;software execution of an INT instruction, there is no discernible
<br>
&nbsp;difference in the system state at the time the interrupt handler receives
<br>
&nbsp;control. This fact is convenient when you are writing and testing external
<br>
&nbsp;interrupt handlers because you can debug them to a large extent simply by
<br>
&nbsp;invoking them with software drivers.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;pic_ctl &nbsp; &nbsp; &nbsp; &nbsp; equ &nbsp;20h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; control port for 8259A
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; interrupt controller
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sti &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; turn interrupts back on,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp;bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp;cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp;dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp;si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp;di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp;bp
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp;ds
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp;es
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; ax,cs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; make local data addressable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; ds,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; do some stuff appropriate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; for this interrupt here
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; al,20h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; send EOI to 8259A PIC
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; dx,pic_ctl
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;out &nbsp; dx,al
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; es &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; restore registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; ds
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; bp
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; resume previous processing
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 13-3. &nbsp;Typical handler for hardware interrupts on the 80x86 family
<br>
&nbsp;of microprocessors. In real life, the interrupt handler would need to save
<br>
&nbsp;and restore only the registers that it actually modified. Also, if the
<br>
&nbsp;handler made extensive use of the machine stack, it would need to save and
<br>
&nbsp;restore the SS and SP registers of the interrupted process and use its own
<br>
&nbsp;local stack.
<br>
<br>
<br>
Interrupt Handlers and MS-DOS
<br>
<br>
&nbsp;The introduction of an interrupt handler into your program brings with it
<br>
&nbsp;considerable hardware dependence. It goes without saying (but I am saying
<br>
&nbsp;it again here anyway) that you should avoid such hardware dependence in
<br>
&nbsp;MS-DOS applications whenever possible, to ensure that your programs will
<br>
&nbsp;be portable to any machine running current versions of MS-DOS and that
<br>
&nbsp;they will run properly under future versions of the operating system.
<br>
<br>
&nbsp;Valid reasons do exist, however, for writing your own interrupt handler
<br>
&nbsp;for use under MS-DOS:
<br>
<br>
&nbsp;■ &nbsp;To supersede the MS-DOS default handler for an internal hardware
<br>
&nbsp; &nbsp; interrupt (such as divide-by-zero, BOUND exceeded, and so forth).
<br>
<br>
&nbsp;■ &nbsp;To supersede the MS-DOS default handler for a defined system exception,
<br>
&nbsp; &nbsp; such as the critical-error handler or Ctrl-C handler.
<br>
<br>
&nbsp;■ &nbsp;To chain your own interrupt handler onto the default system handler for
<br>
&nbsp; &nbsp; a hardware device, so that both the system's actions and your own will
<br>
&nbsp; &nbsp; occur on an interrupt. (A typical example of this is the &quot;clock-tick&quot;
<br>
&nbsp; &nbsp; interrupt.)
<br>
<br>
&nbsp;■ &nbsp;To service interrupts not supported by the default MS-DOS device
<br>
&nbsp; &nbsp; drivers (such as the serial communications port, which can be used at
<br>
&nbsp; &nbsp; much higher speeds with interrupts than with polling).
<br>
<br>
&nbsp;■ &nbsp;To provide a path of communication between a program that terminates
<br>
&nbsp; &nbsp; and stays resident and other application software.
<br>
<br>
&nbsp;MS-DOS provides the following facilities to enable you to install
<br>
&nbsp;well-behaved interrupt handlers in a manner that does not interfere with
<br>
&nbsp;operating-system functions or other interrupt handlers:
<br>
<br>
&nbsp;Function &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Int 21H Function 25H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set interrupt vector.
<br>
&nbsp;Int 21H Function 35H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get interrupt vector.
<br>
&nbsp;Int 21H Function 31H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Terminate and stay resident.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;These functions allow you to examine or modify the contents of the system
<br>
&nbsp;interrupt-vector table and to reserve memory for the use of a handler
<br>
&nbsp;without running afoul of other processes in the system or causing memory
<br>
&nbsp;use conflicts. Section 2 of this book, &quot;MS-DOS Functions Reference,&quot;
<br>
&nbsp;describes each of these functions in detail, with programming examples.
<br>
<br>
&nbsp;Handlers for external hardware interrupts under MS-DOS must operate under
<br>
&nbsp;some fairly severe restrictions:
<br>
<br>
&nbsp;■ &nbsp;Because the current versions of MS-DOS are not reentrant, a hardware
<br>
&nbsp; &nbsp; interrupt handler should never call the MS-DOS functions during the
<br>
&nbsp; &nbsp; actual interrupt processing.
<br>
<br>
&nbsp;■ &nbsp;The handler must reenable interrupts as soon as it gets control, to
<br>
&nbsp; &nbsp; avoid crippling other devices or destroying the accuracy of the system
<br>
&nbsp; &nbsp; clock.
<br>
<br>
&nbsp;■ &nbsp;A program should access the 8259A PIC with great care. The program
<br>
&nbsp; &nbsp; should not access the PIC unless that program is known to be the only
<br>
&nbsp; &nbsp; process in the system concerned with that particular interrupt level.
<br>
&nbsp; &nbsp; And it is vital that the handler issue an end-of-interrupt code to the
<br>
&nbsp; &nbsp; 8259A PIC before performing the IRET; otherwise, the processing of
<br>
&nbsp; &nbsp; further interrupts for that priority level or lower priority levels
<br>
&nbsp; &nbsp; will be blocked.
<br>
<br>
&nbsp;Restrictions on handlers that replace the MS-DOS default handlers for
<br>
&nbsp;internal hardware interrupts or system exceptions (such as Ctrl-C or
<br>
&nbsp;critical errors) are not quite so stringent, but you must still program
<br>
&nbsp;the handlers with extreme care to avoid destroying system tables or
<br>
&nbsp;leaving the operating system in an unstable state.
<br>
<br>
&nbsp;The following are a few rules to keep in mind when you are writing an
<br>
&nbsp;interrupt driver:
<br>
<br>
&nbsp;■ &nbsp;Use Int 21H Function 25H (Set Interrupt Vector) to modify the
<br>
&nbsp; &nbsp; interrupt vector; do not write directly to the interrupt-vector table.
<br>
<br>
&nbsp;■ &nbsp;If your program is not the only process in the system that uses this
<br>
&nbsp; &nbsp; interrupt level, chain back to the previous handler after performing
<br>
&nbsp; &nbsp; your own processing on an interrupt.
<br>
<br>
&nbsp;■ &nbsp;If your program is not going to stay resident, fetch and save the
<br>
&nbsp; &nbsp; current contents of the interrupt vector before modifying it and then
<br>
&nbsp; &nbsp; restore the original contents when your program exits.
<br>
<br>
&nbsp;■ &nbsp;If your program is going to stay resident, use one of the terminate-
<br>
&nbsp; &nbsp; and-stay-resident functions (preferably Int 21H Function 31H) to
<br>
&nbsp; &nbsp; reserve the proper amount of memory for your handler.
<br>
<br>
&nbsp;■ &nbsp;If you are going to process hardware interrupts, keep the time that
<br>
&nbsp; &nbsp; interrupts are disabled and the total length of the service routine to
<br>
&nbsp; &nbsp; an absolute minimum. Remember that even after interrupts are reenabled
<br>
&nbsp; &nbsp; with an STI instruction, interrupts of the same or lower priority
<br>
&nbsp; &nbsp; remain blocked if the interrupt was received through the 8259A PIC.
<br>
<br>
<br>
ZERODIV, an Example Interrupt Handler
<br>
<br>
&nbsp;The listing ZERODIV.ASM (Figure 13-4) illustrates some of the principles
<br>
&nbsp;and guidelines on the previous pages. It is an interrupt handler for the
<br>
&nbsp;divide-by-zero internal interrupt (type 0). ZERODIV is loaded as a .COM
<br>
&nbsp;file (usually by a command in the system's AUTOEXEC file) but makes itself
<br>
&nbsp;permanently resident in memory as long as the system is running.
<br>
<br>
&nbsp;The ZERODIV program has two major portions: the initialization portion and
<br>
&nbsp;the interrupt handler.
<br>
<br>
&nbsp;The initialization procedure (called init in the program listing) is
<br>
&nbsp;executed only once, when the ZERODIV program is executed from the MS-DOS
<br>
&nbsp;level. The init procedure takes over the type 0 interrupt vector, prints a
<br>
&nbsp;sign-on message, then performs a terminate-and-stay-resident exit to
<br>
&nbsp;MS-DOS. This special exit reserves the memory occupied by the ZERODIV
<br>
&nbsp;program, so that it is not overwritten by subsequent application programs.
<br>
<br>
&nbsp;The interrupt handler (called zdiv in the program listing) receives
<br>
&nbsp;control when a divide-by-zero interrupt occurs. The handler preserves all
<br>
&nbsp;registers and then prints a message to the user asking whether to continue
<br>
&nbsp;or to abort the program. We can use the MS-DOS console I/O functions
<br>
&nbsp;within this particular interrupt handler because we can safely presume
<br>
&nbsp;that the application was in control when the interrupt occurred; thus,
<br>
&nbsp;there should be no chance of accidentally making overlapping calls upon
<br>
&nbsp;the operating system.
<br>
<br>
&nbsp;If the user enters a C to continue, the handler simply restores all the
<br>
&nbsp;registers and performs an IRET (INTERRUPT RETURN) to return control to the
<br>
&nbsp;application. (Of course, the results of the divide operation will be
<br>
&nbsp;useless.) If the user enters Q to quit, the handler exits to MS-DOS. Int
<br>
&nbsp;21H Function 4CH is particularly convenient in this case because it
<br>
&nbsp;allows the program to pass a return code and at the same time is the only
<br>
&nbsp;termination function that does not rely on the contents of any of the
<br>
&nbsp;segment registers.
<br>
<br>
&nbsp;For an example of an interrupt handler for external (communications port)
<br>
&nbsp;interrupts, see the TALK terminal-emulator program in Chapter 7. You may
<br>
&nbsp;also want to look again at the discussions of Ctrl-C and critical-error
<br>
&nbsp;exception handlers in Chapters 5 and 8.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name &nbsp; &nbsp; &nbsp;zdivide
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page &nbsp; &nbsp; &nbsp;55,132
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title &nbsp; &nbsp; ZERODIV--Divide-by-zero handler
<br>
<br>
&nbsp;;
<br>
&nbsp;; ZERODIV.ASM--Terminate-and-stay-resident handler
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for divide-by-zero interrupts
<br>
&nbsp;;
<br>
&nbsp;; Copyright 1988 Ray Duncan
<br>
&nbsp;;
<br>
&nbsp;; Build: &nbsp; &nbsp; &nbsp; &nbsp;C&gt;MASM ZERODIV;
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C&gt;LINK ZERODIV;
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C&gt;EXE2BIN ZERODIV.EXE ZERODIV.COM
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C&gt;DEL ZERODIV.EXE
<br>
&nbsp;;
<br>
&nbsp;; Usage: &nbsp; &nbsp; &nbsp; &nbsp;C&gt;ZERODIV
<br>
&nbsp;;
<br>
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII linefeed
<br>
&nbsp;beep &nbsp; &nbsp;equ &nbsp; &nbsp; 07h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII bell code
<br>
&nbsp;backsp &nbsp;equ &nbsp; &nbsp; 08h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII backspace code
<br>
<br>
&nbsp;_TEXT &nbsp; segment word public 'CODE'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;org &nbsp; &nbsp; 100H
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assume &nbsp;cs:_TEXT,ds:_TEXT,es:_TEXT,ss:_TEXT
<br>
<br>
&nbsp;init &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; entry point at load time
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; capture vector for
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; interrupt zero...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset zdiv &nbsp;; DS:DX = handler address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,2500h &nbsp; &nbsp; &nbsp; &nbsp;; function 25h = set vector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; interrupt type = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; print sign-on message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg1 &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 09h = display string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DX = paragraphs to reserve
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,((offset pgm_len+15)/16)+10h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,3100h &nbsp; &nbsp; &nbsp; &nbsp;; function 31h = terminate and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; stay resident
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;init &nbsp; &nbsp;endp
<br>
<br>
<br>
&nbsp;zdiv &nbsp; &nbsp;proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; this is the divide-by-
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; zero interrupt handler
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sti &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; enable interrupts
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bp
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;es
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,cs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; make data addressable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &quot;Continue or Quit?&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg2 &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 09h = display string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;zdiv1: &nbsp;mov &nbsp; &nbsp; ah,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 01h = read keyboard
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,20h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; fold char to lowercase
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,'c' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; is it C or Q?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;zdiv3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, it's a C
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,'q'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;zdiv2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, it's a Q
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; illegal entry, send beep
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and erase the character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg3 &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 09h = display string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; zdiv1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; try again
<br>
<br>
&nbsp;zdiv2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; user chose &quot;Quit&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4cffh &nbsp; &nbsp; &nbsp; &nbsp;; terminate current program
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; with return code = 255
<br>
<br>
&nbsp;zdiv3: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; user chose &quot;Continue&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; send CR-LF pair
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg4 &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 09h = print string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; what CPU type is this?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; to find out, we'll put
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; zero in the CPU flags
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;popf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and see what happens
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pushf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; ax,0f000h &nbsp; &nbsp; &nbsp; ; 8086/8088 forces
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,0f000h &nbsp; &nbsp; &nbsp; ; bits 12-15 true
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;zdiv5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if 8086/8088
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; otherwise we must adjust
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return address to bypass
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; the divide instruction...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bp,sp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; make stack addressable
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lds &nbsp; &nbsp; bx,[bp+18] &nbsp; &nbsp; &nbsp;; get address of the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; faulting instruction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,[bx+1] &nbsp; &nbsp; &nbsp; ; get addressing byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; bx,0c7h &nbsp; &nbsp; &nbsp; &nbsp; ; isolate mod &amp; r/m fields
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; bl,6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; mod 0, r/m 6 = direct
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; zdiv4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; not direct, jump
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; word ptr [bp+18],4
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; zdiv5
<br>
<br>
&nbsp;zdiv4: &nbsp;mov &nbsp; &nbsp; cl,6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; otherwise isolate mod
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; bx,cl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; field and get instruction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,cs:[bx+itab] ; size from table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; [bp+18],bx
<br>
<br>
&nbsp;zdiv5: &nbsp;pop &nbsp; &nbsp; es &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bp
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return from interrupt
<br>
<br>
&nbsp;zdiv &nbsp; &nbsp;endp
<br>
<br>
<br>
&nbsp;msg1 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; load-time sign-on message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Divide by Zero Interrupt '
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Handler installed.'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf,'$'
<br>
<br>
&nbsp;msg2 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf,lf &nbsp; &nbsp; &nbsp; &nbsp;; interrupt-time message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Divide by Zero detected: '
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf,'Continue or Quit (C/Q) ? '
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'$'
<br>
<br>
&nbsp;msg3 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;beep &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; used if bad entry
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;backsp,' ',backsp,'$'
<br>
<br>
&nbsp;msg4 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf,'$' &nbsp; &nbsp; &nbsp; ; carriage return-linefeed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; instruction size table
<br>
&nbsp;itab &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; mod = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; mod = 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; mod = 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; mod = 3
<br>
<br>
&nbsp;pgm_len equ &nbsp; &nbsp; $-init &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; program length
<br>
<br>
&nbsp;_TEXT &nbsp; ends
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end &nbsp; &nbsp; init
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 13-4. &nbsp;A simple example of an interrrupt handler for use within the
<br>
&nbsp;MS-DOS environment. ZERODIV makes itself permanently resident in memory
<br>
&nbsp;and handles the CPU's internal divide-by-zero interrupt.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 14 &nbsp;Installable Device Drivers
<br>
<br>
&nbsp;Device drivers are the modules of an operating system that control the
<br>
&nbsp;hardware. They isolate the operating-system kernel from the specific
<br>
&nbsp;characteristics and idiosyncrasies of the peripheral devices interfaced to
<br>
&nbsp;the central processor. Thus, the driver's relationship to the kernel is
<br>
&nbsp;analogous to the operating system's relationship to application programs.
<br>
<br>
&nbsp;The installable device drivers that were introduced in MS-DOS version 2
<br>
&nbsp;give the user great flexibility. They allow the user to customize and
<br>
&nbsp;configure the computer for a wide range of peripheral devices, with a
<br>
&nbsp;minimum of troublesome interactions and without having to &quot;patch&quot; the
<br>
&nbsp;operating system. Even the most inexperienced user can install a new
<br>
&nbsp;device into a system by plugging in a card, copying a driver file to the
<br>
&nbsp;boot disk, and editing the system configuration file.
<br>
<br>
&nbsp;For those inclined to do their own programming, the MS-DOS installable
<br>
&nbsp;device drivers are interfaced to the hardware-independent kernel through a
<br>
&nbsp;simple and clearly defined scheme of function codes and data structures.
<br>
&nbsp;Given adequate information about the hardware, any competent assembly-
<br>
&nbsp;language programmer can expect to successfully interface even the most
<br>
&nbsp;bizarre device to MS-DOS without altering the operating system in the
<br>
&nbsp;slightest and without acquiring any special or proprietary knowledge about
<br>
&nbsp;its innards.
<br>
<br>
&nbsp;In retrospect, installable device drivers have proven to be one of the key
<br>
&nbsp;usability features of MS-DOS. I feel that they have been largely
<br>
&nbsp;responsible for the rapid proliferation and competitive pricing of
<br>
&nbsp;high-speed mass-storage devices for MS-DOS machines, and for the growing
<br>
&nbsp;confidence of the average user toward &quot;tampering with&quot; (upgrading) his or
<br>
&nbsp;her machine.
<br>
<br>
<br>
MS-DOS Device-Driver Types
<br>
<br>
&nbsp;Drivers written for MS-DOS fall into two distinct classes:
<br>
<br>
&nbsp;■ &nbsp;Block-device drivers
<br>
<br>
&nbsp;■ &nbsp;Character-device drivers
<br>
<br>
&nbsp;A driver's class determines what functions it must support, how it is
<br>
&nbsp;viewed by MS-DOS, and how it makes the associated physical device appear
<br>
&nbsp;to behave when an application program makes a request for I/O.
<br>
<br>
Character-Device Drivers
<br>
<br>
&nbsp;Character-device drivers control peripheral devices that perform input and
<br>
&nbsp;output one character (or byte) at a time, such as a terminal or printer. A
<br>
&nbsp;single character-device driver ordinarily supports a single hardware unit.
<br>
&nbsp;Each character device has a one-to-eight-character logical name, and an
<br>
&nbsp;application program can use this name to open the device for input or
<br>
&nbsp;output, as though it were a file. The logical name is strictly a means of
<br>
&nbsp;identification for MS-DOS and has no physical equivalent on the device.
<br>
<br>
&nbsp;MS-DOS's built-in character-device drivers for the console, serial port,
<br>
&nbsp;and printer are unique in that an application program can access them in
<br>
&nbsp;three different ways:
<br>
<br>
&nbsp;■ &nbsp;It can open them by name (CON, AUX, PRN, etc.) for input and output,
<br>
&nbsp; &nbsp; like any other character device.
<br>
<br>
&nbsp;■ &nbsp;It can use the special-purpose MS-DOS function calls (Int 21H Functions
<br>
&nbsp; &nbsp; 01-0CH).
<br>
<br>
&nbsp;■ &nbsp;It can use the default handles (standard input, standard output,
<br>
&nbsp; &nbsp; standard error, standard auxiliary, and standard printer), which do not
<br>
&nbsp; &nbsp; need to be opened to be used.
<br>
<br>
&nbsp;The number of additional character-device drivers that can be installed is
<br>
&nbsp;limited only by available memory and by the requirement that each driver
<br>
&nbsp;have a unique logical name. If more than one driver uses the same logical
<br>
&nbsp;name, the last driver to be loaded will supersede any others and will
<br>
&nbsp;receive all I/O requests addressed to that logical name. This fact can
<br>
&nbsp;occasionally be turned to advantage; for example, it allows the user to
<br>
&nbsp;replace the system's default CON driver, which does not support cursor
<br>
&nbsp;positioning or character attributes, with the more powerful ANSI.SYS
<br>
&nbsp;driver.
<br>
<br>
&nbsp;ASCII vs Binary Mode
<br>
<br>
&nbsp;MS-DOS regards a handle associated with a character device to be in either
<br>
&nbsp;ASCII (cooked) mode or binary (raw) mode. The mode affects MS-DOS's
<br>
&nbsp;buffering of data for read and write requests. The driver itself is not
<br>
&nbsp;aware of the mode, and the mode does not affect its operation. An
<br>
&nbsp;application can select the mode of a handle with the IOCTL function (Int
<br>
&nbsp;21H Function 44H).
<br>
<br>
&nbsp;During ASCII-mode input, MS-DOS requests characters one at a time from the
<br>
&nbsp;driver and places them into its own internal buffer, echoing each to the
<br>
&nbsp;screen (if the input device is the keyboard) and checking each character
<br>
&nbsp;for a Ctrl-C (03H). When the number of characters requested by the
<br>
&nbsp;application program has been received, when a Ctrl-Z is detected, or when
<br>
&nbsp;the Enter key is pressed (in the case of the keyboard), MS-DOS terminates
<br>
&nbsp;the input and copies the data from its internal buffer into the requesting
<br>
&nbsp;program's buffer. Similarly, during ASCII-mode output, MS-DOS passes the
<br>
&nbsp;characters to the device driver one at a time and checks for a Ctrl-C
<br>
&nbsp;pending at the keyboard between each character. When a Ctrl-C is detected,
<br>
&nbsp;MS-DOS aborts the input or output operation and transfers to the routine
<br>
&nbsp;whose address is stored in the Int 23H vector.
<br>
<br>
&nbsp;In binary mode, MS-DOS reads or writes the exact number of bytes requested
<br>
&nbsp;by the application program, without regard to any control characters such
<br>
&nbsp;as Enter or Ctrl-C. MS-DOS passes the entire request through to the driver
<br>
&nbsp;in a single operation, instead of breaking it into single-character reads
<br>
&nbsp;or writes, and transfers the characters directly to or from the requesting
<br>
&nbsp;program's buffer.
<br>
<br>
Block-Device drivers
<br>
<br>
&nbsp;Block-device drivers usually control random-access mass-storage devices
<br>
&nbsp;such as floppy-disk drives and fixed disks, although they can also be used
<br>
&nbsp;to control non-random-access devices such as magnetic-tape drives. Block
<br>
&nbsp;devices transfer data in chunks, rather than one byte at a time. The size
<br>
&nbsp;of the blocks may be either fixed (disk drives) or variable (tape drives).
<br>
<br>
&nbsp;A block driver can support more than one hardware unit, map a single
<br>
&nbsp;physical unit onto two or more logical units, or both. Block devices do
<br>
&nbsp;not have file-like logical names, as character devices do. Instead, MS-DOS
<br>
&nbsp;assigns drive designators to the block-device units or logical drives in
<br>
&nbsp;an alphabetic sequence: A, B, and so forth. Each logical drive contains a
<br>
&nbsp;file system: boot block, file allocation table, root directory, and so
<br>
&nbsp;forth. (See Chapter 10.)
<br>
<br>
&nbsp;A block-device driver's position in the chain of all drivers determines
<br>
&nbsp;the first letter assigned to that driver. The number of logical drive
<br>
&nbsp;units that the driver supports determines the total number of letters
<br>
&nbsp;assigned to it.
<br>
<br>
&nbsp;Block-device drivers always read or write exactly the number of sectors
<br>
&nbsp;requested (barring hardware or addressing errors) and never filter or
<br>
&nbsp;otherwise manipulate the contents of the blocks being transferred.
<br>
<br>
<br>
Structure of an MS-DOS Device Driver
<br>
<br>
&nbsp;A device driver consists of three major parts (Figure 14-1):
<br>
<br>
&nbsp;■ &nbsp;A device header
<br>
<br>
&nbsp;■ &nbsp;A strategy (strat) routine
<br>
<br>
&nbsp;■ &nbsp;An interrupt (intr) routine
<br>
<br>
&nbsp;We'll discuss each of these in more detail as we work through this
<br>
&nbsp;chapter.
<br>
<br>
&nbsp;┌────────────────────────┬─────────────────────────┐
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; Initialization &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; Media check &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp;Build BPB &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp;IOCTL read and write &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; Status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; Write, write/verify &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; Interrupt routine &nbsp; &nbsp;│ &nbsp; &nbsp;Output until busy &nbsp; &nbsp;│
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;Flush buffers &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; Device open &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp;Device close &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Check whether removable │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; Generic IOCTL &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;├─────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│ Get/Set logical device &nbsp;│
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;└─────────────────────────┤
<br>
&nbsp;├──────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Strategy routine &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;├──────────────────────────────────────────────────┤
<br>
&nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Device-driver header &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;└──────────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 14-1. &nbsp;General structure of an MS-DOS installable device driver.
<br>
<br>
The Device Header
<br>
<br>
&nbsp;The device header (Figure 14-2) lies at the beginning of the driver. It
<br>
&nbsp;contains a link to the next driver in the chain, a set of attribute flags
<br>
&nbsp;for the device (Figure 14-3), offsets to the executable strategy and
<br>
&nbsp;interrupt routines for the device, and the logical-device name (if it is a
<br>
&nbsp;character device such as PRN or COM1) or the number of logical units (if
<br>
&nbsp;it is a block device).
<br>
<br>
&nbsp;Byte offset
<br>
<br>
&nbsp;00H ┌──────────────────────────────────────────────┐
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; Link to next driver, offset &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp;02H ├──────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; Link to next driver, segment &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;04H ├──────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Device attribute word &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;06H ├──────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; Strategy entry point, offset &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;08H ├──────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp;Interrupt entry point, offset &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;0AH ├──────────────────────────────────────────────┤
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp;Logical name (8 bytes) if character device &nbsp;│
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp;Number of units (1 byte) if block device, &nbsp; │
<br>
&nbsp; &nbsp; &nbsp;│ &nbsp; &nbsp;followed by 7 bytes of reserved space &nbsp; &nbsp; │
<br>
&nbsp; &nbsp; &nbsp;└──────────────────────────────────────────────┘
<br>
<br>
&nbsp;Figure 14-2. &nbsp;Device-driver header. The offsets to the strat and intr
<br>
&nbsp;routines are offsets from the same segment used to point to the device
<br>
&nbsp;header.
<br>
<br>
<br>
&nbsp;Bit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if character device, 0 if block device
<br>
&nbsp;14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if IOCTL read and write supported
<br>
&nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for block devices:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if BIOS parameter block in boot sector should be used to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; determine media characteristics, 0 if media ID byte should
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; be used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for character devices:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if output until busy supported
<br>
&nbsp;12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved (should be 0)
<br>
&nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if open/close/removable media supported (MS-DOS 3.0 and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; later)
<br>
&nbsp;7─10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserved (should be 0)
<br>
&nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if generic IOCTL and get/set logical drive supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MS-DOS 3.2 and later)
<br>
&nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved (should be 0)
<br>
&nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if CON driver and Int 29H fast-output function supported
<br>
&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if current CLOCK$ device
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if current NUL device
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for block devices:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if driver supports 32-bit sector addressing (MS-DOS 4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for character devices:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if standard output device (stdout)
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if current standard input device (stdin)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 14-3. &nbsp;Device attribute word in device header. In block-device
<br>
&nbsp;drivers, only bits 6, 11, and 13─15 (and bit 1 in MS-DOS version 4.0) have
<br>
&nbsp;significance; the remainder should always be zero.
<br>
<br>
The Strategy Routine
<br>
<br>
&nbsp;MS-DOS calls the strategy routine (strat) for the device when the driver
<br>
&nbsp;is first loaded and installed, and again whenever an application program
<br>
&nbsp;issues an I/O request for the device. MS-DOS passes the strategy routine a
<br>
&nbsp;double-word pointer to a data structure called a request header. This
<br>
&nbsp;structure contains information about the type of operation to be
<br>
&nbsp;performed. In current versions of MS-DOS, the strategy routine never
<br>
&nbsp;actually performs any I/O operation but simply saves the pointer to the
<br>
&nbsp;request header. The strat routine must not make any Int 21H function
<br>
&nbsp;calls.
<br>
<br>
&nbsp;The first 13 bytes of the request header are the same for all
<br>
&nbsp;device-driver functions and are therefore referred to as the static
<br>
&nbsp;portion of the header. The number and contents of the subsequent bytes
<br>
&nbsp;vary according to the type of function being requested (Figure 14-4).
<br>
&nbsp;Both MS-DOS and the driver read and write information in the request
<br>
&nbsp;header.
<br>
<br>
&nbsp;The request header's most important component is a command code, or
<br>
&nbsp;function number, passed in its third byte to select a driver subfunction
<br>
&nbsp;such as read, write, or status. Other information passed to the driver in
<br>
&nbsp;the header includes unit numbers, transfer addresses, and sector or byte
<br>
&nbsp;counts.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;;
<br>
&nbsp;; MS-DOS request header structure definition
<br>
&nbsp;;
<br>
&nbsp;Request &nbsp; &nbsp; &nbsp; &nbsp; struc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; request header template structure
<br>
<br>
&nbsp;Rlength &nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 0 &nbsp;length of request header
<br>
&nbsp;Unit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 1 &nbsp;unit number for this request
<br>
&nbsp;Command &nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 2 &nbsp;request header's command code
<br>
&nbsp;Status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 3 &nbsp;driver's return status word
<br>
&nbsp;Reserve &nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;8 dup (?) &nbsp; &nbsp; &nbsp; &nbsp;; 5 &nbsp;reserved area
<br>
&nbsp;Media &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 13 media descriptor byte
<br>
&nbsp;Address &nbsp; &nbsp; &nbsp; &nbsp; dd &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 14 memory address for transfer
<br>
&nbsp;Count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dw &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 18 byte/sector count value
<br>
&nbsp;Sector &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 20 starting sector value
<br>
<br>
&nbsp;Request &nbsp; &nbsp; &nbsp; &nbsp; ends &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; end of request header template
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 14-4. &nbsp;Format of request header. Only the first 13 bytes are common
<br>
&nbsp;to all driver functions; the number and definition of the subsequent bytes
<br>
&nbsp;vary, depending upon the function type. The structure shown here is the
<br>
&nbsp;one used by the read and write subfunctions of the driver.
<br>
<br>
The Interrupt Routine
<br>
<br>
&nbsp;The last and most complex part of a device driver is the interrupt routine
<br>
&nbsp;(intr), which MS-DOS calls immediately after it calls the strategy
<br>
&nbsp;routine. The interrupt routine implements the device driver proper; it
<br>
&nbsp;performs (or calls other resident routines to perform) the actual input or
<br>
&nbsp;output operations, based on the information passed in the request header.
<br>
&nbsp;The strat routine may not make any Int 21H function calls, except for a
<br>
&nbsp;restricted set during driver initialization.
<br>
<br>
&nbsp;When an I/O function is completed, the interrupt routine uses the status
<br>
&nbsp;field in the request header to inform the DOS kernel about the outcome of
<br>
&nbsp;the requested I/O operation. It can use other fields in the request header
<br>
&nbsp;to pass back such useful information as counts of the actual sectors or
<br>
&nbsp;bytes transferred.
<br>
<br>
&nbsp;The interrupt routine usually consists of the following elements:
<br>
<br>
&nbsp;■ &nbsp;A collection of subroutines to implement the various function types
<br>
&nbsp; &nbsp; that may be requested by MS-DOS (sometimes called the command-code
<br>
&nbsp; &nbsp; routines)
<br>
<br>
&nbsp;■ &nbsp;A centralized entry point that saves all affected registers, extracts
<br>
&nbsp; &nbsp; the desired function code from the request header, and branches to the
<br>
&nbsp; &nbsp; appropriate command-code routine (typically accomplished with a jump
<br>
&nbsp; &nbsp; table)
<br>
<br>
&nbsp;■ &nbsp;A centralized exit point that stores status and error codes into the
<br>
&nbsp; &nbsp; request header (Figures 14-5 and 14-6) and restores the previous
<br>
&nbsp; &nbsp; contents of the affected registers
<br>
<br>
&nbsp;The command-code routines that implement the various functions supported
<br>
&nbsp;by an installable device driver are discussed in detail in the following
<br>
&nbsp;pages.
<br>
<br>
&nbsp;Bit(s) &nbsp; &nbsp; &nbsp; &nbsp; Significance
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Error
<br>
&nbsp;12─14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved
<br>
&nbsp;9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Busy
<br>
&nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Done
<br>
&nbsp;0─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Error code if bit 15 = 1
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 14-5. &nbsp;Values for the return status word of the request header.
<br>
<br>
&nbsp;Code &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write-protect violation
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unknown unit
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Drive not ready
<br>
&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unknown command
<br>
&nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Data error (CRC)
<br>
&nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bad request-structure length
<br>
&nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Seek error
<br>
&nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unknown medium
<br>
&nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sector not found
<br>
&nbsp;9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Printer out of paper
<br>
&nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write fault
<br>
&nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Read fault
<br>
&nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;General failure
<br>
&nbsp;0D─0EH &nbsp; &nbsp; &nbsp; &nbsp; Reserved
<br>
&nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Invalid disk change (MS-DOS versions 3.0 and later)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 14-6. &nbsp;Driver error codes returned in bits 0 through 7 of the
<br>
&nbsp;return status word of the request header.
<br>
<br>
&nbsp;Although its name suggests otherwise, the interrupt routine is never
<br>
&nbsp;entered asynchronously (on an I/O completion interrupt, for example).
<br>
&nbsp;Thus, the division of function between strategy and interrupt routines is
<br>
&nbsp;completely artificial in the current versions of MS-DOS.
<br>
<br>
<br>
The Command-Code Routines
<br>
<br>
&nbsp;A total of 20 command codes are defined for MS-DOS device drivers. The
<br>
&nbsp;command codes (which are not consecutive), the names of the associated
<br>
&nbsp;driver-interrupt routines, and the MS-DOS versions in which they are first
<br>
&nbsp;supported are as follows:
<br>
<br>
<br>
&nbsp;Command &nbsp; &nbsp; Function &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Character &nbsp; Block &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS
<br>
&nbsp;code &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; driver &nbsp; &nbsp; &nbsp;driver &nbsp; &nbsp; &nbsp; version
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Init (Initialization) &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Media Check &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Build BPB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOCTL Read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Nondestructive Read &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Input Status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Flush Input Buffers &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write with Verify &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output Status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Flush Output Buffers &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IOCTL Write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Device Open &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0
<br>
&nbsp;14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Device Close &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0
<br>
&nbsp;15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Removable Media &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0
<br>
&nbsp;16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output Until Busy &nbsp; &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0
<br>
&nbsp;19 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Generic IOCTL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.2
<br>
&nbsp;23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Logical Device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.2
<br>
&nbsp;24 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Logical Device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.2
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;As you can see from the preceding table, a driver's interrupt section must
<br>
&nbsp;support functions 0 through 12 under all versions of MS-DOS. Drivers
<br>
&nbsp;tailored for MS-DOS 3.0 and 3.1 can optionally support an additional four
<br>
&nbsp;functions, and MS-DOS drivers for versions 3.2 and later can support three
<br>
&nbsp;more (for a total of 20). MS-DOS inspects the bits in the attribute word
<br>
&nbsp;of the device-driver header to determine which of the optional functions a
<br>
&nbsp;driver supports, if any.
<br>
<br>
&nbsp;Some of the functions are relevant only for character-device drivers and
<br>
&nbsp;some only for block-device drivers; a few have meaning to both types. In
<br>
&nbsp;any case, both driver types should have an executable routine present for
<br>
&nbsp;each function, even if it does nothing except set the done flag in the
<br>
&nbsp;status word of the request header.
<br>
<br>
&nbsp;In the command-code descriptions that follow, RH refers to the request
<br>
&nbsp;header whose address was passed to the strategy routine in ES:BX, BYTE is
<br>
&nbsp;an 8-bit parameter, WORD is a 16-bit parameter, and DWORD is a far pointer
<br>
&nbsp;(a 16-bit offset followed by a 16-bit segment).
<br>
<br>
Function 00H (0): Driver Initialization
<br>
<br>
&nbsp;MS-DOS requests the driver's initialization function (init) only once,
<br>
&nbsp;when the driver is first loaded. This function performs any necessary
<br>
&nbsp;device hardware initialization, setup of interrupt vectors, and so forth.
<br>
&nbsp;The initialization routine must return the address of the position where
<br>
&nbsp;free memory begins after the driver code (the break address), so that
<br>
&nbsp;MS-DOS knows where it can build certain control structures and then load
<br>
&nbsp;the next installable driver. If this is a block-device driver, init must
<br>
&nbsp;also return the number of units and the address of a BPB pointer array.
<br>
<br>
&nbsp;MS-DOS uses the number of units returned by a block driver in the request
<br>
&nbsp;header to assign drive identifiers. For example, if the current maximum
<br>
&nbsp;drive is D and the driver being initialized supports four units, MS-DOS
<br>
&nbsp;will assign it the drive letters E, F, G, and H. Although the
<br>
&nbsp;device-driver header also has a field for number of units, MS-DOS does not
<br>
&nbsp;inspect it.
<br>
<br>
&nbsp;The BPB pointer array is an array of word offsets to BIOS parameter blocks
<br>
&nbsp;(Figure 14-7). Each unit defined by the driver must have one entry in the
<br>
&nbsp;array, although the entries can all point to the same BPB to conserve
<br>
&nbsp;memory. During the operating-system boot sequence, MS-DOS scans all the
<br>
&nbsp;BPBs defined by all the units in all the block-device drivers to determine
<br>
&nbsp;the largest sector size that exists on any device in the system and uses
<br>
&nbsp;this information to set its cache buffer size.
<br>
<br>
&nbsp;The operating-system services that the initialization code can invoke at
<br>
&nbsp;load time are very limited only Int 21H Functions 01H through 0CH and
<br>
&nbsp;30H. These are just adequate to check the MS-DOS version number and
<br>
&nbsp;display a driver-identification or error message.
<br>
<br>
&nbsp;Many programmers position the initialization code at the end of the driver
<br>
&nbsp;and return that address as the location of the first free memory, so that
<br>
&nbsp;MS-DOS will reclaim the memory occupied by the initialization routine
<br>
&nbsp;after the routine is finished with its work. If the initialization routine
<br>
&nbsp;finds that the device is missing or defective and wants to abort the
<br>
&nbsp;installation of the driver completely so that it does not occupy any
<br>
&nbsp;memory, it should return number of units as zero and set the free memory
<br>
&nbsp;address to CS:0000H. (A character-device driver that wants to abort its
<br>
&nbsp;installation should clear bit 15 of the attribute word in the driver
<br>
&nbsp;header and then set the units field and free memory address as though it
<br>
&nbsp;were a block-device driver.)
<br>
<br>
&nbsp;Byte(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contents
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;00─01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bytes per sector
<br>
&nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sectors per allocation unit (power of 2)
<br>
&nbsp;03H─04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of reserved sectors (starting at sector 0)
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of file allocation tables
<br>
&nbsp;06H─07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Maximum number of root-directory entries
<br>
&nbsp;08H─09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Total number of sectors in medium
<br>
&nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Media descriptor byte
<br>
&nbsp;0BH─0CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of sectors occupied by a single FAT
<br>
&nbsp;0DH─0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sectors per track (versions 3.0 and later)
<br>
&nbsp;0FH─10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of heads (versions 3.0 and later)
<br>
&nbsp;11H─12H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of hidden sectors (versions 3.0 and later)
<br>
&nbsp;13H─14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;High-order word of number of hidden sectors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (version 4.0)
<br>
&nbsp;15H─18H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If bytes 8─9 are zero, total number of sectors in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; medium (version 4.0)
<br>
&nbsp;19H─1EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved, should be zero (version 4.0)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 14-7. &nbsp;Structure of a BIOS parameter block (BPB). Every formatted
<br>
&nbsp;disk contains a copy of its BPB in the boot sector. (See Chapter 10.)
<br>
<br>
&nbsp;The initialization function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 0
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer to character after equal sign
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on CONFIG.SYS line that loaded driver
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (this information is read-only)
<br>
<br>
&nbsp;RH + 22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Drive number for first unit of this
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block driver (0 = A, 1 = B, and so
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forth) (MS-DOS version 3 only)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of units (block devices only)
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Address of first free memory above
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; driver (break address)
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BPB pointer array (block devices
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; only)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 01H (1): Media Check
<br>
<br>
&nbsp;The media-check function applies only to block devices, and in
<br>
&nbsp;character-device drivers it should do nothing except set the done flag.
<br>
&nbsp;This function is called when a drive-access call other than a simple file
<br>
&nbsp;read or write is pending. MS-DOS passes to the function the media
<br>
&nbsp;descriptor byte for the disk that it assumes is in the drive (Figure
<br>
&nbsp;14-8). If feasible, the media-check routine returns a code indicating
<br>
&nbsp;whether the disk has been changed since the last transfer. If the
<br>
&nbsp;media-check routine can assert that the disk has not been changed, MS-DOS
<br>
&nbsp;can bypass rereading the FAT before a directory access, which improves
<br>
&nbsp;overall performance.
<br>
<br>
&nbsp;Code &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0F0H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.5&quot;, 2-sided, 18-sector
<br>
&nbsp;0F8H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed disk
<br>
&nbsp;0F9H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.5&quot;, 2-sided, 9-sector
<br>
&nbsp;0F9H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25&quot;, 2-sided, 15-sector
<br>
&nbsp;0FCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25&quot;, 1-sided, 9-sector
<br>
&nbsp;0FDH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25&quot;, 2-sided, 9-sector
<br>
&nbsp;0FEH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25&quot;, 1-sided, 8-sector
<br>
&nbsp;0FFH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25&quot;, 2-sided, 8-sector
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 14-8. &nbsp;Current valid MS-DOS codes for the media descriptor byte of
<br>
&nbsp;the request header, assuming bit 13 in the attribute word of the driver
<br>
&nbsp;header is zero.
<br>
<br>
&nbsp;MS-DOS responds to the results of the media-check function in the
<br>
&nbsp;following ways:
<br>
<br>
&nbsp;■ &nbsp;If the disk has not been changed, MS-DOS proceeds with the disk access.
<br>
<br>
&nbsp;■ &nbsp;If the disk has been changed, MS-DOS invalidates all buffers associated
<br>
&nbsp; &nbsp; with this unit, including buffers containing data waiting to be written
<br>
&nbsp; &nbsp; (this data is simply lost), performs a BUILD BPB call, and then reads
<br>
&nbsp; &nbsp; the disk's FAT and directory.
<br>
<br>
&nbsp;■ &nbsp;If the disk-change status is unknown, the action taken by MS-DOS
<br>
&nbsp; &nbsp; depends upon the state of its internal buffers. If data that needs to
<br>
&nbsp; &nbsp; be written out is present in the buffers, MS-DOS assumes no disk change
<br>
&nbsp; &nbsp; has occurred and writes the data (taking the risk that, if the disk
<br>
&nbsp; &nbsp; really was changed, the file structure on the new disk may be damaged).
<br>
&nbsp; &nbsp; If the buffers are empty or have all been previously flushed to the
<br>
&nbsp; &nbsp; disk, MS-DOS assumes that the disk was changed, and then proceeds as
<br>
&nbsp; &nbsp; described above for the disk-changed return code.
<br>
<br>
&nbsp;If bit 11 of the device-header attribute word is set (that is, the driver
<br>
&nbsp;supports the optional open/close/removable-media functions), the host
<br>
&nbsp;system is MS-DOS version 3.0 or later, and the function returns the
<br>
&nbsp;disk-changed code (-1), the function must also return the segment and
<br>
&nbsp;offset of the ASCIIZ volume label for the previous disk in the drive. (If
<br>
&nbsp;the driver does not have the volume label, it can return a pointer to the
<br>
&nbsp;ASCIIZ string NO NAME.) If MS-DOS determines that the disk was changed
<br>
&nbsp;with unwritten data still present in its buffers, it issues a
<br>
&nbsp;critical-error 0FH (invalid disk change). Application programs can trap
<br>
&nbsp;this critical error and prompt the user to replace the original disk.
<br>
<br>
&nbsp;The media-check function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 1
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Media descriptor byte
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Media-change code:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -1 if disk changed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 if don't know whether disk changed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if disk not changed
<br>
<br>
&nbsp;RH + 15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer to previous volume label, if
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; device attribute bit 11 = 1 and disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has been changed (MS-DOS versions 3.0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and later)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 02H (2): Build BIOS Parameter Block (BPB)
<br>
<br>
&nbsp;The build BPB function applies only to block devices, and in
<br>
&nbsp;character-device drivers should do nothing except set the done flag. The
<br>
&nbsp;kernel uses this function to get a pointer to the valid BPB (see Figure
<br>
&nbsp;14-7) for the current disk and calls it when the disk-changed code is
<br>
&nbsp;returned by the media-check routine or the don't-know code is returned and
<br>
&nbsp;there are no dirty buffers (buffers with changed data that have not yet
<br>
&nbsp;been written to disk). Thus, a call to this function indicates that the
<br>
&nbsp;disk has been legally changed.
<br>
<br>
&nbsp;The build BPB function receives a pointer to a one-sector buffer in the
<br>
&nbsp;request header. If bit 13 in the driver header's attribute word is zero,
<br>
&nbsp;the buffer contains the first sector of the FAT (which includes the media
<br>
&nbsp;identification byte) and should not be altered by the driver. If bit 13 is
<br>
&nbsp;set, the driver can use the buffer as scratch space.
<br>
<br>
&nbsp;The build BPB function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 2
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Media descriptor byte
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer address
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer to new BPB
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Under MS-DOS versions 3.0 and later, if bit 11 of the header's device
<br>
&nbsp;attribute word is set, this routine should also read the volume label off
<br>
&nbsp;the disk and save it.
<br>
<br>
Function 03H (3): I/O-Control Read
<br>
<br>
&nbsp;The IOCTL read function allows the device driver to pass information
<br>
&nbsp;directly to the application program. This function is called only if bit
<br>
&nbsp;14 is set in the device attribute word. MS-DOS performs no error check on
<br>
&nbsp;IOCTL I/O calls.
<br>
<br>
&nbsp;The IOCTL read function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code (block devices)
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 3
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Media descriptor byte
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Transfer address
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Byte/sector count
<br>
<br>
&nbsp;RH + 20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Starting sector number (block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devices)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Actual bytes or sectors transferred
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 04H (4): Read
<br>
<br>
&nbsp;The read function transfers data from the device into the specified memory
<br>
&nbsp;buffer. If an error is encountered during the read, the function must set
<br>
&nbsp;the error status and, in addition, report the number of bytes or sectors
<br>
&nbsp;successfully transferred; it is not sufficient to simply report an error.
<br>
<br>
&nbsp;The read function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code (block devices)
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 4
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Media descriptor byte
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Transfer address
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Byte/sector count
<br>
<br>
&nbsp;RH + 20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Starting sector number (block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devices)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;For block-device read operations in MS-DOS version 4, if the logical unit
<br>
&nbsp;is larger than 32 MB and bit 1 of the driver's attribute word is set, the
<br>
&nbsp;following request structure is used instead:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 4
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Media descriptor byte
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Transfer address
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sector count
<br>
<br>
&nbsp;RH + 20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contains -1 to signal use of 32-bit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sector number
<br>
<br>
&nbsp;RH + 26 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 32-bit starting sector number
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The read function returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Actual bytes or sectors transferred
<br>
<br>
&nbsp;RH + 22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer to volume label if error 0FH
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is returned (MS-DOS versions 3.0 and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; later)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Under MS-DOS versions 3.0 and later, this routine can use the count of
<br>
&nbsp;open files maintained by the open and close functions (0DH and 0EH) and
<br>
&nbsp;the media descriptor byte to determine whether the disk has been illegally
<br>
&nbsp;changed.
<br>
<br>
Function 05H (5): Nondestructive Read
<br>
<br>
&nbsp;The nondestructive read function applies only to character devices, and in
<br>
&nbsp;block devices it should do nothing except set the done flag. It returns
<br>
&nbsp;the next character that would be obtained with a read function (command
<br>
&nbsp;code 4), without removing that character from the driver's internal
<br>
&nbsp;buffer. MS-DOS uses this function to check the console driver for pending
<br>
&nbsp;Control-C characters during other operations.
<br>
<br>
&nbsp;The nondestructive read function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 5
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If busy bit = 0, at least one
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; character is waiting
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If busy bit = 1, no characters are
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waiting
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Character (if busy bit = 0)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 06H (6): Input Status
<br>
<br>
&nbsp;The input-status function applies only to character devices, and in
<br>
&nbsp;block-device drivers it should do nothing except set the done flag. This
<br>
&nbsp;function returns the current input status for the device, allowing MS-DOS
<br>
&nbsp;to test whether characters are waiting in a type-ahead buffer. If the
<br>
&nbsp;character device does not have a type-ahead buffer, the input-status
<br>
&nbsp;routine should always return the busy bit equal to zero, so that MS-DOS
<br>
&nbsp;will not wait forever to call the read (04H) or nondestructive read (05H)
<br>
&nbsp;function.
<br>
<br>
&nbsp;The input-status function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 6
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If busy bit = 1, read request goes to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; physical device.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If busy bit = 0, characters already
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in device buffer and read request
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns quickly.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 07H (7): Flush Input Buffers
<br>
<br>
&nbsp;The flush-input-buffers function applies only to character devices, and in
<br>
&nbsp;block-device drivers it should do nothing except set the done flag. This
<br>
&nbsp;function causes any data waiting in the input buffer to be discarded.
<br>
<br>
&nbsp;The flush-input-buffers function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 7
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 08H (8): Write
<br>
<br>
&nbsp;The write function transfers data from the specified memory buffer to the
<br>
&nbsp;device. If an error is encountered during the write, the write function
<br>
&nbsp;must set the error status and, in addition, report the number of bytes or
<br>
&nbsp;sectors successfully transferred; it is not sufficient to simply report an
<br>
&nbsp;error.
<br>
<br>
&nbsp;The write function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code (block devices)
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 8
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Media descriptor byte
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Transfer address
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Byte/sector count
<br>
<br>
&nbsp;RH + 20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Starting sector number (block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devices)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;For block-device write operations in MS-DOS version 4, if the logical unit
<br>
&nbsp;is larger than 32 MB and bit 1 of the driver's attribute word is set, the
<br>
&nbsp;following request structure is used instead:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 8
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Media descriptor byte
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Transfer address
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sector count
<br>
<br>
&nbsp;RH + 20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contains -1 to signal use of 32-bit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sector number
<br>
<br>
&nbsp;RH + 26 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 32-bit starting sector number
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The write function returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Actual bytes or sectors transferred
<br>
<br>
&nbsp;RH + 22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer to volume label if error 0FH
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned (MS-DOS versions 3.0 and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; later)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Under MS-DOS versions 3.0 and later, this routine can use the reference
<br>
&nbsp;count of open files maintained by the open and close functions (0DH and
<br>
&nbsp;0EH) and the media descriptor byte to determine whether the disk has been
<br>
&nbsp;illegally changed.
<br>
<br>
Function 09H (9): Write with Verify
<br>
<br>
&nbsp;The write-with-verify function transfers data from the specified memory
<br>
&nbsp;buffer to the device. If feasible, it should perform a read-after-write
<br>
&nbsp;verification of the data to confirm that the data was written correctly.
<br>
&nbsp;Otherwise, Function 09H is exactly like Function 08H.
<br>
<br>
Function 0AH (10): Output Status
<br>
<br>
&nbsp;The output-status function applies only to character devices, and in
<br>
&nbsp;block-device drivers it should do nothing except set the done flag. This
<br>
&nbsp;function returns the current output status for the device.
<br>
<br>
&nbsp;The output-status function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 10 (0AH)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If busy bit = 1, write request waits
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for completion of current request.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If busy bit = 0, device idle and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write request starts immediately.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 0BH (11): Flush Output Buffers
<br>
<br>
&nbsp;The flush-output-buffers function applies only to character devices, and
<br>
&nbsp;in block-device drivers it should do nothing except set the done flag.
<br>
&nbsp;This function empties the output buffer, if any, and discards any pending
<br>
&nbsp;output requests.
<br>
<br>
&nbsp;The flush-output-buffers function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 11 (0BH)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 0CH (12): I/O-Control Write
<br>
<br>
&nbsp;The IOCTL write function allows an application program to pass control
<br>
&nbsp;information directly to the driver. This function is called only if bit 14
<br>
&nbsp;is set in the device attribute word. MS-DOS performs no error check on
<br>
&nbsp;IOCTL I/O calls.
<br>
<br>
&nbsp;The IOCTL write function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code (block devices)
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 12 (0CH)
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Media descriptor byte
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Transfer address
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Byte/sector count
<br>
<br>
&nbsp;RH + 20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Starting sector number (block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; devices)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Actual bytes or sectors transferred
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 0DH (13): Device Open
<br>
<br>
&nbsp;The device-open function is supported only under MS-DOS versions 3.0 and
<br>
&nbsp;later and is called only if bit 11 is set in the device attribute word of
<br>
&nbsp;the device header.
<br>
<br>
&nbsp;On block devices, the device-open function can be used to manage local
<br>
&nbsp;buffering and to increment a reference count of the number of open files
<br>
&nbsp;on the device. This capability must be used with care, however, because
<br>
&nbsp;programs that access files through FCBs frequently fail to close them,
<br>
&nbsp;thus invalidating the open-files count. One way to protect against this
<br>
&nbsp;possibility is to reset the open-files count to zero, without flushing the
<br>
&nbsp;buffers, whenever the answer to a media-change call is yes and a
<br>
&nbsp;subsequent build BPB call is made to the driver.
<br>
<br>
&nbsp;On character devices, the device-open function can be used to send a
<br>
&nbsp;device-initialization string (which can be set into the driver by an
<br>
&nbsp;application program by means of an IOCTL write function) or to deny
<br>
&nbsp;simultaneous access to a character device by more than one process. Note
<br>
&nbsp;that the predefined handles for the CON, AUX, and PRN devices are always
<br>
&nbsp;open.
<br>
<br>
&nbsp;The device-open function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code (block devices)
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 13 (0DH)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 0EH (14): Device Close
<br>
<br>
&nbsp;The device-close function is supported only under MS-DOS versions 3.0 and
<br>
&nbsp;later and is called only if bit 11 is set in the device attribute word of
<br>
&nbsp;the device header.
<br>
<br>
&nbsp;On block devices, this function can be used to manage local buffering and
<br>
&nbsp;to decrement a reference count of the number of open files on the device;
<br>
&nbsp;when the count reaches zero, all files have been closed and the driver
<br>
&nbsp;should flush buffers because the user may change disks.
<br>
<br>
&nbsp;On character devices, the device-close function can be used to send a
<br>
&nbsp;device-dependent post-I/O string such as a formfeed. (This string can be
<br>
&nbsp;set into the driver by an application program by means of an IOCTL write
<br>
&nbsp;function.) Note that the predefined handles for the CON, PRN, and AUX
<br>
&nbsp;devices are never closed.
<br>
<br>
&nbsp;The device-close function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code (block devices)
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 14 (0EH)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 0FH (15): Removable Media
<br>
<br>
&nbsp;The removable-media function is supported only under MS-DOS versions 3.0
<br>
&nbsp;and later and only on block devices; in character-device drivers it should
<br>
&nbsp;do nothing except set the done flag. This function is called only if bit
<br>
&nbsp;11 is set in the device attribute word in the device header.
<br>
<br>
&nbsp;The removable-media function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 15 (0FH)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If busy bit = 1, medium nonremovable
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If busy bit = 0, medium removable
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 10H (16): Output Until Busy
<br>
<br>
&nbsp;The output-until-busy function is supported only under MS-DOS versions 3.0
<br>
&nbsp;and later, and only on character devices; in block-device drivers it
<br>
&nbsp;should do nothing except set the done flag. This function transfers data
<br>
&nbsp;from the specified memory buffer to a device, continuing to transfer bytes
<br>
&nbsp;until the device is busy. It is called only if bit 13 of the device
<br>
&nbsp;attribute word is set in the device header.
<br>
<br>
&nbsp;This function is an optimization included specifically for the use of
<br>
&nbsp;print spoolers. It is not an error for this function to return a number of
<br>
&nbsp;bytes transferred that is less than the number of bytes requested.
<br>
<br>
&nbsp;The output-until-busy function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 16 (10H)
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Transfer address
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Byte count
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
<br>
&nbsp;RH + 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Actual bytes transferred
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 13H (19) Generic IOCTL
<br>
<br>
&nbsp;The generic IOCTL function is supported only under MS-DOS versions 3.2 and
<br>
&nbsp;later and is called only if bit 6 is set in the device attribute word of
<br>
&nbsp;the device header. This function corresponds to the MS-DOS generic IOCTL
<br>
&nbsp;service supplied to application programs by Int 21H Function 44H
<br>
&nbsp;Subfunctions 0CH and 0DH.
<br>
<br>
&nbsp;The generic IOCTL function is passed a category (major) code, a function
<br>
&nbsp;(minor) code, the contents of the SI and DI registers at the point of the
<br>
&nbsp;IOCTL call, and the segment and offset of a data buffer. This buffer in
<br>
&nbsp;turn contains other information whose format depends on the major and
<br>
&nbsp;minor IOCTL codes passed in the request header. The driver must interpret
<br>
&nbsp;the major and minor codes in the request header and the contents of the
<br>
&nbsp;additional buffer to determine which operation it will carry out, then set
<br>
&nbsp;the done flag in the request-header status word, and return any other
<br>
&nbsp;applicable information in the request header or the data buffer.
<br>
<br>
&nbsp;Services that the generic IOCTL function may invoke, if the driver
<br>
&nbsp;supports them, include configuration of the driver for nonstandard disk
<br>
&nbsp;formats, reading and writing entire disk tracks of data, and formatting
<br>
&nbsp;and verifying tracks. The generic IOCTL function has been designed to be
<br>
&nbsp;open-ended, so that it can be used to easily extend the device-driver
<br>
&nbsp;definition under future versions of MS-DOS.
<br>
<br>
&nbsp;The generic IOCTL function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit number (block devices)
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 19 (13H)
<br>
<br>
&nbsp;RH + 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Category (major) code
<br>
<br>
&nbsp;RH + 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Function (minor) code
<br>
<br>
&nbsp;RH + 15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SI register contents
<br>
<br>
&nbsp;RH + 17 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DI register contents
<br>
<br>
&nbsp;RH + 19 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DWORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Address of generic IOCTL data packet
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 17H (23): Get Logical Device
<br>
<br>
&nbsp;The get-logical-device function is supported only under MS-DOS versions
<br>
&nbsp;3.2 and later and only on block devices; in character-device drivers it
<br>
&nbsp;should do nothing except set the done bit in the status word. This
<br>
&nbsp;function is called only if bit 6 is set in the device attribute word of
<br>
&nbsp;the device header. It corresponds to the get-logical-device-map service
<br>
&nbsp;supplied to application programs through Int 21H Function 44H Subfunction
<br>
&nbsp;0EH.
<br>
<br>
&nbsp;The get-logical-device function returns a code for the last drive letter
<br>
&nbsp;used to reference the device; if only one drive letter is assigned to the
<br>
&nbsp;device, the returned unit code should be zero. Thus, this function can be
<br>
&nbsp;used to determine whether more than one drive letter is assigned to the
<br>
&nbsp;same physical device.
<br>
<br>
&nbsp;The get-logical-device function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 23 (17H)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Last unit referenced, or zero
<br>
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
Function 18H (24): Set Logical Device
<br>
<br>
&nbsp;The set-logical-device function is supported only under MS-DOS versions
<br>
&nbsp;3.2 and later and only on block devices; in character-device drivers it
<br>
&nbsp;should do nothing except set the done bit in the status word. This
<br>
&nbsp;function is called only if bit 6 is set in the device attribute word of
<br>
&nbsp;the device header. It corresponds to the set-logical-device-map service
<br>
&nbsp;supplied to application programs by MS-DOS through Int 21H Function 44H
<br>
&nbsp;Subfunction 0FH.
<br>
<br>
&nbsp;The set-logical-device function informs the driver of the next
<br>
&nbsp;logical-drive identifier that will be used to reference the physical
<br>
&nbsp;device. The unit code passed by the MS-DOS kernel in this case is
<br>
&nbsp;zero-based relative to the number of logical drives supported by this
<br>
&nbsp;particular driver. For example, if the driver supports two floppy-disk
<br>
&nbsp;units (A and B), only one physical floppy-disk drive exists in the system,
<br>
&nbsp;and the set-logical-device function is called with a unit number of 1, the
<br>
&nbsp;driver is being informed that the next read or write request from the
<br>
&nbsp;kernel will be directed to drive B.
<br>
<br>
&nbsp;The set-logical-device function is called with
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unit code
<br>
<br>
&nbsp;RH + 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BYTE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command code = 24 (18H)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;It returns
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;RH + 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Status
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
The Processing of a Typical I/O Request
<br>
<br>
&nbsp;An application program requests an I/O operation from MS-DOS by loading
<br>
&nbsp;registers with the appropriate values and executing an Int 21H. This
<br>
&nbsp;results in the following sequence of actions:
<br>
<br>
&nbsp;1. &nbsp;MS-DOS inspects its internal tables and determines which device driver
<br>
&nbsp; &nbsp; &nbsp;should receive the I/O request.
<br>
<br>
&nbsp;2. &nbsp;MS-DOS creates a request-header data packet in a reserved area of
<br>
&nbsp; &nbsp; &nbsp;memory. (Disk I/O requests are transformed from file and record
<br>
&nbsp; &nbsp; &nbsp;information into logical-sector requests by MS-DOS's interpretation of
<br>
&nbsp; &nbsp; &nbsp;the disk directory and FAT.)
<br>
<br>
&nbsp;3. &nbsp;MS-DOS calls the device driver's strat entry point, passing the
<br>
&nbsp; &nbsp; &nbsp;address of the request header in the ES:BX registers.
<br>
<br>
&nbsp;4. &nbsp;The device driver saves the address of the request header in a local
<br>
&nbsp; &nbsp; &nbsp;variable and performs a FAR RETURN.
<br>
<br>
&nbsp;5. &nbsp;MS-DOS calls the device driver's intr entry point.
<br>
<br>
&nbsp;6. &nbsp;The interrupt routine saves all registers, retrieves the address of
<br>
&nbsp; &nbsp; &nbsp;the request header that was saved by the strategy routine, extracts
<br>
&nbsp; &nbsp; &nbsp;the function code, and branches to the appropriate command-code
<br>
&nbsp; &nbsp; &nbsp;subroutine to perform the function.
<br>
<br>
&nbsp;7. &nbsp;If a data transfer on a block device was requested, the driver's read
<br>
&nbsp; &nbsp; &nbsp;or write subroutine translates the logical-sector number into a head,
<br>
&nbsp; &nbsp; &nbsp;track, and physical-sector address for the requested unit and then
<br>
&nbsp; &nbsp; &nbsp;performs the I/O operation. Because a multiple-sector transfer can be
<br>
&nbsp; &nbsp; &nbsp;requested in a single request header, a single request by MS-DOS to
<br>
&nbsp; &nbsp; &nbsp;the driver can result in multiple read or write commands to the disk
<br>
&nbsp; &nbsp; &nbsp;controller.
<br>
<br>
&nbsp;8. &nbsp;When the requested function is complete, the interrupt routine sets
<br>
&nbsp; &nbsp; &nbsp;the status word and any other required information into the request
<br>
&nbsp; &nbsp; &nbsp;header, restores all registers to their state at entry, and performs a
<br>
&nbsp; &nbsp; &nbsp;FAR RETURN.
<br>
<br>
&nbsp;9. &nbsp;MS-DOS translates the driver's return status into the appropriate
<br>
&nbsp; &nbsp; &nbsp;return code and carry-flag status for the MS-DOS Int 21H function that
<br>
&nbsp; &nbsp; &nbsp;was requested and returns control to the application program.
<br>
<br>
&nbsp;Note that a single request by an application program can result in MS-DOS
<br>
&nbsp;passing many request headers to the driver. For example, attempting to
<br>
&nbsp;open a file in a subdirectory on a previously unaccessed disk drive might
<br>
&nbsp;require the following actions:
<br>
<br>
&nbsp;■ &nbsp;Reading the disk's boot sector to get the BPB
<br>
<br>
&nbsp;■ &nbsp;Reading from one to many sectors of the root directory to find the
<br>
&nbsp; &nbsp; entry for the subdirectory and obtain its starting-cluster number
<br>
<br>
&nbsp;■ &nbsp;Reading from one to many sectors of both the FAT and the subdirectory
<br>
&nbsp; &nbsp; itself to find the entry for the desired file
<br>
<br>
<br>
The CLOCK Driver: A Special Case
<br>
<br>
&nbsp;MS-DOS uses the CLOCK device for marking file control blocks and directory
<br>
&nbsp;entries with the date and time, as well as for providing the date and time
<br>
&nbsp;services to application programs. This device has a unique type of
<br>
&nbsp;interaction with MS-DOS──a 6-byte sequence is read from or written to the
<br>
&nbsp;driver that obtains or sets the current date and time. The sequence has
<br>
&nbsp;the following format:
<br>
<br>
&nbsp;┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
<br>
&nbsp;│ &nbsp; &nbsp;0 &nbsp; &nbsp;│ &nbsp; &nbsp;1 &nbsp; &nbsp;│ &nbsp; &nbsp;2 &nbsp; &nbsp;│ &nbsp; &nbsp;3 &nbsp; &nbsp;│ &nbsp; 4 &nbsp; &nbsp; │ &nbsp; &nbsp;5 &nbsp; &nbsp;│
<br>
&nbsp;│ &nbsp;Days &nbsp; │ &nbsp;Days &nbsp; │ Minutes │ &nbsp;Hours &nbsp;│Seconds/ │ Seconds │
<br>
&nbsp;│low byte │high byte│ &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp; &nbsp; &nbsp; &nbsp; │ &nbsp;100 &nbsp; &nbsp;│ &nbsp; &nbsp; &nbsp; &nbsp; │
<br>
&nbsp;└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
<br>
<br>
&nbsp;The value passed for days is a 16-bit integer representing the number of
<br>
&nbsp;days elapsed since January 1, 1980.
<br>
<br>
&nbsp;The clock driver can have any logical-device name because MS-DOS uses the
<br>
&nbsp;CLOCK bit in the device attribute word of the driver's device header to
<br>
&nbsp;identify the device, rather than its name. On IBM PC systems, the clock
<br>
&nbsp;device has the logical-device name CLOCK$.
<br>
<br>
<br>
Writing and Installing a Device Driver
<br>

<br>
&nbsp;Now that we have discussed the structure and capabilities of installable
<br>
&nbsp;device drivers for the MS-DOS environment, we can discuss the mechanical
<br>
&nbsp;steps of assembling and linking them.
<br>
<br>
Assembly
<br>
<br>
&nbsp;Device drivers for MS-DOS always have an origin of zero but are otherwise
<br>
&nbsp;assembled, linked, and converted into an executable module as though they
<br>
&nbsp;were .COM files. (Although MS-DOS is also capable of loading installable
<br>
&nbsp;drivers in the .EXE file format, this introduces unnecessary complexity
<br>
&nbsp;into writing and debugging drivers and offers no significant advantages.
<br>
&nbsp;In addition, it is not possible to use .EXE-format drivers with some IBM
<br>
&nbsp;versions of MS-DOS because the .EXE loader is located in COMMAND.COM,
<br>
&nbsp;which is not present when the installable device drivers are being
<br>
&nbsp;loaded.) The driver should not have a declared stack segment and must, in
<br>
&nbsp;general, follow the other restrictions outlined in Chapter 3 for
<br>
&nbsp;memory-image (.COM) programs. A driver can be loaded anywhere, so beware
<br>
&nbsp;that you do not make any assumptions in your code about the driver's
<br>
&nbsp;location in physical memory. Figure 14-9 presents a skeleton example that
<br>
&nbsp;you can follow as you read the next few pages.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;driver
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page &nbsp; &nbsp;55,132
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;title &nbsp; DRIVER.ASM Device-Driver Skeleton
<br>
<br>
&nbsp;;
<br>
&nbsp;; DRIVER.ASM &nbsp; MS-DOS device-driver skeleton
<br>
&nbsp;;
<br>
&nbsp;; The driver command-code routines are stubs only and have
<br>
&nbsp;; no effect but to return a nonerror &quot;done&quot; status.
<br>
&nbsp;;
<br>
&nbsp;; Copyright 1988 Ray Duncan
<br>
&nbsp;;
<br>
<br>
&nbsp;_TEXT &nbsp; segment word public 'CODE'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assume &nbsp;cs:_TEXT,ds:_TEXT,es:NOTHING
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;org &nbsp; &nbsp; 0
<br>
<br>
&nbsp;MaxCmd &nbsp;equ &nbsp; &nbsp; 24 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; maximum allowed command code:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 12 for MS-DOS 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 16 for MS-DOS 3.0-3.1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 24 for MS-DOS 3.2-3.3
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII linefeed
<br>
&nbsp;eom &nbsp; &nbsp; equ &nbsp; &nbsp; '$' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; end-of-message signal
<br>
<br>
<br>
&nbsp;Header: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; device-driver header
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; link to next device driver
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0c840h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; device attribute word
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;Strat &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &quot;strategy&quot; routine entry point
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;Intr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &quot;interrupt&quot; routine entry point
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'SKELETON' &nbsp; &nbsp; &nbsp;; logical-device name
<br>
<br>
<br>
&nbsp;RHPtr &nbsp; dd &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; pointer to request header, passed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; by MS-DOS kernel to strategy routine
<br>
<br>
<br>
&nbsp;Dispatch: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; interrupt-routine command-code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; dispatch table:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;Init &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 0 &nbsp;= initialize driver
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;MediaChk &nbsp; &nbsp; &nbsp; &nbsp;; 1 &nbsp;= media check
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;BuildBPB &nbsp; &nbsp; &nbsp; &nbsp;; 2 &nbsp;= build BPB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;IoctlRd &nbsp; &nbsp; &nbsp; &nbsp; ; 3 &nbsp;= IOCTL read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;Read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 4 &nbsp;= read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;NdRead &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 5 &nbsp;= nondestructive read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;InpStat &nbsp; &nbsp; &nbsp; &nbsp; ; 6 &nbsp;= input status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;InpFlush &nbsp; &nbsp; &nbsp; &nbsp;; 7 &nbsp;= flush input buffers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;Write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 8 &nbsp;= write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;WriteVfy &nbsp; &nbsp; &nbsp; &nbsp;; 9 &nbsp;= write with verify
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;OutStat &nbsp; &nbsp; &nbsp; &nbsp; ; 10 = output status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;OutFlush &nbsp; &nbsp; &nbsp; &nbsp;; 11 = flush output buffers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;IoctlWt &nbsp; &nbsp; &nbsp; &nbsp; ; 12 = IOCTL write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;DevOpen &nbsp; &nbsp; &nbsp; &nbsp; ; 13 = device open &nbsp; &nbsp; &nbsp; (MS-DOS 3.0+)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;DevClose &nbsp; &nbsp; &nbsp; &nbsp;; 14 = device close &nbsp; &nbsp; &nbsp;(MS-DOS 3.0+)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;RemMedia &nbsp; &nbsp; &nbsp; &nbsp;; 15 = removable media &nbsp;(MS-DOS 3.0+)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;OutBusy &nbsp; &nbsp; &nbsp; &nbsp; ; 16 = output until busy (MS-DOS 3.0+)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;Error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 17 = not used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;Error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 18 = not used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;GenIOCTL &nbsp; &nbsp; &nbsp; &nbsp;; 19 = generic IOCTL &nbsp; &nbsp; (MS-DOS 3.2+)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;Error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 20 = not used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;Error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 21 = not used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;Error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; 22 = not used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;GetLogDev &nbsp; &nbsp; &nbsp; ; 23 = get logical device (MS-DOS 3.2+)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;SetLogDev &nbsp; &nbsp; &nbsp; ; 24 = set logical device (MS-DOS 3.2+)
<br>
&nbsp;Strat &nbsp; proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; device-driver strategy routine,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; called by MS-DOS kernel with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ES:BX = address of request header
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save pointer to request header
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr cs:[RHPtr],bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr cs:[RHPtr+2],es
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to MS-DOS kernel
<br>
<br>
&nbsp;Strat &nbsp; endp
<br>
<br>
<br>
&nbsp;Intr &nbsp; &nbsp;proc &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; device-driver interrupt routine,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; called by MS-DOS kernel immediately
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; after call to strategy routine
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save general registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;es
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bp
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; make local data addressable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; by setting DS = CS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;les &nbsp; &nbsp; di,[RHPtr] &nbsp; &nbsp; &nbsp;; let ES:DI = request header
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get BX = command code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,es:[di+2]
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; bh,bh
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; bx,MaxCmd &nbsp; &nbsp; &nbsp; ; make sure it's legal
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jle &nbsp; &nbsp; Intr1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, function code is ok
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;Error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set error bit, &quot;unknown command&quot; code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; Intr2
<br>
<br>
&nbsp;Intr1: &nbsp;shl &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; form index to dispatch table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and branch to command-code routine
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;word ptr [bx+Dispatch]
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;les &nbsp; &nbsp; di,[RHPtr] &nbsp; &nbsp; &nbsp;; ES:DI = addr of request header
<br>
<br>
&nbsp;Intr2: &nbsp;or &nbsp; &nbsp; &nbsp;ax,0100h &nbsp; &nbsp; &nbsp; &nbsp;; merge 'done' bit into status and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es:[di+3],ax &nbsp; &nbsp;; store status into request header
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore general registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; es
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ds
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to MS-DOS kernel
<br>
<br>
<br>
&nbsp;; Command-code routines are called by the interrupt routine
<br>
&nbsp;; via the dispatch table with ES:DI pointing to the request
<br>
&nbsp;; header. &nbsp;Each routine should return AX = 0 if function was
<br>
&nbsp;; completed successfully or AX = (8000h + error code) if
<br>
&nbsp;; function failed.
<br>
<br>
<br>
&nbsp;MediaChk proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 1 = media check
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;MediaChk endp
<br>
<br>
<br>
&nbsp;BuildBPB proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 2 = build BPB
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;BuildBPB endp
<br>
<br>
<br>
&nbsp;IoctlRd proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 3 = IOCTL read
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;IoctlRd endp
<br>
&nbsp;Read &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 4 = read (input)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;Read &nbsp; &nbsp;endp
<br>
<br>
<br>
&nbsp;NdRead &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 5 = nondestructive read
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;NdRead &nbsp;endp
<br>
<br>
<br>
&nbsp;InpStat proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 6 = input status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;InpStat endp
<br>
<br>
<br>
&nbsp;InpFlush proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 7 = flush input buffers
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;InpFlush endp
<br>
<br>
<br>
&nbsp;Write &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 8 = write (output)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;Write &nbsp; endp
<br>
<br>
<br>
&nbsp;WriteVfy proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 9 = write with verify
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
&nbsp;endp
<br>
<br>
<br>
&nbsp;OutStat proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 10 = output status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;OutStat endp
<br>
<br>
<br>
&nbsp;OutFlush proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 11 = flush output buffers
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;OutFlush endp
<br>
<br>
<br>
&nbsp;IoctlWt proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 12 = IOCTL write
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;IoctlWt endp
<br>
<br>
<br>
&nbsp;DevOpen proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 13 = device open
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;DevOpen endp
<br>
<br>
<br>
&nbsp;DevClose proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 14 = device close
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;DevClose endp
<br>
&nbsp;RemMedia proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 15 = removable media
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;RemMedia endp
<br>
<br>
<br>
&nbsp;OutBusy proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 16 = output until busy
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;OutBusy endp
<br>
<br>
<br>
&nbsp;GenIOCTL proc &nbsp; near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 19 = generic IOCTL
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;GenIOCTL endp
<br>
<br>
<br>
&nbsp;GetLogDev proc &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 23 = get logical device
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;GetLogDev endp
<br>
<br>
<br>
&nbsp;SetLogDev proc &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 24 = set logical device
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;SetLogDev endp
<br>
<br>
<br>
&nbsp;Error &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bad command code in request header
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,8003h &nbsp; &nbsp; &nbsp; &nbsp;; error bit + &quot;unknown command&quot; code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
&nbsp; &nbsp;endp
<br>
<br>
<br>
&nbsp;Init &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 0 = initialize driver
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;es &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save address of request header
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;di
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,cs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; convert load address to ASCII
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset Ident1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;hexasc
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display driver sign-on message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset Ident
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; di &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore request-header address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; es
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set address of free memory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; above driver (break address)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr es:[di+14],offset Init
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr es:[di+16],cs
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret
<br>
<br>
&nbsp;Init &nbsp; &nbsp;endp
<br>
<br>
<br>
&nbsp;hexasc &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; converts word to hex ASCII
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call with AX = value,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:BX = address for string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns AX, BX destroyed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;dx
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; initialize character counter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; isolate next four bits
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rol &nbsp; &nbsp; ax,cl
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; cx,0fh
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; cx,'0' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; convert to ASCII
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; cx,'9' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; is it 0-9?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jbe &nbsp; &nbsp; hexasc2 &nbsp; &nbsp; &nbsp; &nbsp; ; yes, jump
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; cx,'A'-'9'-1 &nbsp; &nbsp;; add fudge factor for A-F
<br>
<br>
&nbsp;hexasc2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; store this character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; [bx],cl
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bump string pointer
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dec &nbsp; &nbsp; dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; count characters converted
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; hexasc1 &nbsp; &nbsp; &nbsp; &nbsp; ; loop, not four yet
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to caller
<br>
<br>
&nbsp;hexasc &nbsp;endp
<br>
<br>
<br>
&nbsp;Ident &nbsp; db &nbsp; &nbsp; &nbsp;cr,lf,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Advanced MS-DOS Example Device Driver'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Device driver header at: '
<br>
&nbsp;Ident1 &nbsp;db &nbsp; &nbsp; &nbsp;'XXXX:0000'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf,lf,eom
<br>
<br>
&nbsp;Intr &nbsp; &nbsp;endp
<br>
<br>
&nbsp;_TEXT &nbsp; ends
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 14-9. &nbsp;DRIVER.ASM: A functional skeleton from which you can
<br>
&nbsp;implement your own working device driver.
<br>
<br>
&nbsp;The driver's device header must be located at the beginning of the file
<br>
&nbsp;(offset 0000H). Both words in the link field in the header should be set
<br>
&nbsp;to -1. The attribute word must be set up correctly for the device type and
<br>
&nbsp;other options. The offsets to the strategy and interrupt routines must be
<br>
&nbsp;relative to the same segment base as the device header itself. If the
<br>
&nbsp;driver is for a character device, the name field should be filled in
<br>
&nbsp;properly with the device's logical name. The logical name can be any legal
<br>
&nbsp;8-character filename, padded with spaces and without a colon. Beware of
<br>
&nbsp;accidentally duplicating the names of existing character devices, unless
<br>
&nbsp;you are intentionally superseding a resident driver.
<br>
<br>
&nbsp;MS-DOS calls the strategy and interrupt routines for the device by means
<br>
&nbsp;of an intersegment call (CALL FAR) when the driver is first loaded and
<br>
&nbsp;installed and again whenever an application program issues an I/O request
<br>
&nbsp;for the device. MS-DOS uses the ES:BX registers to pass the strat routine
<br>
&nbsp;a double-word pointer to the request header; this address should be saved
<br>
&nbsp;internally in the driver so that it is available for use during the
<br>
&nbsp;subsequent call to the intr routine.
<br>
<br>
&nbsp;The command-code routines for function codes 0 through 12 (0CH) must be
<br>
&nbsp;present in every installable device driver, regardless of device type.
<br>
&nbsp;Functions 13 (0DH) and above are optional for drivers used with MS-DOS
<br>
&nbsp;versions 3.0 and later and can be handled in one of the following ways:
<br>
<br>
&nbsp;■ &nbsp;Don't implement them, and leave the associated bits in the device
<br>
&nbsp; &nbsp; header cleared. The resulting driver will work in either version 2 or
<br>
&nbsp; &nbsp; version 3 but does not take full advantage of the augmented
<br>
&nbsp; &nbsp; functionality of version 3.
<br>
<br>
&nbsp;■ &nbsp;Implement them, and test the MS-DOS version during the initialization
<br>
&nbsp; &nbsp; sequence, setting bits 6 and 11 of the device header appropriately.
<br>
&nbsp; &nbsp; Write all command-code routines so that they test this bit and adjust
<br>
&nbsp; &nbsp; to accommodate the host version of MS-DOS. Such a driver requires more
<br>
&nbsp; &nbsp; work and testing but will take full advantage of both the version 2 and
<br>
&nbsp; &nbsp; the version 3 environments.
<br>
<br>
&nbsp;■ &nbsp;Implement them, and assume that all the version 3 facilities are
<br>
&nbsp; &nbsp; available. With this approach, the resulting driver may not work
<br>
&nbsp; &nbsp; properly under version 2.
<br>
<br>
&nbsp;Remember that device drivers must preserve the integrity of MS-DOS. The
<br>
&nbsp;driver must preserve all registers, including flags (especially the
<br>
&nbsp;direction flag and interrupt enable bits), and if the driver makes heavy
<br>
&nbsp;use of the stack, it should switch to an internal stack of adequate depth
<br>
&nbsp;(the MS-DOS stack has room for only 40 to 50 bytes when a driver is
<br>
&nbsp;called).
<br>
<br>
&nbsp;If you install a new CON driver, be sure to set the bits for standard
<br>
&nbsp;input and standard output in the device attribute word in the device
<br>
&nbsp;header.
<br>
<br>
&nbsp;You'll recall that one file can contain multiple drivers. In this case,
<br>
&nbsp;the device-header link field of each driver should point to the segment
<br>
&nbsp;offset of the next, all using the same segment base, and the link field
<br>
&nbsp;for the last driver in the file should be set to -1,-1. The initialization
<br>
&nbsp;routines for all the drivers in the file should return the same break
<br>
&nbsp;address.
<br>
<br>
Linking
<br>
<br>
&nbsp;Use the standard MS-DOS linker to transform the .OBJ file that is output
<br>
&nbsp;from the assembler into a relocatable .EXE module. Then, use the EXE2BIN
<br>
&nbsp;utility (see Chapter 4) to convert the .EXE file into a memory-image
<br>
&nbsp;program. The extension on the final driver file can be anything, but .BIN
<br>
&nbsp;and .SYS are most commonly used in MS-DOS systems, and it is therefore
<br>
&nbsp;wise to follow one of these conventions.
<br>
<br>
Installation
<br>
<br>
&nbsp;After the driver is assembled, linked, and converted to a .BIN or .SYS
<br>
&nbsp;file, copy it to the root directory of a bootable disk. If it is a
<br>
&nbsp;character-device driver, do not use the same name for the file as you used
<br>
&nbsp;for the logical device listed in the driver's header, or you will not be
<br>
&nbsp;able to delete, copy, or rename the file after the driver is loaded.
<br>
<br>
&nbsp;Use your favorite text editor to add the line
<br>
<br>
&nbsp; &nbsp;DEVICE=[D:][PATH]FILENAME.EXT
<br>
<br>
&nbsp;to the CONFIG.SYS file on the bootable disk. (In this line, D: is an
<br>
&nbsp;optional drive designator and FILENAME.EXT is the name of the file
<br>
&nbsp;containing your new device driver. You can include a path specification in
<br>
&nbsp;the entry if you prefer not to put the driver file in your root
<br>
&nbsp;directory.) Now restart your computer system to load the modified
<br>
&nbsp;CONFIG.SYS file.
<br>
<br>
&nbsp;During the MS-DOS boot sequence, the SYSINIT module (which is part of
<br>
&nbsp;IO.SYS) reads and processes the CONFIG.SYS file. It loads the driver into
<br>
&nbsp;memory and inspects the device header. If the driver is a character-device
<br>
&nbsp;driver, SYSINIT links it into the device chain ahead of the other
<br>
&nbsp;character devices; if it is a block-device driver, SYSINIT places it
<br>
&nbsp;behind all previously linked block devices and the resident block devices
<br>
&nbsp;(Figures 14-10, 14-11, and 14-12). It accomplishes the linkage by
<br>
&nbsp;updating the link field in the device header to point to the segment and
<br>
&nbsp;offset of the next driver in the chain. The link field of the last driver
<br>
&nbsp;in the chain contains -1,-1.
<br>
<br>
&nbsp;Next, SYSINIT calls the strat routine with a request header that contains
<br>
&nbsp;a command code of zero, and then it calls the intr routine. The driver
<br>
&nbsp;executes its initialization routine and returns the break address, telling
<br>
&nbsp;MS-DOS how much memory to reserve for this driver. Now MS-DOS can proceed
<br>
&nbsp;to the next entry in the CONFIG.SYS file.
<br>
<br>
&nbsp;You cannot supersede a built-in block-device driver──you can only add
<br>
&nbsp;supplemental block devices. However, you can override the default system
<br>
&nbsp;driver for a character device (such as CON) with an installed driver by
<br>
&nbsp;giving it the same logical-device name in the device header. When
<br>
&nbsp;processing a character I/O request, MS-DOS always scans the list of
<br>
&nbsp;installed drivers before it scans the list of default devices and takes
<br>
&nbsp;the first match.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NUL
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CON
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AUX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PRN
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CLOCK
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp;Any other resident block
<br>
&nbsp; &nbsp;or character devices
<br>
<br>
&nbsp;Figure 14-10. &nbsp;MS-DOS device-driver chain before any installable device
<br>
&nbsp;drivers have been loaded.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NUL
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp; Installable character-
<br>
&nbsp; &nbsp; &nbsp; device drivers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CON
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AUX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PRN
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CLOCK
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp;Any other resident block
<br>
&nbsp; &nbsp;or character devices
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;│
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<br>
&nbsp; &nbsp; Installable block-
<br>
&nbsp; &nbsp; &nbsp; device drivers
<br>
<br>
&nbsp;Figure 14-11. &nbsp;MS-DOS device-driver chain after installable device drivers
<br>
&nbsp;have been loaded.
<br>
<br>
&nbsp;Address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Attribute &nbsp;Strategy &nbsp; &nbsp;Interrupt &nbsp;Type &nbsp;Units Name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;routine &nbsp; &nbsp; routine
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;00E3:0111 &nbsp; &nbsp; &nbsp; &nbsp;8004 &nbsp; &nbsp; &nbsp; 0FD5 &nbsp; &nbsp; &nbsp; &nbsp;0FE0 &nbsp; &nbsp; &nbsp; C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NUL
<br>
&nbsp;0070:0148 &nbsp; &nbsp; &nbsp; &nbsp;8013 &nbsp; &nbsp; &nbsp; 008E &nbsp; &nbsp; &nbsp; &nbsp;0099 &nbsp; &nbsp; &nbsp; C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CON
<br>
&nbsp;0070:01DD &nbsp; &nbsp; &nbsp; &nbsp;8000 &nbsp; &nbsp; &nbsp; 008E &nbsp; &nbsp; &nbsp; &nbsp;009F &nbsp; &nbsp; &nbsp; C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AUX
<br>
&nbsp;0070:028E &nbsp; &nbsp; &nbsp; &nbsp;8000 &nbsp; &nbsp; &nbsp; 008E &nbsp; &nbsp; &nbsp; &nbsp;00AE &nbsp; &nbsp; &nbsp; C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PRN
<br>
&nbsp;0070:0300 &nbsp; &nbsp; &nbsp; &nbsp;8008 &nbsp; &nbsp; &nbsp; 008E &nbsp; &nbsp; &nbsp; &nbsp;00C3 &nbsp; &nbsp; &nbsp; C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CLOCK
<br>
&nbsp;0070:03CC &nbsp; &nbsp; &nbsp; &nbsp;0000 &nbsp; &nbsp; &nbsp; 008E &nbsp; &nbsp; &nbsp; &nbsp;00C9 &nbsp; &nbsp; &nbsp; B &nbsp; &nbsp; 02
<br>
&nbsp;0070:01EF &nbsp; &nbsp; &nbsp; &nbsp;8000 &nbsp; &nbsp; &nbsp; 008E &nbsp; &nbsp; &nbsp; &nbsp;009F &nbsp; &nbsp; &nbsp; C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COM1
<br>
&nbsp;0070:02A0 &nbsp; &nbsp; &nbsp; &nbsp;8000 &nbsp; &nbsp; &nbsp; 008E &nbsp; &nbsp; &nbsp; &nbsp;00AE &nbsp; &nbsp; &nbsp; C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LPT1
<br>
&nbsp;0070:06F0 &nbsp; &nbsp; &nbsp; &nbsp;8000 &nbsp; &nbsp; &nbsp; 008E &nbsp; &nbsp; &nbsp; &nbsp;00B4 &nbsp; &nbsp; &nbsp; C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LPT2
<br>
&nbsp;0070:0702 &nbsp; &nbsp; &nbsp; &nbsp;8000 &nbsp; &nbsp; &nbsp; 008E &nbsp; &nbsp; &nbsp; &nbsp;00BA &nbsp; &nbsp; &nbsp; C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LPT3
<br>
&nbsp;0070:0714 &nbsp; &nbsp; &nbsp; &nbsp;8000 &nbsp; &nbsp; &nbsp; 008E &nbsp; &nbsp; &nbsp; &nbsp;00A5 &nbsp; &nbsp; &nbsp; C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COM2
<br>
&nbsp;End of
<br>
&nbsp;device chain
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 14-12. &nbsp;Example listing of device chain under MS-DOS version 2.1,
<br>
&nbsp;&quot;plain vanilla&quot; IBM PC with no fixed disks or user device drivers.
<br>
&nbsp;(C=character device, B=block device)
<br>
<br>
<br>
Debugging a Device Driver
<br>
<br>
&nbsp;The most important thing to remember when testing new device drivers is to
<br>
&nbsp;maintain adequate backups and a viable fallback position. Don't modify the
<br>
&nbsp;CONFIG.SYS file and install the new driver on your fixed disk before it is
<br>
&nbsp;proven! Be prudent──create a bootable floppy disk and put the modified
<br>
&nbsp;CONFIG.SYS file and the new driver on that for debugging. When everything
<br>
&nbsp;is working properly, copy the finished product to its permanent storage
<br>
&nbsp;medium.
<br>
<br>
&nbsp;The easiest way to test a new device driver is to write a simple
<br>
&nbsp;assembly-language front-end routine that sets up a simulated request
<br>
&nbsp;packet and then performs FAR CALLs to the strat and intr entry points,
<br>
&nbsp;exactly as MS-DOS would. You can then link the driver and the front end
<br>
&nbsp;together into a .COM or .EXE file that can be run under the control of
<br>
&nbsp;CodeView or another debugger. This arrangement makes it easy to trace each
<br>
&nbsp;of the command-code routines individually, to observe the results of the
<br>
&nbsp;I/O, and to examine the status codes returned in the request header.
<br>
<br>
&nbsp;Tracing the installed driver when it is linked into the MS-DOS system in
<br>
&nbsp;the normal manner is more difficult. Breakpoints must be chosen carefully,
<br>
&nbsp;to yield the maximum possible information per debugging run. Because
<br>
&nbsp;current versions of MS-DOS maintain only one request header internally,
<br>
&nbsp;the request header that was being used by the driver you are tracing will
<br>
&nbsp;be overwritten as soon as your debugger makes an output request to display
<br>
&nbsp;information. You will find it helpful to add a routine to your
<br>
&nbsp;initialization subroutine that displays the driver's load address on the
<br>
&nbsp;console when you boot MS-DOS; you can then use this address to inspect the
<br>
&nbsp;device-driver header and set breakpoints within the body of the driver.
<br>
<br>
&nbsp;Debugging a device driver can also be somewhat sticky when interrupt
<br>
&nbsp;handling is involved, especially if the device uses the same
<br>
&nbsp;interrupt-request priority level (IRQ level) as other peripherals in the
<br>
&nbsp;system. Cautious, conservative programming is needed to avoid unexpected
<br>
&nbsp;and unreproducible interactions with other device drivers and interrupt
<br>
&nbsp;handlers. If possible, prove out the basic logic of the driver using
<br>
&nbsp;polled I/O, rather than interrupt-driven I/O, and introduce interrupt
<br>
&nbsp;handling only when you know the rest of the driver's logic to be solid.
<br>
<br>
&nbsp;Typical device-driver errors or problems that can cause system crashes or
<br>
&nbsp;strange system behavior include the following:
<br>
<br>
&nbsp;■ &nbsp;Failure to set the linkage address of the last driver in a file to -1
<br>
<br>
&nbsp;■ &nbsp;Overflow of the MS-DOS stack by driver-initialization code, corrupting
<br>
&nbsp; &nbsp; the memory image of MS-DOS (can lead to unpredictable behavior during
<br>
&nbsp; &nbsp; boot; remedy is to use a local stack)
<br>
<br>
&nbsp;■ &nbsp;Incorrect break-address reporting by the initialization routine (can
<br>
&nbsp; &nbsp; lead to a system crash if the next driver loaded overwrites vital parts
<br>
&nbsp; &nbsp; of the driver)
<br>
<br>
&nbsp;■ &nbsp;Improper BPBs supplied by the build BPB routine, or incorrect BPB
<br>
&nbsp; &nbsp; pointer array supplied by the initialization routine (can lead to many
<br>
&nbsp; &nbsp; confusing problems, ranging from out-of-memory errors to system boot
<br>
&nbsp; &nbsp; failure)
<br>
<br>
&nbsp;■ &nbsp;Incorrect reporting of the number of bytes or sectors successfully
<br>
&nbsp; &nbsp; transferred at the time an I/O error occurs (can manifest itself as a
<br>
&nbsp; &nbsp; system crash after you enter R to the Abort, Retry, Ignore? prompt)
<br>
<br>
&nbsp;Although the interface between the DOS kernel and the device driver is
<br>
&nbsp;fairly simple, it is also quite strict. The command-code routines must
<br>
&nbsp;perform exactly as they are defined, or the system will behave
<br>
&nbsp;erratically. Even a very subtle discrepancy in the action of a
<br>
&nbsp;command-code routine can have unexpectedly large global effects.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 15 &nbsp;Filters
<br>
<br>
&nbsp;A filter is, essentially, a program that operates on a stream of
<br>
&nbsp;characters. The source and destination of the character stream can be
<br>
&nbsp;files, another program, or almost any character device. The transformation
<br>
&nbsp;applied by the filter to the character stream can range from an operation
<br>
&nbsp;as simple as character substitution to one as elaborate as generating
<br>
&nbsp;splines from sets of coordinates.
<br>
<br>
&nbsp;The standard MS-DOS package includes three simple filters: SORT, which
<br>
&nbsp;alphabetically sorts text on a line-by-line basis; FIND, which searches a
<br>
&nbsp;text stream to match a specified string; and MORE, which displays text one
<br>
&nbsp;screenful at a time.
<br>
<br>
<br>
System Support for Filters
<br>
<br>
&nbsp;The operation of a filter program relies on two MS-DOS features that first
<br>
&nbsp;appeared in version 2.0: standard devices and redirectable I/O.
<br>
<br>
&nbsp;The standard devices are represented by five handles that are originally
<br>
&nbsp;established by COMMAND.COM. Each process inherits these handles from its
<br>
&nbsp;immediate parent. Thus, the standard device handles are already open when
<br>
&nbsp;a process acquires control of the system, and it can use them with
<br>
&nbsp;Interrupt 21H Functions 3FH and 40H for read and write operations
<br>
&nbsp;without further preliminaries. The default assignments of the standard
<br>
&nbsp;device handles are as follows:
<br>
<br>
&nbsp;Handle &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Default device
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stdin (standard input) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CON
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stdout (standard output) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CON
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stderr (standard error) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CON
<br>
&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stdaux (standard auxiliary) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AUX
<br>
&nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stdprn (standard printer) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PRN
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The CON device is assigned by default to the system's keyboard and video
<br>
&nbsp;display. AUX and PRN are respectively associated by default with COM1 (the
<br>
&nbsp;first physical serial port) and LPT1 (the first parallel printer port).
<br>
&nbsp;You can use the MODE command to redirect LPT1 to one of the serial ports;
<br>
&nbsp;the MODE command will also redirect PRN.
<br>
<br>
&nbsp;When executing a program by entering its name at the COMMAND.COM prompt,
<br>
&nbsp;you can redirect the standard input, the standard output, or both from
<br>
&nbsp;their default device (CON) to another file, a character device, or a
<br>
&nbsp;process. You do this by including one of the special characters &lt;, &gt;, &gt;&gt;,
<br>
&nbsp;and | in the command line, in the form shown on the following page.
<br>
<br>
&nbsp;Symbol &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Effect
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;&lt; file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Takes standard input from the specified file instead of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the keyboard.
<br>
<br>
&nbsp;&lt; device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Takes standard input from the named device instead of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the keyboard.
<br>
<br>
&nbsp;&gt; file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sends standard output to the specified file instead of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the display.
<br>
<br>
&nbsp;&gt;&gt; file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Appends standard output to the current contents of the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specified file instead of sending it to the display.
<br>
<br>
&nbsp;&gt; device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sends standard output to the named device instead of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the display.
<br>
<br>
&nbsp;p1 | p2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Routes standard output of program p1 to become the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standard input of program p2. (Output of p1 is said to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; be piped to p2.)
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;For example, the command
<br>
<br>
&nbsp;C&gt;SORT &lt;MYFILE.TXT &gt;PRN &lt;Enter&gt;
<br>
<br>
&nbsp;causes the SORT filter to read its input from the file MYFILE.TXT, sort
<br>
&nbsp;the lines alphabetically, and write the resulting text to the character
<br>
&nbsp;device PRN (the logical name for the system's list device).
<br>
<br>
&nbsp;The redirection requested by the &lt;, &gt;, &gt;&gt;, and | characters takes place at
<br>
&nbsp;the level of COMMAND.COM and is invisible to the program it affects. Any
<br>
&nbsp;other process can achieve a similar effect by redirecting the standard
<br>
&nbsp;input and standard output with Int 21H Function 46H before calling the
<br>
&nbsp;EXEC function (Int 21H Function 4BH) to run a child process.
<br>
<br>
&nbsp;Note that if a program circumvents MS-DOS to perform its input and output,
<br>
&nbsp;either by calling ROM BIOS functions or by manipulating the keyboard or
<br>
&nbsp;video controller directly, redirection commands placed in the program's
<br>
&nbsp;command line do not have the expected effect.
<br>
<br>
<br>
How Filters Work
<br>
<br>
&nbsp;By convention, a filter program reads its text from the standard input
<br>
&nbsp;device and writes the results of its operations to the standard output
<br>
&nbsp;device. When it reaches the end of the input stream, the filter simply
<br>
&nbsp;terminates. As a result, filters are both flexible and simple.
<br>
<br>
&nbsp;Filter programs are flexible because they do not know, and do not care
<br>
&nbsp;about, the source of the data they process or the destination of their
<br>
&nbsp;output. Thus, any character device that has a logical name within the
<br>
&nbsp;system (CON, AUX, COM1, COM2, PRN, LPT1, LPT2, LPT3, and so on), any file
<br>
&nbsp;on any block device (local or network) known to the system, or any other
<br>
&nbsp;program can supply a filter's input or accept its output. If necessary,
<br>
&nbsp;you can concatenate several functionally simple filters with pipes to
<br>
&nbsp;perform very complex operations.
<br>
<br>
&nbsp;Although flexible, filters are also simple because they rely on their
<br>
&nbsp;parent processes to supply standard input and standard output handles that
<br>
&nbsp;have already been appropriately redirected. The parent must open or create
<br>
&nbsp;any necessary files, check the validity of logical character-device names,
<br>
&nbsp;and load and execute the preceding or following process in a pipe. The
<br>
&nbsp;filter concerns itself only with the transformation it applies to the
<br>
&nbsp;data.
<br>
<br>
<br>
Building a Filter
<br>
<br>
&nbsp;Creating a new filter for MS-DOS is a straightforward process. In its
<br>
&nbsp;simplest form, a filter need only use the handle-oriented read (Interrupt
<br>
&nbsp;21H Function 3FH) and write (Interrupt 21H Function 40H) functions to
<br>
&nbsp;get characters or lines from standard input and send them to standard
<br>
&nbsp;output, performing any desired alterations on the text stream on a
<br>
&nbsp;character-by-character or line-by-line basis.
<br>
<br>
&nbsp;Figures 15-1 and 15-2 contain prototype character-oriented filters in
<br>
&nbsp;both assembly language and C. In these examples, the translate routine,
<br>
&nbsp;which is called for each character transferred from the standard input to
<br>
&nbsp;the standard output, does nothing at all. As a result, both filters
<br>
&nbsp;function rather like a very slow COPY command. You can quickly turn these
<br>
&nbsp;primitive filters into useful programs by substituting your own translate
<br>
&nbsp;routine.
<br>
<br>
&nbsp;If you try out these programs, you'll notice that the C prototype filter
<br>
&nbsp;runs much faster than its MASM equivalent. This is because the C runtime
<br>
&nbsp;library is performing hidden blocking and deblocking of the input and
<br>
&nbsp;output stream, whereas the MASM filter is doing exactly what it appears to
<br>
&nbsp;be doing: making two calls to MS-DOS for each character processed. You can
<br>
&nbsp;easily restore the MASM filter's expected speed advantage by adapting it
<br>
&nbsp;to read and write lines instead of single characters.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name &nbsp; &nbsp; &nbsp;proto
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page &nbsp; &nbsp; &nbsp;55,132
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title &nbsp; &nbsp; PROTO.ASM--prototype filter
<br>
&nbsp;;
<br>
&nbsp;; PROTO.ASM: &nbsp;prototype character-oriented filter
<br>
&nbsp;;
<br>
&nbsp;; Copyright 1988 Ray Duncan
<br>
&nbsp;;
<br>
<br>
&nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard input handle
<br>
&nbsp;stdout &nbsp;equ &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp;stderr &nbsp;equ &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard error handle
<br>
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII linefeed
<br>
<br>
&nbsp;_TEXT &nbsp; segment word public 'CODE'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assume &nbsp;cs:_TEXT,ds:_DATA,ss:STACK
<br>
<br>
&nbsp;main &nbsp; &nbsp;proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; entry point from MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp;; set DS = our data segment
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax
<br>
<br>
&nbsp;main1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read char from stdin...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset char &nbsp;; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = length to read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdin &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard input handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 3fh = read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;main3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; if error, terminate
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; any character read?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; main2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; if end of file, terminate
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;translate &nbsp; &nbsp; &nbsp; ; translate character
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write char to stdout...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset char &nbsp;; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = length to write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; BX = standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;main3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; if error, terminate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; was character written?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; main3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; if disk full, terminate
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; main1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get another character
<br>
<br>
&nbsp;main2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; end of file reached
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch = terminate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;main3: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; error or disk full
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c01h &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch = terminate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code = 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;main &nbsp; &nbsp;endp
<br>
<br>
&nbsp;;
<br>
&nbsp;; Perform any necessary translation on character
<br>
&nbsp;; from standard input stored in variable 'char'.
<br>
&nbsp;; This example simply leaves character unchanged.
<br>
&nbsp;;
<br>
&nbsp;translate proc &nbsp;near
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; does nothing
<br>
<br>
&nbsp;translate endp
<br>
<br>
&nbsp;_TEXT &nbsp; ends
<br>
<br>
<br>
&nbsp;_DATA &nbsp; segment word public 'DATA'
<br>
<br>
&nbsp;char &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; storage for input character
<br>
<br>
&nbsp;_DATA &nbsp; ends
<br>
<br>
<br>
&nbsp;STACK &nbsp; segment para stack 'STACK'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;64 dup (?)
<br>
<br>
&nbsp;STACK &nbsp; ends
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end &nbsp; &nbsp; main &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; defines program entry point
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 15-1. &nbsp;PROTO.ASM, the source code for a prototype
<br>
&nbsp;character-oriented MASM filter.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;PROTO.C: &nbsp;prototype character-oriented filter
<br>
<br>
&nbsp; &nbsp; &nbsp;Copyright 1988 Ray Duncan
<br>
&nbsp;*/
<br>
<br>
&nbsp;#include &lt;stdio.h&gt;
<br>
<br>
&nbsp;main(int argc, char *argv[])
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;char ch;
<br>
<br>
&nbsp; &nbsp; &nbsp;while((ch=getchar()) != EOF) &nbsp; &nbsp;/* read a character &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ch = translate(ch); &nbsp; &nbsp; &nbsp; &nbsp; /* translate it if necessary &nbsp; */
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;putchar(ch); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* write the character &nbsp; &nbsp; &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp;}
<br>
&nbsp; &nbsp; &nbsp;exit(0); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* terminate at end of file &nbsp; &nbsp;*/
<br>
&nbsp;}
<br>
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;Perform any necessary translation on character
<br>
&nbsp; &nbsp; &nbsp;from input file. This example simply returns
<br>
&nbsp; &nbsp; &nbsp;the same character.
<br>
&nbsp;*/
<br>
<br>
&nbsp;int translate(char ch)
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;return (ch);
<br>
&nbsp;}
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 15-2. &nbsp;PROTO.C, the source code for a prototype character-oriented
<br>
&nbsp;C filter.
<br>
<br>
<br>
The CLEAN Filter
<br>
<br>
&nbsp;As a more practical example of MS-DOS filters, let's look at a simple but
<br>
&nbsp;very useful filter called CLEAN. Figures 15-3 and 15-4 show the
<br>
&nbsp;assembly-language and C source code for this filter. CLEAN processes a
<br>
&nbsp;text stream by stripping the high bit from all characters, expanding tabs
<br>
&nbsp;to spaces, and throwing away all control codes except carriage returns,
<br>
&nbsp;linefeeds, and formfeeds. Consequently, CLEAN can transform almost any
<br>
&nbsp;kind of word-processed document file into a plain ASCII text file.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;clean
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page &nbsp; &nbsp;55,132
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;title &nbsp; CLEAN--Text-file filter
<br>
&nbsp;;
<br>
&nbsp;; CLEAN.ASM &nbsp; &nbsp; Filter to turn document files into
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; normal text files.
<br>
&nbsp;;
<br>
&nbsp;; Copyright 1988 Ray Duncan
<br>
&nbsp;;
<br>
&nbsp;; Build: &nbsp; &nbsp; &nbsp; &nbsp;C&gt;MASM CLEAN;
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C&gt;LINK CLEAN;
<br>
&nbsp;;
<br>
&nbsp;; Usage: &nbsp; &nbsp; &nbsp; &nbsp;C&gt;CLEAN &nbsp;&lt;infile &nbsp;&gt;outfile
<br>
&nbsp;;
<br>
&nbsp;; All text characters are passed through with high
<br>
&nbsp;; bit stripped off. Formfeeds, carriage returns,
<br>
&nbsp;; and linefeeds are passed through. Tabs are expanded
<br>
&nbsp;; to spaces. All other control codes are discarded.
<br>
&nbsp;;
<br>
<br>
&nbsp;tab &nbsp; &nbsp; equ &nbsp; &nbsp; 09h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII tab code
<br>
&nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII linefeed
<br>
&nbsp;ff &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII formfeed
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;blank &nbsp; equ &nbsp; &nbsp; 020h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ASCII space code
<br>
&nbsp;eof &nbsp; &nbsp; equ &nbsp; &nbsp; 01ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Ctrl-Z end-of-file
<br>
<br>
&nbsp;tabsiz &nbsp;equ &nbsp; &nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; width of tab stop
<br>
<br>
&nbsp;bufsiz &nbsp;equ &nbsp; &nbsp; 128 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; size of input and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; output buffers
<br>
<br>
&nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; standard input handle
<br>
&nbsp;stdout &nbsp;equ &nbsp; &nbsp; 0001 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; standard output handle
<br>
&nbsp;stderr &nbsp;equ &nbsp; &nbsp; 0002 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; standard error handle
<br>
<br>
<br>
&nbsp;_TEXT &nbsp; segment word public 'CODE'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assume &nbsp;cs:_TEXT,ds:_DATA,es:_DATA,ss:STACK
<br>
<br>
&nbsp;clean &nbsp; proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; entry point from MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save DS:0000 for final
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ax,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to MS-DOS, in case
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch can't be used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,_DATA &nbsp; &nbsp; &nbsp; &nbsp;; make data segment addressable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,ax
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,30h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; check version of MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; MS-DOS 2.0 or later?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jae &nbsp; &nbsp; clean1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if version OK
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; MS-DOS 1, display error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; message and exit...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg1 &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 9 = display string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; then exit the old way
<br>
<br>
&nbsp;clean1: call &nbsp; &nbsp;init &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; initialize input buffer
<br>
<br>
&nbsp;clean2: call &nbsp; &nbsp;getc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get character from input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;clean9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; exit if end of stream
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; al,07fh &nbsp; &nbsp; &nbsp; &nbsp; ; strip off high bit
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,blank &nbsp; &nbsp; &nbsp; &nbsp;; is it a control char?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jae &nbsp; &nbsp; clean4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; no, write it
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,eof &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; is it end of file?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;clean8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; yes, write EOF and exit
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,tab &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; is it a tab?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;clean6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; yes, expand it to spaces
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,cr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is it a carriage return?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;clean3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; yes, go process it
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,lf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is it a linefeed?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;clean3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; yes, go process it
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,ff &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; is it a formfeed?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; clean2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; no, discard it
<br>
<br>
&nbsp;clean3: mov &nbsp; &nbsp; column,0 &nbsp; &nbsp; &nbsp; &nbsp;; if CR, LF, or FF,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; clean5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; reset column to zero
<br>
<br>
&nbsp;clean4: inc &nbsp; &nbsp; column &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if non-control character,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; increment column counter
<br>
&nbsp;clean5: call &nbsp; &nbsp;putc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write char to stdout
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnc &nbsp; &nbsp; clean2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if disk not full,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get another character
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write failed...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg2 &nbsp;; DS:DX = error message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg2_len &nbsp; &nbsp; ; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stderr &nbsp; &nbsp; &nbsp; ; BX = standard error handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c01h &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch = terminate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code = 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;clean6: mov &nbsp; &nbsp; ax,column &nbsp; &nbsp; &nbsp; ; tab code detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cwd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; tabsiz - (column MOD tabsiz)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,tabsiz &nbsp; &nbsp; &nbsp; ; is number of spaces needed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;idiv &nbsp; &nbsp;cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to move to next tab stop
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub &nbsp; &nbsp; cx,dx
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; column,cx &nbsp; &nbsp; &nbsp; ; also update column counter
<br>
<br>
&nbsp;clean7: push &nbsp; &nbsp;cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save spaces counter
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,blank &nbsp; &nbsp; &nbsp; &nbsp;; write an ASCII space
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;putc
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore spaces counter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop &nbsp; &nbsp;clean7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; loop until tab stop
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; clean2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get another character
<br>
<br>
&nbsp;clean8: call &nbsp; &nbsp;putc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write EOF mark
<br>
<br>
&nbsp;clean9: call &nbsp; &nbsp;flush &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; write last output buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4c00h &nbsp; &nbsp; &nbsp; &nbsp;; function 4ch = terminate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;clean &nbsp; endp
<br>
<br>
<br>
&nbsp;getc &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get character from stdin
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns carry = 1 if
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; end of input, else
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AL = char, carry = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,iptr &nbsp; &nbsp; &nbsp; &nbsp; ; get input buffer pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; bx,ilen &nbsp; &nbsp; &nbsp; &nbsp; ; end of buffer reached?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; getc1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; not yet, jump
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; more data is needed...
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdin &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard input handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,bufsiz &nbsp; &nbsp; &nbsp; ; CX = length to read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset ibuff ; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 3fh = read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;getc2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if read failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;ax,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; was anything read?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;getc2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if end of input
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ilen,ax &nbsp; &nbsp; &nbsp; &nbsp; ; save length of data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; bx,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; reset buffer pointer
<br>
<br>
&nbsp;getc1: &nbsp;mov &nbsp; &nbsp; al,[ibuff+bx] &nbsp; ; get character from buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bump buffer pointer
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; iptr,bx &nbsp; &nbsp; &nbsp; &nbsp; ; save updated pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;clc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return character in AL
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and carry = 0 (clear)
<br>
<br>
&nbsp;getc2: &nbsp;stc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; end of input stream
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return carry = 1 (set)
<br>
<br>
&nbsp;getc &nbsp; &nbsp;endp
<br>
<br>
<br>
&nbsp;putc &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; send character to stdout,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns carry = 1 if
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; error, else carry = 0
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,optr &nbsp; &nbsp; &nbsp; &nbsp; ; store character into
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; [obuff+bx],al &nbsp; ; output buffer
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bump buffer pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; bx,bufsiz &nbsp; &nbsp; &nbsp; ; buffer full?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; putc1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, jump
<br>
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; BX = standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,bufsiz &nbsp; &nbsp; &nbsp; ; CX = length to write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset obuff ; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;putc2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if write failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; was write complete?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; putc2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if disk full
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; bx,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; reset buffer pointer
<br>
<br>
&nbsp;putc1: &nbsp;mov &nbsp; &nbsp; optr,bx &nbsp; &nbsp; &nbsp; &nbsp; ; save buffer pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;clc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; write successful,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return carry = 0 (clear)
<br>
<br>
&nbsp;putc2: &nbsp;stc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; write failed or disk full,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return carry = 1 (set)
<br>
<br>
&nbsp;putc &nbsp; &nbsp;endp
<br>
<br>
<br>
&nbsp;init &nbsp; &nbsp;proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; initialize input buffer
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdin &nbsp; &nbsp; &nbsp; &nbsp;; BX = standard input handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,bufsiz &nbsp; &nbsp; &nbsp; ; CX = length to read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset ibuff ; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 3fh = read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;init1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if read failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ilen,ax &nbsp; &nbsp; &nbsp; &nbsp; ; save actual bytes read
<br>
&nbsp;init1: &nbsp;ret
<br>
<br>
&nbsp;init &nbsp; &nbsp;endp
<br>
<br>
<br>
&nbsp;flush &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; flush output buffer
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,optr &nbsp; &nbsp; &nbsp; &nbsp; ; CX = bytes to write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jcxz &nbsp; &nbsp;flush1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; exit if buffer empty
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset obuff ; DS:DX = buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; BX = standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp;flush1: ret
<br>
<br>
&nbsp;flush &nbsp; endp
<br>
<br>
&nbsp;_TEXT &nbsp; ends
<br>
&nbsp;_DATA &nbsp; segment word public 'DATA'
<br>
<br>
&nbsp;ibuff &nbsp; db &nbsp; &nbsp; &nbsp;bufsiz dup (0) &nbsp;; input buffer
<br>
&nbsp;obuff &nbsp; db &nbsp; &nbsp; &nbsp;bufsiz dup (0) &nbsp;; output buffer
<br>
<br>
&nbsp;iptr &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ibuff pointer
<br>
&nbsp;ilen &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; bytes in ibuff
<br>
&nbsp;optr &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; obuff pointer
<br>
<br>
&nbsp;column &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; current column counter
<br>
<br>
&nbsp;msg1 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'clean: need MS-DOS version 2 or greater.'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf,'$'
<br>
<br>
&nbsp;msg2 &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'clean: disk is full.'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp;msg2_len equ &nbsp; &nbsp;$-msg2
<br>
<br>
&nbsp;_DATA &nbsp; ends
<br>
<br>
<br>
&nbsp;STACK &nbsp; segment para stack 'STACK'
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;64 dup (?)
<br>
<br>
&nbsp;STACK &nbsp; ends
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end &nbsp; &nbsp; clean
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 15-3. &nbsp;CLEAN.ASM, the source code for the MASM version of the CLEAN
<br>
&nbsp;filter.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;CLEAN.C &nbsp; &nbsp; Filter to turn document files into
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;normal text files.
<br>
<br>
&nbsp; &nbsp; &nbsp;Copyright 1988 Ray Duncan
<br>
<br>
&nbsp; &nbsp; &nbsp;Compile: &nbsp; &nbsp;C&gt;CL CLEAN.C
<br>
<br>
&nbsp; &nbsp; &nbsp;Usage: &nbsp; &nbsp; &nbsp;C&gt;CLEAN &nbsp;&lt;infile &gt;outfile
<br>
<br>
&nbsp; &nbsp; &nbsp;All text characters are passed through with high bit stripped
<br>
&nbsp; &nbsp; &nbsp;off. Formfeeds, carriage returns, and linefeeds are passed
<br>
&nbsp; &nbsp; &nbsp;through. Tabs are expanded to spaces. All other control codes
<br>
&nbsp; &nbsp; &nbsp;are discarded.
<br>
&nbsp;*/
<br>
<br>
&nbsp;#include &lt;stdio.h&gt;
<br>
<br>
&nbsp;#define TAB_WIDTH &nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* width of a tab stop &nbsp; &nbsp; */
<br>
&nbsp;#define TAB &nbsp; &nbsp; '\x09' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* ASCII tab character &nbsp; &nbsp; */
<br>
&nbsp;#define LF &nbsp; &nbsp; &nbsp;'\x0A' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* ASCII linefeed &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp;#define FF &nbsp; &nbsp; &nbsp;'\x0C' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* ASCII formfeed &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp;#define CR &nbsp; &nbsp; &nbsp;'\x0D' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* ASCII carriage return &nbsp; */
<br>
&nbsp;#define BLANK &nbsp; '\x20' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* ASCII space code &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp;#define EOFMK &nbsp; '\x1A' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Ctrl-Z end of file &nbsp; &nbsp; &nbsp;*/
<br>
<br>
<br>
&nbsp;main(int argc, char *argv[])
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;char c; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* character from stdin &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;int col = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* column counter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
<br>
&nbsp; &nbsp; &nbsp;while((c = getchar()) != EOF) &nbsp;/* read input character &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c &amp;= 0x07F; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* strip high bit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;switch(c) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* decode character &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case LF: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* if linefeed or &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case CR: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* carriage return, &nbsp; &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;col=0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* reset column count &nbsp; &nbsp; &nbsp;*/
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case FF: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* if formfeed, carriage &nbsp; */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wchar(c); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* return, or linefeed, &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* pass character through &nbsp;*/
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case TAB: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* if tab, expand to spaces*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do wchar(BLANK);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while((++col % TAB_WIDTH) != 0);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* discard other control &nbsp; */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(c &gt;= BLANK) &nbsp; &nbsp; /* characters, pass text &nbsp; */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* characters through &nbsp; &nbsp; &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wchar(c);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;col++; &nbsp; &nbsp; &nbsp; &nbsp; /* bump column counter &nbsp; &nbsp; */
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
<br>
&nbsp; &nbsp; &nbsp;}
<br>
&nbsp; &nbsp; &nbsp;wchar(EOFMK); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* write end-of-file mark &nbsp;*/
<br>
&nbsp; &nbsp; &nbsp;exit(0);
<br>
&nbsp;}
<br>
<br>
<br>
&nbsp;/*
<br>
&nbsp; &nbsp; &nbsp;Write a character to the standard output. If
<br>
&nbsp; &nbsp; &nbsp;write fails, display error message and terminate.
<br>
&nbsp;*/
<br>
<br>
&nbsp;wchar(char c)
<br>
&nbsp;{
<br>
&nbsp; &nbsp; &nbsp;if((putchar(c) == EOF) &amp;&amp; (c != EOFMK))
<br>
&nbsp; &nbsp; &nbsp;{
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fputs(&quot;clean: disk full&quot;,stderr);
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit(1);
<br>
&nbsp; &nbsp; &nbsp;}
<br>
&nbsp;}
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 15-4. &nbsp;CLEAN.C, the source code for the C version of the CLEAN
<br>
&nbsp;filter.
<br>
<br>
&nbsp;When using the CLEAN filter, you must specify the source and destination
<br>
&nbsp;files with redirection parameters in the command line; otherwise, CLEAN
<br>
&nbsp;will simply read the keyboard and write to the display. For example, to
<br>
&nbsp;filter the document file MYFILE.DOC and leave the result in the file
<br>
&nbsp;MYFILE.TXT, you would enter the following command:
<br>
<br>
&nbsp;C&gt;CLEAN &lt;MYFILE.DOC &gt;MYFILE.TXT &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;(Note that the original file, MYFILE.DOC, is unchanged.)
<br>
<br>
&nbsp;One valuable application of this filter is to rescue assembly-language
<br>
&nbsp;source files. If you accidentally edit such a source file in document
<br>
&nbsp;mode, the resulting file may cause the assembler to generate spurious or
<br>
&nbsp;confusing error messages. CLEAN lets you turn the source file back into
<br>
&nbsp;something the assembler can cope with, without losing the time you spent
<br>
&nbsp;to edit it.
<br>
<br>
&nbsp;Another handy application for CLEAN is to list a word-processed document
<br>
&nbsp;in raw form on the printer, using a command such as
<br>
<br>
&nbsp;C&gt;CLEAN &lt;MYFILE.DOC &gt;PRN &nbsp;&lt;Enter&gt;
<br>
<br>
&nbsp;Contrasting the C and assembly-language versions of this filter provides
<br>
&nbsp;some interesting statistics. The C version contains 79 lines and compiles
<br>
&nbsp;to a 5889-byte .EXE file, whereas the assembly-language version contains
<br>
&nbsp;265 lines and builds an 1107-byte .EXE file. The size and execution-speed
<br>
&nbsp;advantages of implementing such tools in assembly language is obvious,
<br>
&nbsp;even compared with such an excellent compiler as the Microsoft C
<br>
&nbsp;Optimizing Compiler. However, you must balance performance considerations
<br>
&nbsp;against the time and expense required for programming, particularly when a
<br>
&nbsp;program will not be used very often.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Chapter 16 &nbsp;Compatibility and Portability
<br>
<br>
&nbsp;At the beginning of this book, we surveyed the history of MS-DOS and saw
<br>
&nbsp;that new versions come along nearly every year, loosely coupled to the
<br>
&nbsp;introduction of new models of personal computers. We then focused on each
<br>
&nbsp;of the mainstream issues of MS-DOS applications programming: the user
<br>
&nbsp;interface; mass storage; memory management; control of &quot;child&quot; processes;
<br>
&nbsp;and special classes of programs, such as filters, interrupt handlers, and
<br>
&nbsp;device drivers.
<br>
<br>
&nbsp;It's now time to close the circle and consider two global concerns of
<br>
&nbsp;MS-DOS programming: compatibility and portability. For your programs to
<br>
&nbsp;remain useful in a constantly evolving software and hardware environment,
<br>
&nbsp;you must design them so that they perform reliably on any reasonable
<br>
&nbsp;machine configuration and exploit available system resources; in addition,
<br>
&nbsp;you should be able to upgrade them easily for new versions of MS-DOS, for
<br>
&nbsp;new machines, and, for that matter, for completely new environments such
<br>
&nbsp;as MS OS/2.
<br>
<br>
<br>
Degrees of Compatibility
<br>
<br>
&nbsp;If we look at how existing MS-DOS applications use the operating system
<br>
&nbsp;and hardware, we find that we can assign them to one of four categories:
<br>
<br>
&nbsp;■ &nbsp;MS-DOS─compatible applications
<br>
<br>
&nbsp;■ &nbsp;ROM BIOS─compatible applications
<br>
<br>
&nbsp;■ &nbsp;Hardware-compatible applications
<br>
<br>
&nbsp;■ &nbsp;&quot;Ill-behaved&quot; applications
<br>
<br>
&nbsp;MS-DOS─compatible applications use only the documented MS-DOS function
<br>
&nbsp;calls and do not call the ROM BIOS or access the hardware directly. They
<br>
&nbsp;use ANSI escape sequences for screen control, and their input and output
<br>
&nbsp;is redirectable. An MS-DOS─compatible application will run on any machine
<br>
&nbsp;that supports MS-DOS, regardless of the machine configuration. Because of
<br>
&nbsp;the relatively poor performance of MS-DOS's built-in display and serial
<br>
&nbsp;port drivers, few popular programs other than compilers, assemblers, and
<br>
&nbsp;linkers fall into this category.
<br>
<br>
&nbsp;ROM BIOS─compatible applications use the documented MS-DOS and ROM BIOS
<br>
&nbsp;function calls but do not access the hardware directly. As recently as
<br>
&nbsp;three years ago, this strategy might have significantly limited a
<br>
&nbsp;program's potential market. Today, the availability of high-quality
<br>
&nbsp;IBM-compatible ROM BIOSes from companies such as Phoenix has ensured the
<br>
&nbsp;dominance of the IBM ROM BIOS standard; virtually no machines are being
<br>
&nbsp;sold in which a program cannot rely as much on the ROM BIOS interface as
<br>
&nbsp;it might on the MS-DOS interface. However, as we noted in Chapters 6 and
<br>
&nbsp;7, the ROM BIOS display and serial drivers are still not adequate to the
<br>
&nbsp;needs of high-performance interactive applications, so the popular
<br>
&nbsp;programs that fall into this category are few.
<br>
<br>
&nbsp;Hardware-compatible applications generally use MS-DOS functions for mass
<br>
&nbsp;storage, memory management, and the like, and use a mix of MS-DOS and ROM
<br>
&nbsp;BIOS function calls and direct hardware access for their user interfaces.
<br>
&nbsp;The amount of hardware dependence in such programs varies widely. For
<br>
&nbsp;example, some programs only write characters and attributes into the video
<br>
&nbsp;controller's regen buffer and use the ROM BIOS to switch modes and
<br>
&nbsp;position the cursor; others bypass the ROM BIOS video driver altogether
<br>
&nbsp;and take complete control of the video adapter. As this book is written,
<br>
&nbsp;the vast majority of the popular MS-DOS &quot;productivity&quot; applications (word
<br>
&nbsp;processors, databases, telecommunications programs, and so on) can be
<br>
&nbsp;placed somewhere in this category.
<br>
<br>
&nbsp;&quot;Ill-behaved&quot; applications are those that rely on undocumented MS-DOS
<br>
&nbsp;function calls or data structures, interception of MS-DOS or ROM BIOS
<br>
&nbsp;interrupts, or direct access to mass storage devices (bypassing the MS-DOS
<br>
&nbsp;file system). These programs tend to be extremely sensitive to their
<br>
&nbsp;environment and typically must be &quot;adjusted&quot; in order to work with each
<br>
&nbsp;new MS-DOS version or PC model. Virtually all popular terminate-
<br>
&nbsp;and-stay-resident (TSR) utilities, network programs, and disk
<br>
&nbsp;repair/optimization packages are in this category.
<br>
<br>
Writing Well-Behaved MS-DOS Applications
<br>
<br>
&nbsp;Your choice of MS-DOS functions, ROM BIOS functions, or direct hardware
<br>
&nbsp;access to solve a particular problem must always be balanced against
<br>
&nbsp;performance needs; and, of course, the user is the final judge of a
<br>
&nbsp;program's usefulness and reliability. Nevertheless, you can follow some
<br>
&nbsp;basic guidelines, outlined below, to create well-behaved applications that
<br>
&nbsp;are likely to run properly under future versions of MS-DOS and under
<br>
&nbsp;multitasking program managers that run on top of MS-DOS, such as Microsoft
<br>
&nbsp;Windows.
<br>
<br>
&nbsp;Program structure
<br>
<br>
&nbsp;Design your programs as .EXE files with separate code, data, and stack
<br>
&nbsp;segments; shun the use of .COM files. Use the Microsoft conventions for
<br>
&nbsp;segment names and attributes discussed in Chapter 3. Inspect the
<br>
&nbsp;environment block at runtime to locate your program's overlays or data
<br>
&nbsp;files; don't &quot;hard-wire&quot; a directory location into the program.
<br>
<br>
&nbsp;Check host capabilities
<br>
<br>
&nbsp;Obtain the MS-DOS version number with Int 21H Function 30H during your
<br>
&nbsp;program's initialization and be sure that all of the functions your
<br>
&nbsp;program requires are actually available. If you find that the host MS-DOS
<br>
&nbsp;version is inadequate, be careful about which functions you call to
<br>
&nbsp;display an error message and to terminate.
<br>
<br>
&nbsp;Use the enhanced capabilities of MS-DOS versions 3 and 4 when your program
<br>
&nbsp;is running under those versions. For example, you can specify a sharing
<br>
&nbsp;mode when opening a file with Int 21H Function 3DH, you can create
<br>
&nbsp;temporary or unique files with Int 21H Functions 5AH and 5BH, and you
<br>
&nbsp;can obtain extended error information (including a recommended recovery
<br>
&nbsp;strategy) with Int 21H Function 59H. Section 2 of this book contains
<br>
&nbsp;version-dependency information for each MS-DOS function.
<br>
<br>
&nbsp;Input and output
<br>
<br>
&nbsp;Use the handle file functions exclusively and extend full path support
<br>
&nbsp;throughout your application (being sure to allow for the maximum possible
<br>
&nbsp;path length during user input of filenames). Use buffered I/O whenever
<br>
&nbsp;possible. The device drivers in MS-DOS versions 2.0 and later can handle
<br>
&nbsp;strings as long as 64 KB, and performance will be improved if you write
<br>
&nbsp;fewer, larger records as opposed to many short ones.
<br>
<br>
&nbsp;Avoid the use of FCBs, the Int 25H or Int 26H functions, or the ROM BIOS
<br>
&nbsp;disk driver. If you must use FCBs, close them when you are done with them
<br>
&nbsp;and don't move them around while they are open. Avoid reopening FCBs that
<br>
&nbsp;are already open or reclosing FCBs that have already been closed──these
<br>
&nbsp;seemingly harmless practices can cause problems when network software is
<br>
&nbsp;running.
<br>
<br>
&nbsp;Memory management
<br>
<br>
&nbsp;During your program's initialization, release any memory that is not
<br>
&nbsp;needed by the program. (This is especially important for .COM programs.)
<br>
&nbsp;If your program requires extra memory for buffers or tables, allocate that
<br>
&nbsp;memory dynamically when it is needed and release it as soon as it is no
<br>
&nbsp;longer required. Use expanded memory, when it is available, to minimize
<br>
&nbsp;your program's demands on conventional memory.
<br>
<br>
&nbsp;As a general rule, don't touch any memory that is not owned by your
<br>
&nbsp;program. To set or inspect interrupt vectors, use Int 21H Functions 25H
<br>
&nbsp;and 35H rather than editing the interrupt vector table directly. If you
<br>
&nbsp;alter the contents of interrupt vectors, save their original values and
<br>
&nbsp;restore them before the program exits.
<br>
<br>
&nbsp;Process management
<br>
<br>
&nbsp;To isolate your program from dependencies on PSP structure and relocation
<br>
&nbsp;information, use the EXEC function (Int 21H Function 4BH) when loading
<br>
&nbsp;overlays or other programs. Terminate your program with Int 21H Function
<br>
&nbsp;4CH, passing a zero return code if the program executes successfully and
<br>
&nbsp;a nonzero code if an error is encountered. Your program's parent can then
<br>
&nbsp;test this return code with Int 21H Function 4DH or, in a batch file, with
<br>
&nbsp;the IF ERRORLEVEL statement.
<br>
<br>
&nbsp;Exception handling
<br>
<br>
&nbsp;Install Ctrl-C (Int 23H) and critical-error (Int 24H) handlers so that
<br>
&nbsp;your program cannot be terminated unexpectedly by the user's entry of
<br>
&nbsp;Ctrl-C or Ctrl-Break or by a hardware I/O failure. This is particularly
<br>
&nbsp;important if your program uses expanded memory or installs its own
<br>
&nbsp;interrupt handlers.
<br>
<br>
ROM BIOS and Hardware-Compatible Applications
<br>
<br>
&nbsp;When you feel the need to introduce ROM BIOS or hardware dependence for
<br>
&nbsp;performance reasons, keep it isolated to small, well-documented procedures
<br>
&nbsp;that can be easily modified when the hardware changes. Use macros and
<br>
&nbsp;equates to hide hardware characteristics and to avoid spreading &quot;magic
<br>
&nbsp;numbers&quot; throughout your program.
<br>
<br>
&nbsp;Check host capabilities
<br>
<br>
&nbsp;If you use ROM BIOS functions in your program, you must check the machine
<br>
&nbsp;model at runtime to be sure that the functions your program needs are
<br>
&nbsp;actually available. There is a machine ID byte at F000:FFFEH whose value
<br>
&nbsp;is interpreted as follows:
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;F8H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PS/2 Models 70 and 80
<br>
<br>
&nbsp;F9H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC Convertible
<br>
<br>
&nbsp;FAH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PS/2 Model 30
<br>
<br>
&nbsp;FBH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC/XT (later models)
<br>
<br>
&nbsp;FCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC/AT, PC/XT-286, PS/2 Models 50 and 60
<br>
<br>
&nbsp;FDH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PCjr
<br>
<br>
&nbsp;FEH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC/XT (early models)
<br>
<br>
&nbsp;FFH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PC &quot;Classic&quot;
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;In some cases, submodels can be identified; see Int 15H Function C0H on
<br>
&nbsp;page 573. Section 3 of this book contains version-dependency information
<br>
&nbsp;for each ROM BIOS function.
<br>
<br>
&nbsp;When writing your own direct video drivers, you must determine the type
<br>
&nbsp;and capabilities of the video adapter by a combination of Int 10H calls,
<br>
&nbsp;reading ports, and inspection of the ROM BIOS data area at 0040:0000H and
<br>
&nbsp;the memory reserved for the EGA or VGA ROM BIOS, among other things. The
<br>
&nbsp;techniques required are beyond the scope of this book but are well
<br>
&nbsp;explained in Programmer's Guide to PC and PS/2 Video Systems (Microsoft
<br>
&nbsp;Press, 1987).
<br>
<br>
&nbsp;Avoid unstable hardware
<br>
<br>
&nbsp;Some areas of IBM personal computer architecture have remained remarkably
<br>
&nbsp;stable from the original IBM PC, based on a 4.77 MHz 8088, to today's PS/2
<br>
&nbsp;Model 80, based on a 20 MHz 80386. IBM's track record for upward
<br>
&nbsp;compatibility in its video and serial communications controllers has been
<br>
&nbsp;excellent; in many cases, the same hardware-dependent code that was
<br>
&nbsp;written for the original IBM PC runs perfectly well on an IBM PS/2 Model
<br>
&nbsp;80. Other areas of relative hardware stability are:
<br>
<br>
&nbsp;■ &nbsp;Sound control via port 61H
<br>
<br>
&nbsp;■ &nbsp;The 8253 timer chip's channels 0 and 2 (ports 40H, 42H, and 43H)
<br>
<br>
&nbsp;■ &nbsp;The game adapter at port 201H
<br>
<br>
&nbsp;■ &nbsp;Control of the interrupt system via the 8259 PIC's mask register at
<br>
&nbsp; &nbsp; port 21H
<br>
<br>
&nbsp;However, direct sound generation and manipulation of the 8253 timer or
<br>
&nbsp;8259 PIC are quite likely to cause problems if your program is run under a
<br>
&nbsp;multitasking program manager such as Microsoft Windows or DesqView.
<br>
<br>
&nbsp;Keyboard mapping, the keyboard controller, and the floppy and fixed disk
<br>
&nbsp;controllers are areas of relative hardware instability. Programs that
<br>
&nbsp;bypass MS-DOS for keyboard or disk access are much less likely to function
<br>
&nbsp;properly across the different PC models and are also prone to interfere
<br>
&nbsp;with each other and with well-behaved applications.
<br>
<br>
<br>
OS/2 Compatibility
<br>
<br>
&nbsp;MS-DOS is upwardly compatible in several respects with OS/2, Microsoft's
<br>
&nbsp;multitasking protected-mode virtual memory operating system for 80286 and
<br>
&nbsp;80386 computers. The OS/2 graphical user interface (the Presentation
<br>
&nbsp;Manager) is nearly identical to Microsoft Windows 2.0. OS/2 versions 1.0
<br>
&nbsp;and 1.1 use exactly the same disk formats as MS-DOS so that files may
<br>
&nbsp;easily be moved between MS-DOS and OS/2 systems. Most important, OS/2
<br>
&nbsp;includes a module called the &quot;DOS Compatibility Environment&quot; or &quot;3.x Box,&quot;
<br>
&nbsp;which can run one MS-DOS application at a time alongside protected-mode
<br>
&nbsp;OS/2 applications.
<br>
<br>
&nbsp;The 3.x Box traps Int 21H function calls and remaps them into OS/2
<br>
&nbsp;function calls, emulating an MS-DOS 3.3 environment with the file-sharing
<br>
&nbsp;module (SHARE.EXE) loaded but returning a major version number of 10
<br>
&nbsp;instead of 3 for Int 21H Function 30H. The 3.x Box also supports most ROM
<br>
&nbsp;BIOS calls, either by emulating their function or by interlocking the
<br>
&nbsp;device and then calling the original ROM BIOS routine. In addition, the
<br>
&nbsp;3.x Box maintains the ROM BIOS data area, provides timer ticks to
<br>
&nbsp;applications via Int 1CH, and supports certain undocumented MS-DOS
<br>
&nbsp;services and data structures so that most TSR utilities can function
<br>
&nbsp;properly. Nevertheless, the 3.x Box's emulation of MS-DOS is not perfect,
<br>
&nbsp;and you must be aware of certain constraints on MS-DOS applications
<br>
&nbsp;running under OS/2.
<br>
<br>
&nbsp;The most significant restriction on an MS-DOS application is that it does
<br>
&nbsp;not receive any CPU cycles when it is in the background. That is, when a
<br>
&nbsp;protected-mode application has been &quot;selected,&quot; so that the user can
<br>
&nbsp;interact with it, the MS-DOS application is frozen. If the MS-DOS
<br>
&nbsp;application has captured any interrupt vectors (such as the serial port or
<br>
&nbsp;timer tick), these interrupts will not be serviced until the application
<br>
&nbsp;is again selected and in the foreground. OS/2 must freeze MS-DOS
<br>
&nbsp;applications when they are in the background because they execute in real
<br>
&nbsp;mode and are thus not subject to hardware memory protection; nothing else
<br>
&nbsp;ensures that they will not interfere with a protected-mode process that
<br>
&nbsp;has control of the screen and keyboard.
<br>
<br>
&nbsp;Use of FCBs is restricted in the 3.x Box, as it is under MS-DOS 3 or 4
<br>
&nbsp;with SHARE.EXE loaded. A file cannot be opened with an FCB if any other
<br>
&nbsp;process is using it. The number of FCBs that can be simultaneously opened
<br>
&nbsp;is limited to 16 or to the number specified in a CONFIG.SYS FCBS=
<br>
&nbsp;directive. Even when the handle file functions are used, these functions
<br>
&nbsp;may fail unexpectedly due to the activity of other processes (for example,
<br>
&nbsp;if a protected-mode process has already opened the file with &quot;deny all&quot;
<br>
&nbsp;sharing mode); most MS-DOS applications are not written with file sharing
<br>
&nbsp;in mind, and they do not handle such errors gracefully.
<br>
<br>
&nbsp;Direct writes to a fixed disk using Int 26H or Int 13H are not allowed.
<br>
&nbsp;This prevents the file system from being corrupted, because protected-mode
<br>
&nbsp;applications running concurrently with the MS-DOS application may also be
<br>
&nbsp;writing to the same disk. Imagine the mess if a typical MS-DOS unerase
<br>
&nbsp;utility were to alter the root directory and FAT at the same time that a
<br>
&nbsp;protected-mode database program was updating its file and indexes!
<br>
<br>
&nbsp;MS-DOS applications that attempt to reprogram the 8259 to move the
<br>
&nbsp;interrupt vector table or that modify interrupt vectors already belonging
<br>
&nbsp;to an OS/2 device driver are terminated by the operating system. MS-DOS
<br>
&nbsp;applications can change the 8259's interrupt-mask register, disable and
<br>
&nbsp;reenable interrupts at their discretion, and read or write any I/O port.
<br>
&nbsp;The obvious corollary is that an MS-DOS program running in the 3.x Box can
<br>
&nbsp;crash the entire OS/2 system at any time; this is the price for allowing
<br>
&nbsp;real-mode applications to run at all.
<br>
<br>
Porting MS-DOS Applications to OS/2
<br>
<br>
&nbsp;The application program interface (API) provided by OS/2 to protected-mode
<br>
&nbsp;programs is quite different from the familiar Int 21H interface of MS-DOS
<br>
&nbsp;and the OS/2 3.x Box. However, the OS/2 API is functionally a proper
<br>
&nbsp;superset of MS-DOS. This makes it easy to convert well-behaved MS-DOS
<br>
&nbsp;applications to run in OS/2 protected mode, whence they can be enhanced to
<br>
&nbsp;take advantage of OS/2's virtual memory, multitasking, and interprocess
<br>
&nbsp;communication capabilities.
<br>
<br>
&nbsp;To give you a feeling for both the nature of the OS/2 API and the
<br>
&nbsp;practices that should be avoided in MS-DOS programming if portability to
<br>
&nbsp;OS/2 is desired, I will outline my own strategy for converting existing
<br>
&nbsp;MS-DOS assembly-language programs to OS/2. For the purposes of discussion,
<br>
&nbsp;I have divided the conversion process into five steps and have assigned
<br>
&nbsp;each an easily remembered buzzword:
<br>
<br>
&nbsp;1. &nbsp;Segmentation
<br>
<br>
&nbsp;2. &nbsp;Rationalization
<br>
<br>
&nbsp;3. &nbsp;Encapsulation
<br>
<br>
&nbsp;4. &nbsp;Conversion
<br>
<br>
&nbsp;5. &nbsp;Optimization
<br>
<br>
&nbsp;The first three stages can (and should) be performed and tested in the
<br>
&nbsp;MS-DOS environment; only the last two require OS/2 and the protected-mode
<br>
&nbsp;programming tools. As you read on, you may notice that an MS-DOS program
<br>
&nbsp;that follows the compatibility guidelines presented earlier in this
<br>
&nbsp;chapter requires relatively little work to make it run in protected mode.
<br>
&nbsp;This is the natural benefit of working with the operating system instead
<br>
&nbsp;of against it.
<br>
<br>
&nbsp;Segmentation
<br>
<br>
&nbsp;Most of the 80286's protected-mode capabilities revolve around a change in
<br>
&nbsp;the way memory is addressed. In real mode, the 80286 essentially emulates
<br>
&nbsp;an 8088/86 processor, and the value in a segment register corresponds
<br>
&nbsp;directly to a physical memory address. MS-DOS runs on the 80286 in real
<br>
&nbsp;mode.
<br>
<br>
&nbsp;When an 80286 is running in protected mode, as it does under OS/2, an
<br>
&nbsp;additional level of indirection is added to memory addressing.
<br>
Although the 80386 has additional modes and addressing capabilities,
<br>
current versions of OS/2 use the 80386 as though it were an 80286.
<br>
A segment
<br>
&nbsp;register holds a selector, which is an index to a table of descriptors. A
<br>
&nbsp;descriptor defines the physical address and length of a memory segment,
<br>
&nbsp;its characteristics (executable, read-only data, or read/write data) and
<br>
&nbsp;access rights, and whether the segment is currently resident in RAM or has
<br>
&nbsp;been swapped out to disk. Each time a program loads a segment register or
<br>
&nbsp;accesses memory, the 80286 hardware checks the associated descriptor and
<br>
&nbsp;the program's privilege level, generating a fault if the selector or
<br>
&nbsp;memory operation is not valid. The fault acts like a hardware interrupt,
<br>
&nbsp;allowing the operating system to regain control and take the appropriate
<br>
&nbsp;action.
<br>
<br>
&nbsp;This scheme of memory addressing in protected mode has two immediate
<br>
&nbsp;consequences for application programs. The first is that application
<br>
&nbsp;programs can no longer perform arithmetic on the contents of segment
<br>
&nbsp;registers (because selectors are magic numbers and have no direct
<br>
&nbsp;relationship to physical memory addresses) or use segment registers for
<br>
&nbsp;storage of temporary values. A program must not load a segment register
<br>
&nbsp;with anything but a legitimate selector provided by the OS/2 loader or
<br>
&nbsp;resulting from an OS/2 memory allocation function call. The second
<br>
&nbsp;consequence is that a program must strictly segregate machine code
<br>
&nbsp;(&quot;text&quot;) from data, placing them in separate segments with distinct
<br>
&nbsp;selectors (because a selector that is executable is not writable, and vice
<br>
&nbsp;versa).
<br>
<br>
&nbsp;Accordingly, the first step in converting a program for OS/2 is to turn it
<br>
&nbsp;into a .EXE-type program that uses the Microsoft segment, class, and group
<br>
&nbsp;conventions described in Chapter 3. At minimum, the program must have one
<br>
&nbsp;code segment and one data segment, and should declare a group──with the
<br>
&nbsp;special name DGROUP──that contains the &quot;near&quot; data segment, stack, and
<br>
&nbsp;local heap (if any). At the same time, you should remove or rewrite any
<br>
&nbsp;code that performs direct manipulation of segment values.
<br>
<br>
&nbsp;After restructuring and segmentation, reassemble and link your program and
<br>
&nbsp;check to be sure it still works as expected under MS-DOS. Changing or
<br>
&nbsp;adding segmentation often uncovers hidden addressing assumptions in the
<br>
&nbsp;code, so it is best to track these problems down before making other
<br>
&nbsp;substantive changes to the program.
<br>
<br>
&nbsp;Rationalization
<br>
<br>
&nbsp;Once you've successfully segmented your program so that it can be linked
<br>
&nbsp;and executed as a .EXE file under MS-DOS, the next step is to rationalize
<br>
&nbsp;your code. By rationalization I mean converting your program into a
<br>
&nbsp;completely well-behaved MS-DOS application.
<br>
<br>
&nbsp;First, you must ruthlessly eliminate any elements that manipulate the
<br>
&nbsp;peripheral device adapters directly, alter interrupt priorities, edit the
<br>
&nbsp;system interrupt-vector table, or depend on CPU speed or characteristics
<br>
&nbsp;(such as timing loops). In protected mode, control of the interrupt system
<br>
&nbsp;is completely reserved to the operating system and its device drivers, I/O
<br>
&nbsp;ports may be read or written by an application only under very specific
<br>
&nbsp;conditions, and timing loops burn up CPU cycles that can be used by other
<br>
&nbsp;processes.
<br>
<br>
&nbsp;As I mentioned earlier in this chapter, display routines constitute the
<br>
&nbsp;most common area of hardware dependence in an MS-DOS application. Direct
<br>
&nbsp;manipulation of the video adapter and its regen buffer poses obvious
<br>
&nbsp;difficulties in a multitasking, protected-memory environment such as OS/2.
<br>
&nbsp;For porting purposes, you must convert all routines that write text to the
<br>
&nbsp;display, modify character attributes, or affect cursor shape or position
<br>
&nbsp;into Int 21H Function 40H calls using ANSI escape sequences or into ROM
<br>
&nbsp;BIOS Int 10H calls. Similarly, you must convert all hardware-dependent
<br>
&nbsp;keyboard operations to Int 21H Function 3FH or ROM BIOS Int 16H calls.
<br>
<br>
&nbsp;Once all hardware dependence has been expunged from your program, your
<br>
&nbsp;next priority is to make it well-behaved in its use of system memory.
<br>
&nbsp;Under MS-DOS an application is typically handed all remaining memory in
<br>
&nbsp;the system to do with as it will; under OS/2 the converse is true: A
<br>
&nbsp;process is initially allocated only enough memory to hold its code,
<br>
&nbsp;declared data storage, and stack. You can make the MS-DOS loader behave
<br>
&nbsp;like the OS/2 loader by linking your application with the /CPARMAXALLOC
<br>
&nbsp;switch. Alternatively, your program can give up all extra memory during
<br>
&nbsp;its initialization with Int 21H Function 4AH, as recommended earlier in
<br>
&nbsp;this chapter.
<br>
<br>
&nbsp;After your program completes its initialization sequence, it should
<br>
&nbsp;dynamically obtain and release any additional memory it may require for
<br>
&nbsp;buffers and tables with MS-DOS Int 21H Functions 48H and 49H. To ensure
<br>
&nbsp;compatibility with protected mode, limit the size of any single allocated
<br>
&nbsp;block to 65,536 bytes or less, even though MS-DOS allows larger blocks to
<br>
&nbsp;be allocated.
<br>
<br>
&nbsp;Finally, you must turn your attention to file and device handling. Replace
<br>
&nbsp;any calls to FCB file functions with their handle-based equivalents,
<br>
&nbsp;because OS/2 does not support FCBs in protected mode at all. Check
<br>
&nbsp;pathnames for validity within the application; although MS-DOS and the 3.x
<br>
&nbsp;Box silently truncate a name or extension, OS/2 refuses to open or create
<br>
&nbsp;a file in protected mode if the name or extension is too long and returns
<br>
&nbsp;an error instead. Replace any use of the predefined handles for the
<br>
&nbsp;standard auxiliary and standard list devices with explicit opens of COM1,
<br>
&nbsp;PRN, LPT1, and so on, using the resulting handle for read and write
<br>
&nbsp;operations. OS/2 does not supply processes with standard handles for the
<br>
&nbsp;serial communications port or printer.
<br>
<br>
&nbsp;Encapsulation
<br>
<br>
&nbsp;When you reach this point, with a well-behaved, segmented MS-DOS
<br>
&nbsp;application in hand, the worst of a port to OS/2 is behind you. You are
<br>
&nbsp;now ready to prepare your program for true conversion to protected-mode
<br>
&nbsp;operation by encapsulating, in individual subroutines, every part of the
<br>
&nbsp;program that is specific to the host operating system. The objective here
<br>
&nbsp;is to localize the program's &quot;knowledge&quot; of the environment into small
<br>
&nbsp;procedures that can be subsequently modified without affecting the
<br>
&nbsp;remainder of the program.
<br>
<br>
&nbsp;As an example of encapsulation, consider a typical call by an MS-DOS
<br>
&nbsp;application to write a string to the standard output device (Figure
<br>
&nbsp;16-1). In order to facilitate conversion to OS/2, you would replace every
<br>
&nbsp;instance of such a write to a file or device with a call to a small
<br>
&nbsp;subroutine that &quot;hides&quot; the mechanics of the actual operating-system
<br>
&nbsp;function call, as illustrated in Figure 16-2.
<br>
<br>
&nbsp;Another candidate for encapsulation, which does not necessarily involve an
<br>
&nbsp;operating-system function call, is the application's code to gain access
<br>
&nbsp;to command-line parameters, environment-block variables, and the name of
<br>
&nbsp;the file it was loaded from. Under MS-DOS, this information is divided
<br>
&nbsp;between the program segment prefix (PSP) and the environment block, as we
<br>
&nbsp;saw in Chapters 3 and 12; under OS/2, there is no such thing as a PSP,
<br>
&nbsp;and the program filename and command-line information are appended to the
<br>
&nbsp;environment block.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard input handle
<br>
&nbsp;stdout &nbsp;equ &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp;stderr &nbsp;equ &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard error handle
<br>
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'This is a sample message'
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg msg &nbsp; &nbsp; &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset DGROUP:msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp; &nbsp; &nbsp;; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; BX = handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AH = function 40h write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,msg_len &nbsp; &nbsp; &nbsp;; all characters written?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; diskfull &nbsp; &nbsp; &nbsp; &nbsp;; no, device is full
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 16-1. &nbsp;Typical in-line code for an MS-DOS function call. This
<br>
&nbsp;particular sequence writes a string to the standard output device. Since
<br>
&nbsp;the standard output might be redirected to a file without the program's
<br>
&nbsp;knowledge, it must also check that all of the requested characters were
<br>
&nbsp;actually written; if the returned length is less than the requested
<br>
&nbsp;length, this usually indicates that the standard output has been
<br>
&nbsp;redirected to a disk file and that the disk is full.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard input handle
<br>
&nbsp;stdout &nbsp;equ &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp;stderr &nbsp;equ &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard error handle
<br>
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'This is a sample message'
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg msg &nbsp; &nbsp; &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset DGROUP:msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp; &nbsp; &nbsp;; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; BX = handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; perform the write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,msg_len &nbsp; &nbsp; &nbsp;; all characters written?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; diskfull &nbsp; &nbsp; &nbsp; &nbsp;; no, device is full
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;write &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write to file or device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Call with:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; BX = handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = length of data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:DX = address of data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if successful, carry clear
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and AX = bytes written
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if error, carry set
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and AX = error code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function 40h = write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return status in CY and AX
<br>
<br>
&nbsp;write &nbsp; endp
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 16-2. &nbsp;Code from Figure 16-1 after &quot;encapsulation.&quot; The portion of
<br>
&nbsp;the code that is operating-system dependent has been isolated inside a
<br>
&nbsp;subroutine that is called from other points within the application.
<br>
<br>
&nbsp;When you have completed the encapsulation of system services and access to
<br>
&nbsp;the PSP and environment, subject your program once more to thorough
<br>
&nbsp;testing under MS-DOS. This is your last chance, while you are still
<br>
&nbsp;working in a familiar milieu and have access to your favorite debugging
<br>
&nbsp;tools, to detect any subtle errors you may have introduced during the
<br>
&nbsp;three conversion steps discussed thus far.
<br>
<br>
&nbsp;Conversion
<br>
<br>
&nbsp;Next, you must rewrite each system-dependent procedure you created during
<br>
&nbsp;the encapsulation stage to conform to the OS/2 protected-mode API. In
<br>
&nbsp;contrast to MS-DOS functions, which are actuated through software
<br>
&nbsp;interrupts and pass parameters in registers, OS/2 API functions are
<br>
&nbsp;requested through a far call to a named entry point. Parameters are passed
<br>
&nbsp;on the stack, along with the addresses of variables within the calling
<br>
&nbsp;program's data segment that will receive any results returned by the
<br>
&nbsp;function. The status of an operation is returned in register AX──zero if
<br>
&nbsp;the function succeeded, an error code otherwise. All other registers are
<br>
&nbsp;preserved.
<br>
<br>
&nbsp;Although it is not my intention here to provide a detailed introduction to
<br>
&nbsp;OS/2 programming, Figure 16-3 illustrates the final form of our previous
<br>
&nbsp;example, after conversion for OS/2. Note especially the addition of the
<br>
&nbsp;extrn statement, the wlen variable, and the simulation of the MS-DOS
<br>
&nbsp;function status. This code may not be elegant, but it serves the purpose
<br>
&nbsp;of limiting the necessary changes to a very small portion of the source
<br>
&nbsp;file. Some OS/2 functions (such as DosOpen) require parameters that have
<br>
&nbsp;no counterpart under MS-DOS; you can usually select reasonable values for
<br>
&nbsp;these extra parameters that will make their existence temporarily
<br>
&nbsp;invisible to the remainder of the application.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard input handle
<br>
&nbsp;stdout &nbsp;equ &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp;stderr &nbsp;equ &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard error handle
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;extrn &nbsp; DosWrite:far
<br>
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'This is a sample message'
<br>
&nbsp;msg_len equ &nbsp; &nbsp; $-msg
<br>
<br>
&nbsp;wlen &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; receives actual number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; of bytes written
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg msg &nbsp; &nbsp; &nbsp;; DS:DX = message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset DGROUP:msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,msg_len &nbsp; &nbsp; &nbsp;; CX = message length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; BX = handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; perform the write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,msg_len &nbsp; &nbsp; &nbsp;; all characters written?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; diskfull &nbsp; &nbsp; &nbsp; &nbsp;; no, device is full
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;write &nbsp; proc &nbsp; &nbsp;near &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write to file or device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; call with:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; BX = handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; CX = length of data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DS:DX = address of data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; returns:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if successful, carry clear
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and AX = bytes written
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if error, carry set
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and AX = error code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; address of data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; length of data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; receives length written
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,offset DGROUP:wlen
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;DosWrite &nbsp; &nbsp; &nbsp; &nbsp;; transfer to OS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;ax,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; did write succeed?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; write1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump, write failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,wlen &nbsp; &nbsp; &nbsp; &nbsp; ; no error, OR cleared CY
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and AX := bytes written
<br>
<br>
&nbsp;write1: stc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; write error, return CY set
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; and AX = error number
<br>
<br>
&nbsp;write &nbsp; endp
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 16-3. &nbsp;Code from Figure 16-2 after &quot;conversion.&quot; The MS-DOS
<br>
&nbsp;function call has been replaced with the equivalent OS/2 function call.
<br>
&nbsp;Since the knowledge of the operating system has been hidden inside the
<br>
&nbsp;subroutine by the previous encapsulation step, the surrounding program's
<br>
&nbsp;requests for write operations should run unchanged. Note that the OS/2
<br>
&nbsp;function had to be declared as an external name with the &quot;far&quot; attribute,
<br>
&nbsp;and that a variable named wlen was added to the data segment of the
<br>
&nbsp;application to receive the actual number of bytes written.
<br>
<br>
&nbsp;Figures 16-4, 16-5, and 16-6 list the OS/2 services that are equivalent
<br>
&nbsp;to selected MS-DOS and ROM BIOS Int 21H, Int 10H, and Int 16H calls.
<br>
&nbsp;MS-DOS functions related to FCBs and PSPs are not included in these tables
<br>
&nbsp;because OS/2 does not support either of these structures. The MS-DOS
<br>
&nbsp;terminate-and-stay-resident functions are also omitted. Because OS/2 is a
<br>
&nbsp;true multitasking system, a process doesn't need to terminate in order to
<br>
&nbsp;stay resident while another process is running.
<br>
<br>
<br>
&nbsp;MS-DOS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Description &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OS/2 function
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Int 21H Function
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Terminate process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosExit
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Character input with echo &nbsp; &nbsp; &nbsp; KbdCharIn
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Character output &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;VioWrtTTY
<br>
&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Auxiliary input &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosRead
<br>
&nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Auxiliary output &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosWrite
<br>
&nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Printer output &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosWrite
<br>
&nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Direct console I/O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;KbdCharIn,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VioWrtTTY
<br>
&nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unfiltered input without echo &nbsp; KbdCharIn
<br>
&nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Character input without echo &nbsp; &nbsp;KbdCharIn
<br>
&nbsp;9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Display string &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;VioWrtTTY
<br>
&nbsp;0AH (10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffered keyboard input &nbsp; &nbsp; &nbsp; &nbsp; KbdStringIn
<br>
&nbsp;0BH (11) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Check input status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;KbdPeek
<br>
&nbsp;0CH (12) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reset buffer and input &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;KbdFlushBuffer,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; KbdCharIn
<br>
&nbsp;0DH (13) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Disk reset &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosBufReset
<br>
&nbsp;0EH (14) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosSelectDisk
<br>
&nbsp;19H (25) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get current disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosQCurDisk
<br>
&nbsp;1BH (27) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get default drive data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosQFSInfo
<br>
&nbsp;1CH (28) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get drive data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosQFSInfo
<br>
&nbsp;2AH (42) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosGetDateTime
<br>
&nbsp;2BH (43) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosSetDateTime
<br>
&nbsp;2CH (44) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosGetDateTime
<br>
&nbsp;2DH (45) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosSetDateTime
<br>
&nbsp;2EH (46) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set verify flag &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosSetVerify
<br>
&nbsp;30H (48) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get MS-DOS version &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosGetVersion
<br>
&nbsp;36H (54) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get drive allocation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosQFSInfo
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; information
<br>
&nbsp;38H (56) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get or set country &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosGetCtryInfo
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; information
<br>
&nbsp;39H (57) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Create directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosMkdir
<br>
&nbsp;3AH (58) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Delete directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosRmdir
<br>
&nbsp;3BH (59) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set current directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosChdir
<br>
&nbsp;3CH (60) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Create file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosOpen
<br>
&nbsp;3DH (61) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Open file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosOpen
<br>
&nbsp;3EH (62) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Close file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosClose
<br>
&nbsp;3FH (63) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Read file or device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosRead
<br>
&nbsp;40H (64) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write file or device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosWrite
<br>
&nbsp;41H (65) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Delete file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosDelete
<br>
&nbsp;42H (66) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set file pointer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosChgFilePtr
<br>
&nbsp;43H (67) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get or set file attributes &nbsp; &nbsp; &nbsp;DosQFileMode,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosSetFileMode
<br>
&nbsp;44H (68) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;I/O control (IOCTL) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosDevIOCtl
<br>
&nbsp;45H (69) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Duplicate handle &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosDupHandle
<br>
&nbsp;46H (70) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Redirect handle &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosDupHandle
<br>
&nbsp;47H (71) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get current directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosQCurDir
<br>
&nbsp;48H (72) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Allocate memory block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosAllocSeg
<br>
&nbsp;49H (73) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Release memory block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosFreeSeg
<br>
&nbsp;4AH (74) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Resize memory block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosReAllocSeg
<br>
&nbsp;4BH (75) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Execute program &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosExecPgm
<br>
&nbsp;4CH (76) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Terminate process with &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosExit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return code
<br>
&nbsp;4DH (77) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get return code &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosCWait
<br>
&nbsp;4EH (78) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Find first file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosFindFirst
<br>
&nbsp;4FH (79) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Find next file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosFindNext
<br>
&nbsp;54H (84) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get verify flag &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosQVerify
<br>
&nbsp;56H (86) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rename file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosMove
<br>
&nbsp;57H (87) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get or set file date and time &nbsp; DosQFileInfo,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosSetFileInfo
<br>
&nbsp;59H (89) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get extended error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosErrClass
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; information
<br>
&nbsp;5BH (91) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Create new file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosOpen
<br>
&nbsp;5CH (92) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Lock or unlock file region &nbsp; &nbsp; &nbsp;DosFileLocks
<br>
&nbsp;65H (101) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get extended country &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosGetCtryInfo
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; information
<br>
&nbsp;66H (102) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get or set code page &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosGetCp,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosSetCp
<br>
&nbsp;67H (103) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set handle count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosSetMaxFH
<br>
&nbsp;68H (104) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Commit file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DosBufReset
<br>
&nbsp;6CH (108) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Extended open file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DosOpen
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Figure 16-4. &nbsp;Table of selected MS-DOS function calls and their OS/2
<br>
&nbsp;counterparts. Note that OS/2 functions are typically more powerful and
<br>
&nbsp;flexible than the corresponding MS-DOS functions, and that this is not a
<br>
&nbsp;complete list of OS/2 services.
<br>
<br>
&nbsp;ROM BIOS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Description &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OS/2 function
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Int 10H Function
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Select display mode &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VioSetMode
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set cursor type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VioSetCurType
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set cursor position &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VioSetCurPos
<br>
&nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get cursor position &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VioGetCurPos
<br>
&nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Initialize or scroll window up &nbsp; &nbsp; &nbsp;VioScrollUp
<br>
&nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Initialize or scroll window down &nbsp; &nbsp;VioScrollDn
<br>
&nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read character and attribute &nbsp; &nbsp; &nbsp; &nbsp;VioReadCellStr
<br>
&nbsp;9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write character and attribute &nbsp; &nbsp; &nbsp; VioWrtNCell
<br>
&nbsp;0AH (10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write character &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VioWrtNChar
<br>
&nbsp;0EH (14) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write character in teletype mode &nbsp; &nbsp;VioWrtTTY
<br>
&nbsp;0FH (15) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get display mode &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;VioGetMode
<br>
&nbsp;10H (16) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set palette, border color, etc. &nbsp; &nbsp; VioSetState
<br>
&nbsp;13H (19) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write string in teletype mode &nbsp; &nbsp; &nbsp; VioWrtTTY
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 16-5. &nbsp;Table of ROM BIOS Int 10H video-display driver functions
<br>
&nbsp;used by MS-DOS applications and their OS/2 equivalents. This is not a
<br>
&nbsp;complete list of OS/2 video services.
<br>
<br>
&nbsp;ROM BIOS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Description &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OS/2 function
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Int 16H Function
<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read keyboard character &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; KbdCharIn
<br>
&nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get keyboard status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; KbdPeek
<br>
&nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get keyboard flags &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;KbdGetStatus
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Figure 16-6. &nbsp;Table of ROM BIOS Int 16H keyboard driver functions used by
<br>
&nbsp;MS-DOS applications and their OS/2 equivalents. This is not a complete
<br>
&nbsp;list of OS/2 keyboard services.
<br>
<br>
&nbsp;Optimization
<br>
<br>
&nbsp;Once your program is running in protected mode, it is time to unravel some
<br>
&nbsp;of the changes made for purposes of conversion and to introduce various
<br>
&nbsp;optimizations. Three obvious categories should be considered:
<br>
<br>
&nbsp;1. &nbsp;Modifying the program's user-interface code for the more powerful OS/2
<br>
&nbsp; &nbsp; &nbsp;keyboard and display API functions.
<br>
<br>
&nbsp;2. &nbsp;Incorporating 80286-specific machine instructions where appropriate.
<br>
<br>
&nbsp;3. &nbsp;Revamping the application to exploit the OS/2 facilities that are
<br>
&nbsp; &nbsp; &nbsp;unique to protected mode. (Of course, the application benefits from
<br>
&nbsp; &nbsp; &nbsp;OS/2's virtual memory capabilities automatically; it can allocate
<br>
&nbsp; &nbsp; &nbsp;memory until physical memory and disk swapping space are exhausted.)
<br>
<br>
&nbsp;Modifying subroutines that encapsulate user input and output to take
<br>
&nbsp;advantage of the additional functionality available under OS/2 is
<br>
&nbsp;straight-forward, and the resulting performance improvements can be quite
<br>
&nbsp;dramatic. For example, the OS/2 video driver offers a variety of services
<br>
&nbsp;that are far superior to the screen support in MS-DOS and the ROM BIOS,
<br>
&nbsp;including high-speed display of strings and attributes at any screen
<br>
&nbsp;position, &quot;reading back&quot; selected areas of the display into a buffer, and
<br>
&nbsp;scrolling in all four directions.
<br>
<br>
&nbsp;The 80286-specific machine instructions can be very helpful in reducing
<br>
&nbsp;code size and increasing execution speed. The most useful instructions are
<br>
&nbsp;the shifts and rotates by an immediate count other than one, the
<br>
&nbsp;three-operand multiply where one of the operands is an immediate (literal)
<br>
&nbsp;value, and the push immediate value instruction (particularly handy for
<br>
&nbsp;setting up OS/2 function calls). For example, in Figure 16-3, the
<br>
&nbsp;sequence
<br>
<br>
&nbsp;mov &nbsp; &nbsp; ax,offset DGROUP:wlen
<br>
&nbsp;push &nbsp; &nbsp;ax
<br>
<br>
&nbsp;could be replaced by the single instruction
<br>
<br>
&nbsp;push &nbsp; &nbsp;offset DGROUP:wlen
<br>
<br>
&nbsp;Restructuring an application to take full advantage of OS/2's
<br>
&nbsp;protected-mode capabilities requires close study of both the application
<br>
&nbsp;and the OS/2 API, but such study can pay off with sizable benefits in
<br>
&nbsp;performance, ease of maintenance, and code sharing. Often, for instance,
<br>
&nbsp;different parts of an application are concerned with I/O devices of vastly
<br>
&nbsp;different speeds, such as the keyboard, disk, and video display. It both
<br>
&nbsp;simplifies and enhances the application to separate these elements into
<br>
&nbsp;subprocesses (called threads in OS/2) that execute asynchronously,
<br>
&nbsp;communicate through shared data structures, and synchronize with each
<br>
&nbsp;other, when necessary, using semaphores.
<br>
<br>
&nbsp;As another example, when several applications are closely related and
<br>
&nbsp;contain many identical or highly similar procedures, OS/2 allows you to
<br>
&nbsp;centralize those procedures in a dynamic link library. Routines in a
<br>
&nbsp;dynamic link library are bound to a program at its load time (rather than
<br>
&nbsp;by LINK, as in the case of traditional runtime libraries) and are shared
<br>
&nbsp;by all the processes that need them. This reduces the size of each
<br>
&nbsp;application .EXE file and allows more efficient use of memory. Best of
<br>
&nbsp;all, dynamic link libraries drastically simplify code maintenance; the
<br>
&nbsp;routines in the libraries can be debugged or improved at any time, and the
<br>
&nbsp;applications that use them will automatically benefit the next time they
<br>
&nbsp;are executed.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
SECTION 2 &nbsp;MS-DOS FUNCTIONS REFERENCE
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
Notes to the Reader
<br>
<br>
&nbsp;This section documents the services that the MS-DOS kernel provides to
<br>
&nbsp;application programs via software interrupts 20H─2FH. Each MS-DOS function
<br>
&nbsp;is described in the same format:
<br>
<br>
&nbsp;■ A heading containing the function's name, software interrupt and
<br>
&nbsp; &nbsp;function number, and an icon indicating the MS-DOS version in which the
<br>
&nbsp; &nbsp;function was first supported. You can assume that the function is
<br>
&nbsp; &nbsp;available in all subsequent MS-DOS versions unless explicitly noted
<br>
&nbsp; &nbsp;otherwise.
<br>
<br>
&nbsp;■ A synopsis of the actions performed by the function and the
<br>
&nbsp; &nbsp;circumstances under which it would be used.
<br>
<br>
&nbsp;■ A summary of the function's arguments.
<br>
<br>
&nbsp;■ The results and/or error indicators returned by the function. A
<br>
&nbsp; &nbsp;comprehensive list of error codes can be found in the entry for Int 21H
<br>
&nbsp; &nbsp;Function 59H.
<br>
<br>
&nbsp;■ Notes describing special uses or dependencies of the function.
<br>
<br>
&nbsp;■ A skeleton example of the function's use, written in assembly language.
<br>
<br>
&nbsp;Version icons used in the synopsis, arguments, results, or Notes sections
<br>
&nbsp;refer to specific minor or major versions, unless they include a + sign to
<br>
&nbsp;indicate a version and all subsequent versions.
<br>
<br>
&nbsp;For purposes of clarity, the examples may include instructions that would
<br>
&nbsp;not be necessary if the code were inserted into a working program. For
<br>
&nbsp;example, most of the examples explicitly set the segment registers when
<br>
&nbsp;passing the address of a filename or buffer to MS-DOS; in real
<br>
&nbsp;applications, the segment registers are usually initialized once at entry
<br>
&nbsp;to the program and left alone thereafter.
<br>
<br>
<br>
Int 21H Function Summary by Number
<br>
<br>
<br>
&nbsp;Hex &nbsp; &nbsp; &nbsp;Dec &nbsp; &nbsp; Function name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vers &nbsp; &nbsp;F/H
<br>
Specifies whether file functions are FCB- or handle-related.
<br>
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp;Terminate Process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp;Character Input with Echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp;Character Output &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp;Auxiliary Input &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp;Auxiliary Output &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp;Printer Output &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp;Direct Console I/O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp;Unfiltered Character Input Without Echo 1.0+
<br>
&nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp;Character Input Without Echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp;9 &nbsp; &nbsp;Display String &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;0AH &nbsp; &nbsp; &nbsp; 10 &nbsp; &nbsp;Buffered Keyboard Input &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;0BH &nbsp; &nbsp; &nbsp; 11 &nbsp; &nbsp;Check Input Status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;0CH &nbsp; &nbsp; &nbsp; 12 &nbsp; &nbsp;Flush Input Buffer and Then Input &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;0DH &nbsp; &nbsp; &nbsp; 13 &nbsp; &nbsp;Disk Reset &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;0EH &nbsp; &nbsp; &nbsp; 14 &nbsp; &nbsp;Select Disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;0FH &nbsp; &nbsp; &nbsp; 15 &nbsp; &nbsp;Open File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;10H &nbsp; &nbsp; &nbsp; 16 &nbsp; &nbsp;Close File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;11H &nbsp; &nbsp; &nbsp; 17 &nbsp; &nbsp;Find First File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;12H &nbsp; &nbsp; &nbsp; 18 &nbsp; &nbsp;Find Next File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;13H &nbsp; &nbsp; &nbsp; 19 &nbsp; &nbsp;Delete File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;14H &nbsp; &nbsp; &nbsp; 20 &nbsp; &nbsp;Sequential Read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;15H &nbsp; &nbsp; &nbsp; 21 &nbsp; &nbsp;Sequential Write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;16H &nbsp; &nbsp; &nbsp; 22 &nbsp; &nbsp;Create File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;17H &nbsp; &nbsp; &nbsp; 23 &nbsp; &nbsp;Rename File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;18H &nbsp; &nbsp; &nbsp; &nbsp;24 &nbsp; &nbsp;Reserved
<br>
&nbsp;19H &nbsp; &nbsp; &nbsp; 25 &nbsp; &nbsp;Get Current Disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;1AH &nbsp; &nbsp; &nbsp; 26 &nbsp; &nbsp;Set DTA Address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;1BH &nbsp; &nbsp; &nbsp; 27 &nbsp; &nbsp;Get Default Drive Data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;1CH &nbsp; &nbsp; &nbsp; 28 &nbsp; &nbsp;Get Drive Data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;1DH &nbsp; &nbsp; &nbsp; &nbsp;29 &nbsp; &nbsp;Reserved
<br>
&nbsp;1EH &nbsp; &nbsp; &nbsp; &nbsp;30 &nbsp; &nbsp;Reserved
<br>
&nbsp;1FH &nbsp; &nbsp; &nbsp; &nbsp;31 &nbsp; &nbsp;Reserved
<br>
&nbsp;20H &nbsp; &nbsp; &nbsp; &nbsp;32 &nbsp; &nbsp;Reserved
<br>
&nbsp;21H &nbsp; &nbsp; &nbsp; 33 &nbsp; &nbsp;Random Read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;22H &nbsp; &nbsp; &nbsp; 34 &nbsp; &nbsp;Random Write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;23H &nbsp; &nbsp; &nbsp; 35 &nbsp; &nbsp;Get File Size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;24H &nbsp; &nbsp; &nbsp; 36 &nbsp; &nbsp;Set Relative Record Number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;25H &nbsp; &nbsp; &nbsp; 37 &nbsp; &nbsp;Set Interrupt Vector &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;26H &nbsp; &nbsp; &nbsp; 38 &nbsp; &nbsp;Create New PSP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;27H &nbsp; &nbsp; &nbsp; 39 &nbsp; &nbsp;Random Block Read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;28H &nbsp; &nbsp; &nbsp; 40 &nbsp; &nbsp;Random Block Write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;29H &nbsp; &nbsp; &nbsp; 41 &nbsp; &nbsp;Parse Filename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;2AH &nbsp; &nbsp; &nbsp; 42 &nbsp; &nbsp;Get Date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;2BH &nbsp; &nbsp; &nbsp; 43 &nbsp; &nbsp;Set Date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;2CH &nbsp; &nbsp; &nbsp; 44 &nbsp; &nbsp;Get Time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;2DH &nbsp; &nbsp; &nbsp; 45 &nbsp; &nbsp;Set Time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;2EH &nbsp; &nbsp; &nbsp; 46 &nbsp; &nbsp;Set Verify Flag &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;2FH &nbsp; &nbsp; &nbsp; 47 &nbsp; &nbsp;Get DTA Address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;30H &nbsp; &nbsp; &nbsp; 48 &nbsp; &nbsp;Get MS-DOS Version Number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;31H &nbsp; &nbsp; &nbsp; 49 &nbsp; &nbsp;Terminate and Stay Resident &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;32H &nbsp; &nbsp; &nbsp; &nbsp;50 &nbsp; &nbsp;Reserved
<br>
&nbsp;33H &nbsp; &nbsp; &nbsp; 51 &nbsp; &nbsp;Get or Set Break Flag, Get Boot Drive &nbsp; 2.0+
<br>
&nbsp;34H &nbsp; &nbsp; &nbsp; &nbsp;52 &nbsp; &nbsp;Reserved
<br>
&nbsp;35H &nbsp; &nbsp; &nbsp; 53 &nbsp; &nbsp;Get Interrupt Vector &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;36H &nbsp; &nbsp; &nbsp; 54 &nbsp; &nbsp;Get Drive Allocation Information &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;37H &nbsp; &nbsp; &nbsp; &nbsp;55 &nbsp; &nbsp;Reserved
<br>
&nbsp;38H &nbsp; &nbsp; &nbsp; 56 &nbsp; &nbsp;Get or Set Country Information &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;39H &nbsp; &nbsp; &nbsp; 57 &nbsp; &nbsp;Create Directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;3AH &nbsp; &nbsp; &nbsp; 58 &nbsp; &nbsp;Delete Directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;3BH &nbsp; &nbsp; &nbsp; 59 &nbsp; &nbsp;Set Current Directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;3CH &nbsp; &nbsp; &nbsp; 60 &nbsp; &nbsp;Create File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;3DH &nbsp; &nbsp; &nbsp; 61 &nbsp; &nbsp;Open File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;3EH &nbsp; &nbsp; &nbsp; 62 &nbsp; &nbsp;Close File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+ &nbsp; &nbsp;H
<br>
&nbsp;3FH &nbsp; &nbsp; &nbsp; 63 &nbsp; &nbsp;Read File or Device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;40H &nbsp; &nbsp; &nbsp; 64 &nbsp; &nbsp;Write File or Device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+ &nbsp; &nbsp;H
<br>
&nbsp;41H &nbsp; &nbsp; &nbsp; 65 &nbsp; &nbsp;Delete File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;42H &nbsp; &nbsp; &nbsp; 66 &nbsp; &nbsp;Set File Pointer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+ &nbsp; &nbsp;H
<br>
&nbsp;43H &nbsp; &nbsp; &nbsp; 67 &nbsp; &nbsp;Get or Set File Attributes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;44H &nbsp; &nbsp; &nbsp; 68 &nbsp; &nbsp;IOCTL (I/O Control) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;45H &nbsp; &nbsp; &nbsp; 69 &nbsp; &nbsp;Duplicate Handle &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;46H &nbsp; &nbsp; &nbsp; 70 &nbsp; &nbsp;Redirect Handle &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;47H &nbsp; &nbsp; &nbsp; 71 &nbsp; &nbsp;Get Current Directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;48H &nbsp; &nbsp; &nbsp; 72 &nbsp; &nbsp;Allocate Memory Block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;49H &nbsp; &nbsp; &nbsp; 73 &nbsp; &nbsp;Release Memory Block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;4AH &nbsp; &nbsp; &nbsp; 74 &nbsp; &nbsp;Resize Memory Block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;4BH &nbsp; &nbsp; &nbsp; 75 &nbsp; &nbsp;Execute Program (EXEC) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;4CH &nbsp; &nbsp; &nbsp; 76 &nbsp; &nbsp;Terminate Process with Return Code &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;4DH &nbsp; &nbsp; &nbsp; 77 &nbsp; &nbsp;Get Return Code &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;4EH &nbsp; &nbsp; &nbsp; 78 &nbsp; &nbsp;Find First File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;4FH &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp;Find Next File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+ &nbsp; &nbsp;H
<br>
&nbsp;50H &nbsp; &nbsp; &nbsp; &nbsp;80 &nbsp; &nbsp;Reserved
<br>
&nbsp;51H &nbsp; &nbsp; &nbsp; &nbsp;81 &nbsp; &nbsp;Reserved
<br>
&nbsp;52H &nbsp; &nbsp; &nbsp; &nbsp;82 &nbsp; &nbsp;Reserved
<br>
&nbsp;53H &nbsp; &nbsp; &nbsp; &nbsp;83 &nbsp; &nbsp;Reserved
<br>
&nbsp;54H &nbsp; &nbsp; &nbsp; 84 &nbsp; &nbsp;Get Verify Flag &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;55H &nbsp; &nbsp; &nbsp; &nbsp;85 &nbsp; &nbsp;Reserved
<br>
&nbsp;56H &nbsp; &nbsp; &nbsp; 86 &nbsp; &nbsp;Rename File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;57H &nbsp; &nbsp; &nbsp; 87 &nbsp; &nbsp;Get or Set File Date and Time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;58H &nbsp; &nbsp; &nbsp; 88 &nbsp; &nbsp;Get or Set Allocation Strategy &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0+
<br>
&nbsp;59H &nbsp; &nbsp; &nbsp; 89 &nbsp; &nbsp;Get Extended Error Information &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0+
<br>
&nbsp;5AH &nbsp; &nbsp; &nbsp; 90 &nbsp; &nbsp;Create Temporary File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.0+ &nbsp; &nbsp;H
<br>
&nbsp;5BH &nbsp; &nbsp; &nbsp; 91 &nbsp; &nbsp;Create New File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.0+ &nbsp; &nbsp;H
<br>
&nbsp;5CH &nbsp; &nbsp; &nbsp; 92 &nbsp; &nbsp;Lock or Unlock File Region &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0+ &nbsp; &nbsp;H
<br>
&nbsp;5DH &nbsp; &nbsp; &nbsp; &nbsp;93 &nbsp; &nbsp;Reserved
<br>
&nbsp;5EH &nbsp; &nbsp; &nbsp; 94 &nbsp; &nbsp;Get Machine Name, Get or Set Printer &nbsp; &nbsp;3.1+
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Setup
<br>
&nbsp;5FH &nbsp; &nbsp; &nbsp; 95 &nbsp; &nbsp;Device Redirection &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.1+
<br>
&nbsp;60H &nbsp; &nbsp; &nbsp; &nbsp;96 &nbsp; &nbsp;Reserved
<br>
&nbsp;61H &nbsp; &nbsp; &nbsp; &nbsp;97 &nbsp; &nbsp;Reserved
<br>
&nbsp;62H &nbsp; &nbsp; &nbsp; 98 &nbsp; &nbsp;Get PSP Address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.0+
<br>
&nbsp;63H &nbsp; &nbsp; &nbsp; 99 &nbsp; &nbsp;Get DBCS Lead Byte Table &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.25
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; only
<br>
&nbsp;64H &nbsp; &nbsp; &nbsp; 100 &nbsp; &nbsp;Reserved
<br>
&nbsp;65H &nbsp; &nbsp; &nbsp;101 &nbsp; &nbsp;Get Extended Country Information &nbsp; &nbsp; &nbsp; &nbsp;3.3+
<br>
&nbsp;66H &nbsp; &nbsp; &nbsp;102 &nbsp; &nbsp;Get or Set Code Page &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.3+
<br>
&nbsp;67H &nbsp; &nbsp; &nbsp;103 &nbsp; &nbsp;Set Handle Count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.3+
<br>
&nbsp;68H &nbsp; &nbsp; &nbsp;104 &nbsp; &nbsp;Commit File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.3+ &nbsp; &nbsp;H
<br>
&nbsp;69H &nbsp; &nbsp; &nbsp; 105 &nbsp; &nbsp;Reserved
<br>
&nbsp;6AH &nbsp; &nbsp; &nbsp; 106 &nbsp; &nbsp;Reserved
<br>
&nbsp;6BH &nbsp; &nbsp; &nbsp; 107 &nbsp; &nbsp;Reserved
<br>
&nbsp;6CH &nbsp; &nbsp; &nbsp;108 &nbsp; &nbsp;Extended Open File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.0+ &nbsp; &nbsp;H
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
<br>
Int 21H Function Summary by Category
<br>
<br>
<br>
&nbsp;Hex &nbsp; &nbsp; &nbsp;Dec &nbsp; &nbsp; Function name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vers &nbsp; &nbsp;F/H
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;Character I/O
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp;Character Input with Echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp;Character Output &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp;Auxiliary Input &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp;Auxiliary Output &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp;Printer Output &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp;Direct Console I/O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp;Unfiltered Character Input Without Echo 1.0+
<br>
&nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp;Character Input Without Echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp;9 &nbsp; &nbsp;Display String &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;0AH &nbsp; &nbsp; &nbsp; 10 &nbsp; &nbsp;Buffered Keyboard Input &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;0BH &nbsp; &nbsp; &nbsp; 11 &nbsp; &nbsp;Check Input Status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;0CH &nbsp; &nbsp; &nbsp; 12 &nbsp; &nbsp;Flush Input Buffer and Then Input &nbsp; &nbsp; &nbsp; 1.0+
<br>
<br>
&nbsp;File Operations
<br>
&nbsp;0FH &nbsp; &nbsp; &nbsp; 15 &nbsp; &nbsp;Open File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;10H &nbsp; &nbsp; &nbsp; 16 &nbsp; &nbsp;Close File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;11H &nbsp; &nbsp; &nbsp; 17 &nbsp; &nbsp;Find First File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;12H &nbsp; &nbsp; &nbsp; 18 &nbsp; &nbsp;Find Next File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;13H &nbsp; &nbsp; &nbsp; 19 &nbsp; &nbsp;Delete File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;16H &nbsp; &nbsp; &nbsp; 22 &nbsp; &nbsp;Create File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;17H &nbsp; &nbsp; &nbsp; 23 &nbsp; &nbsp;Rename File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;23H &nbsp; &nbsp; &nbsp; 35 &nbsp; &nbsp;Get File Size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;29H &nbsp; &nbsp; &nbsp; 41 &nbsp; &nbsp;Parse Filename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;3CH &nbsp; &nbsp; &nbsp; 60 &nbsp; &nbsp;Create File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;3DH &nbsp; &nbsp; &nbsp; 61 &nbsp; &nbsp;Open File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;3EH &nbsp; &nbsp; &nbsp; 62 &nbsp; &nbsp;Close File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+ &nbsp; &nbsp;H
<br>
&nbsp;41H &nbsp; &nbsp; &nbsp; 65 &nbsp; &nbsp;Delete File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;43H &nbsp; &nbsp; &nbsp; 67 &nbsp; &nbsp;Get or Set File Attributes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;45H &nbsp; &nbsp; &nbsp; 69 &nbsp; &nbsp;Duplicate Handle &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;46H &nbsp; &nbsp; &nbsp; 70 &nbsp; &nbsp;Redirect Handle &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;4EH &nbsp; &nbsp; &nbsp; 78 &nbsp; &nbsp;Find First File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;4FH &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp;Find Next File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+ &nbsp; &nbsp;H
<br>
&nbsp;56H &nbsp; &nbsp; &nbsp; 86 &nbsp; &nbsp;Rename File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;57H &nbsp; &nbsp; &nbsp; 87 &nbsp; &nbsp;Get or Set File Date and Time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;5AH &nbsp; &nbsp; &nbsp; 90 &nbsp; &nbsp;Create Temporary File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.0+ &nbsp; &nbsp;H
<br>
&nbsp;5BH &nbsp; &nbsp; &nbsp; 91 &nbsp; &nbsp;Create New File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.0+ &nbsp; &nbsp;H
<br>
&nbsp;67H &nbsp; &nbsp; &nbsp;103 &nbsp; &nbsp;Set Handle Count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.3+
<br>
&nbsp;68H &nbsp; &nbsp; &nbsp;104 &nbsp; &nbsp;Commit File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.3+ &nbsp; &nbsp;H
<br>
&nbsp;6CH &nbsp; &nbsp; &nbsp;108 &nbsp; &nbsp;Extended Open File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.0+ &nbsp; &nbsp;H
<br>
<br>
&nbsp;Record Operations
<br>
&nbsp;14H &nbsp; &nbsp; &nbsp; 20 &nbsp; &nbsp;Sequential Read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;15H &nbsp; &nbsp; &nbsp; 21 &nbsp; &nbsp;Sequential Write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;1AH &nbsp; &nbsp; &nbsp; 26 &nbsp; &nbsp;Set DTA Address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;21H &nbsp; &nbsp; &nbsp; 33 &nbsp; &nbsp;Random Read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;22H &nbsp; &nbsp; &nbsp; 34 &nbsp; &nbsp;Random Write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;24H &nbsp; &nbsp; &nbsp; 36 &nbsp; &nbsp;Set Relative Record Number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;27H &nbsp; &nbsp; &nbsp; 39 &nbsp; &nbsp;Random Block Read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+ &nbsp; &nbsp;F
<br>
&nbsp;28H &nbsp; &nbsp; &nbsp; 40 &nbsp; &nbsp;Random Block Write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+ &nbsp; &nbsp;F
<br>
&nbsp;2FH &nbsp; &nbsp; &nbsp; 47 &nbsp; &nbsp;Get DTA Address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;3FH &nbsp; &nbsp; &nbsp; 63 &nbsp; &nbsp;Read File or Device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+ &nbsp; &nbsp;H
<br>
&nbsp;40H &nbsp; &nbsp; &nbsp; 64 &nbsp; &nbsp;Write File or Device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+ &nbsp; &nbsp;H
<br>
&nbsp;42H &nbsp; &nbsp; &nbsp; 66 &nbsp; &nbsp;Set File Pointer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+ &nbsp; &nbsp;H
<br>
&nbsp;5CH &nbsp; &nbsp; &nbsp; 92 &nbsp; &nbsp;Lock or Unlock File Region &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0+ &nbsp; &nbsp;H
<br>
<br>
&nbsp;Directory Operations
<br>
&nbsp;39H &nbsp; &nbsp; &nbsp; 57 &nbsp; &nbsp;Create Directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;3AH &nbsp; &nbsp; &nbsp; 58 &nbsp; &nbsp;Delete Directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;3BH &nbsp; &nbsp; &nbsp; 59 &nbsp; &nbsp;Set Current Directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;47H &nbsp; &nbsp; &nbsp; 71 &nbsp; &nbsp;Get Current Directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
<br>
&nbsp;Disk Management
<br>
&nbsp;0DH &nbsp; &nbsp; &nbsp; 13 &nbsp; &nbsp;Disk Reset &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;0EH &nbsp; &nbsp; &nbsp; 14 &nbsp; &nbsp;Select Disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;19H &nbsp; &nbsp; &nbsp; 25 &nbsp; &nbsp;Get Current Disk &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;1BH &nbsp; &nbsp; &nbsp; 27 &nbsp; &nbsp;Get Default Drive Data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;1CH &nbsp; &nbsp; &nbsp; 28 &nbsp; &nbsp;Get Drive Data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;2EH &nbsp; &nbsp; &nbsp; 46 &nbsp; &nbsp;Set Verify Flag &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;36H &nbsp; &nbsp; &nbsp; 54 &nbsp; &nbsp;Get Drive Allocation Information &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;54H &nbsp; &nbsp; &nbsp; 84 &nbsp; &nbsp;Get Verify Flag &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
<br>
&nbsp;Process Management
<br>
&nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp;Terminate Process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.0+
<br>
&nbsp;26H &nbsp; &nbsp; &nbsp; 38 &nbsp; &nbsp;Create New PSP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;31H &nbsp; &nbsp; &nbsp; 49 &nbsp; &nbsp;Terminate and Stay Resident &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;4BH &nbsp; &nbsp; &nbsp; 75 &nbsp; &nbsp;Execute Program (EXEC) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;4CH &nbsp; &nbsp; &nbsp; 76 &nbsp; &nbsp;Terminate Process with Return Code &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;4DH &nbsp; &nbsp; &nbsp; 77 &nbsp; &nbsp;Get Return Code &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;62H &nbsp; &nbsp; &nbsp; 98 &nbsp; &nbsp;Get PSP Address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.0+
<br>
<br>
&nbsp;Memory Management
<br>
&nbsp;48H &nbsp; &nbsp; &nbsp; 72 &nbsp; &nbsp;Allocate Memory Block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;49H &nbsp; &nbsp; &nbsp; 73 &nbsp; &nbsp;Release Memory Block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;4AH &nbsp; &nbsp; &nbsp; 74 &nbsp; &nbsp;Resize Memory Block &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;58H &nbsp; &nbsp; &nbsp; 88 &nbsp; &nbsp;Get or Set Allocation Strategy &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0+
<br>
<br>
&nbsp;Network Functions
<br>
&nbsp;5EH &nbsp; &nbsp; &nbsp; 94 &nbsp; &nbsp;Get Machine Name, Get or Set Printer &nbsp; &nbsp;3.1+
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Setup
<br>
&nbsp;5FH &nbsp; &nbsp; &nbsp; 95 &nbsp; &nbsp;Device Redirection &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.1+
<br>
<br>
&nbsp;Time and Date
<br>
&nbsp;2AH &nbsp; &nbsp; &nbsp; 42 &nbsp; &nbsp;Get Date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;2BH &nbsp; &nbsp; &nbsp; 43 &nbsp; &nbsp;Set Date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;2CH &nbsp; &nbsp; &nbsp; 44 &nbsp; &nbsp;Get Time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;2DH &nbsp; &nbsp; &nbsp; 45 &nbsp; &nbsp;Set Time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
<br>
&nbsp;Miscellaneous System Functions
<br>
&nbsp;25H &nbsp; &nbsp; &nbsp; 37 &nbsp; &nbsp;Set Interrupt Vector &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.0+
<br>
&nbsp;30H &nbsp; &nbsp; &nbsp; 48 &nbsp; &nbsp;Get MS-DOS Version Number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;33H &nbsp; &nbsp; &nbsp; 51 &nbsp; &nbsp;Get or Set Break Flag, Get Boot Drive &nbsp; 2.0+
<br>
&nbsp;35H &nbsp; &nbsp; &nbsp; 53 &nbsp; &nbsp;Get Interrupt Vector &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;38H &nbsp; &nbsp; &nbsp; 56 &nbsp; &nbsp;Get or Set Country Information &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0+
<br>
&nbsp;44H &nbsp; &nbsp; &nbsp; 68 &nbsp; &nbsp;IOCTL (I/O Control) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0+
<br>
&nbsp;59H &nbsp; &nbsp; &nbsp; 89 &nbsp; &nbsp;Get Extended Error Information &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0+
<br>
&nbsp;63H &nbsp; &nbsp; &nbsp; 99 &nbsp; &nbsp;Get Lead Byte Table &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.25
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; only
<br>
&nbsp;65H &nbsp; &nbsp; &nbsp;101 &nbsp; &nbsp;Get Extended Country Information &nbsp; &nbsp; &nbsp; &nbsp;3.3+
<br>
&nbsp;66H &nbsp; &nbsp; &nbsp;102 &nbsp; &nbsp;Get or Set Code Page &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.3+
<br>
<br>
&nbsp;Reserved Functions
<br>
&nbsp;18H &nbsp; &nbsp; &nbsp; &nbsp;24 &nbsp; &nbsp;Reserved
<br>
&nbsp;1DH &nbsp; &nbsp; &nbsp; &nbsp;29 &nbsp; &nbsp;Reserved
<br>
&nbsp;1EH &nbsp; &nbsp; &nbsp; &nbsp;30 &nbsp; &nbsp;Reserved
<br>
&nbsp;1FH &nbsp; &nbsp; &nbsp; &nbsp;31 &nbsp; &nbsp;Reserved
<br>
&nbsp;20H &nbsp; &nbsp; &nbsp; &nbsp;32 &nbsp; &nbsp;Reserved
<br>
&nbsp;32H &nbsp; &nbsp; &nbsp; &nbsp;50 &nbsp; &nbsp;Reserved
<br>
&nbsp;34H &nbsp; &nbsp; &nbsp; &nbsp;52 &nbsp; &nbsp;Reserved
<br>
&nbsp;37H &nbsp; &nbsp; &nbsp; &nbsp;55 &nbsp; &nbsp;Reserved
<br>
&nbsp;50H &nbsp; &nbsp; &nbsp; &nbsp;80 &nbsp; &nbsp;Reserved
<br>
&nbsp;51H &nbsp; &nbsp; &nbsp; &nbsp;81 &nbsp; &nbsp;Reserved
<br>
&nbsp;52H &nbsp; &nbsp; &nbsp; &nbsp;82 &nbsp; &nbsp;Reserved
<br>
&nbsp;53H &nbsp; &nbsp; &nbsp; &nbsp;83 &nbsp; &nbsp;Reserved
<br>
&nbsp;55H &nbsp; &nbsp; &nbsp; &nbsp;85 &nbsp; &nbsp;Reserved
<br>
&nbsp;5DH &nbsp; &nbsp; &nbsp; &nbsp;93 &nbsp; &nbsp;Reserved
<br>
&nbsp;60H &nbsp; &nbsp; &nbsp; &nbsp;96 &nbsp; &nbsp;Reserved
<br>
&nbsp;61H &nbsp; &nbsp; &nbsp; &nbsp;97 &nbsp; &nbsp;Reserved
<br>
&nbsp;64H &nbsp; &nbsp; &nbsp; 100 &nbsp; &nbsp;Reserved
<br>
&nbsp;69H &nbsp; &nbsp; &nbsp; 105 &nbsp; &nbsp;Reserved
<br>
&nbsp;6AH &nbsp; &nbsp; &nbsp; 106 &nbsp; &nbsp;Reserved
<br>
&nbsp;6BH &nbsp; &nbsp; &nbsp; 107 &nbsp; &nbsp;Reserved
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 20H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Terminate process
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Terminates the current process. This is one of several methods that a
<br>
&nbsp;program can use to perform a final exit. MS-DOS then takes the following
<br>
&nbsp;actions:
<br>
<br>
&nbsp;■ All memory belonging to the process is released.
<br>
<br>
&nbsp;■ File buffers are flushed and any open handles for files or devices owned
<br>
&nbsp; &nbsp;by the process are closed.
<br>
<br>
&nbsp;■ The termination handler vector (Int 22H) is restored from PSP:000AH.
<br>
<br>
&nbsp;■ The Ctrl-C handler vector (Int 23H) is restored from PSP:000EH.
<br>
<br>
&nbsp;■ [2.0+] The critical-error handler vector (Int 24H) is restored from
<br>
&nbsp; &nbsp;PSP:0012H.
<br>
<br>
&nbsp;■ Control is transferred to the termination handler.
<br>
<br>
&nbsp;If the program is returning to COMMAND.COM, control transfers to the
<br>
&nbsp;resident portion, and the transient portion is reloaded if necessary. If a
<br>
&nbsp;batch file is in progress, the next line of the file is fetched and
<br>
&nbsp;interpreted; otherwise, a prompt is issued for the next user command.
<br>
<br>
Call with:
<br>
<br>
&nbsp;CS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment address of program segment prefix
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Any files that have been written to using FCBs should be closed before
<br>
&nbsp; &nbsp;performing this exit call; otherwise, data may be lost.
<br>
<br>
&nbsp;■ Other methods of performing a final exit are:
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 00H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 31H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 4CH
<br>
<br>
&nbsp; &nbsp;∙ Int 27H
<br>
<br>
&nbsp;■ [2.0+] Int 21H Functions 31H and 4CH are the preferred methods for
<br>
&nbsp; &nbsp;termination, since they allow a return code to be passed to the parent
<br>
&nbsp; &nbsp;process.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, it should remove all
<br>
&nbsp; &nbsp;locks it has placed on file regions before terminating.
<br>
<br>
Example:
<br>
<br>
&nbsp;Terminate the current program, returning control to the program's parent.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 20h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 00H
<br>
Terminate process
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Terminates the current process. This is one of several methods that a
<br>
&nbsp;program can use to perform a final exit. MS-DOS then takes the following
<br>
&nbsp;actions:
<br>
<br>
&nbsp;■ All memory belonging to the process is released.
<br>
<br>
&nbsp;■ File buffers are flushed and any open handles for files or devices owned
<br>
&nbsp; &nbsp;by the process are closed.
<br>
<br>
&nbsp;■ The termination handler vector (Int 22H) is restored from PSP:000AH.
<br>
<br>
&nbsp;■ The Ctrl-C handler vector (Int 23H) is restored from PSP:000EH.
<br>
<br>
&nbsp;■ [2.0+] The critical-error handler vector (Int 24H) is restored from
<br>
&nbsp; &nbsp;PSP:0012H.
<br>
<br>
&nbsp;■ Control is transferred to the termination handler.
<br>
<br>
&nbsp;If the program is returning to COMMAND.COM, control transfers to the
<br>
&nbsp;resident portion, and the transient portion is reloaded if necessary. If a
<br>
&nbsp;batch file is in progress, the next line of the file is fetched and
<br>
&nbsp;interpreted; otherwise, a prompt is issued for the next user command.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;CS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment address of program segment prefix
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Any files that have been written to using FCBs should be closed before
<br>
&nbsp; &nbsp;performing this exit call; otherwise, data may be lost.
<br>
<br>
&nbsp;■ Other methods of performing a final exit are:
<br>
<br>
&nbsp; &nbsp;∙ Int 20H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 31H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 4CH&lt;21H4CH&gt;
<br>
<br>
&nbsp; &nbsp;∙ Int 27H
<br>
<br>
&nbsp;■ [2.0+] Int 21H Functions 31H and 4CH are the preferred methods for
<br>
&nbsp; &nbsp;termination, since they allow a return code to be passed to the parent
<br>
&nbsp; &nbsp;process.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, it should remove all
<br>
&nbsp; &nbsp;locks it has placed on file regions before terminating.
<br>
<br>
Example:
<br>
<br>
&nbsp;Terminate the current program, returning control to the program's parent.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 01H
<br>
Character input with echo
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Inputs a character from the keyboard, then echoes it to the display.
<br>
&nbsp;If no character is ready, waits until one is available.
<br>
<br>
&nbsp;[2.0+] Reads a character from the standard input device and echoes it to
<br>
&nbsp;the standard output device. If no character is ready, waits until one is
<br>
&nbsp;available. Input can be redirected. (If input has been redirected, there
<br>
&nbsp;is no way to detect EOF.)
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 8-bit input data
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the standard input is not redirected, and the character read is a
<br>
&nbsp; &nbsp;Ctrl-C, an Int 23H is executed. If the standard input is redirected, a
<br>
&nbsp; &nbsp;Ctrl-C is detected at the console, and BREAK is ON, an Int 23H is
<br>
&nbsp; &nbsp;executed.
<br>
<br>
&nbsp;■ To read extended ASCII codes (such as the special function keys F1 to
<br>
&nbsp; &nbsp;F10) on the IBM PC and compatibles, you must call this function twice.
<br>
&nbsp; &nbsp;The first call returns the value 00H to signal the presence of an
<br>
&nbsp; &nbsp;extended code.
<br>
<br>
&nbsp;■ See also Int 21H Functions 06H, 07H, and 08H, which provide character
<br>
&nbsp; &nbsp;input with various combinations of echo and/or Ctrl-C sensing.
<br>
<br>
&nbsp;■ [2.0+] You can also read the keyboard by issuing a read (Int 21H
<br>
&nbsp; &nbsp;Function 3FH) using the predefined handle for the standard input
<br>
&nbsp; &nbsp;(0000H), if input has not been redirected, or a handle obtained by
<br>
&nbsp; &nbsp;opening the logical device CON.
<br>
<br>
Example:
<br>
<br>
&nbsp;Read one character from the keyboard into register AL, echo it to the
<br>
&nbsp;display, and store it in the variable char.
<br>
<br>
&nbsp;char &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; input character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; char,al &nbsp; &nbsp; &nbsp; &nbsp; ; save character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 02H
<br>
Character output
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Outputs a character to the currently active video display.
<br>
<br>
&nbsp;[2.0+] Outputs a character to the standard output device. Output can be
<br>
&nbsp;redirected. (If output is redirected, there is no way to detect disk
<br>
&nbsp;full.)
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 8-bit data for output
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If a Ctrl-C is detected at the keyboard after the requested character is
<br>
&nbsp; &nbsp;output, an Int 23H is executed.
<br>
<br>
&nbsp;■ If the standard output has not been redirected, a backspace code (08H)
<br>
&nbsp; &nbsp;causes the cursor to move left one position. If output has been
<br>
&nbsp; &nbsp;redirected, the backspace code does not receive any special treatment.
<br>
<br>
&nbsp;■ [2.0+] You can also send strings to the display by performing a write
<br>
&nbsp; &nbsp;(Int 21H Function 40H) using the predefined handle for the standard
<br>
&nbsp; &nbsp;output (0001H), if output has not been redirected, or a handle obtained
<br>
&nbsp; &nbsp;by opening the logical device CON.
<br>
<br>
Example:
<br>
<br>
&nbsp;Send the character &quot;*&quot; to the standard output device.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,'*' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; character to output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 03H
<br>
Auxiliary input
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Reads a character from the first serial port.
<br>
<br>
&nbsp;[2.0+] Reads a character from the standard auxiliary device. The default
<br>
&nbsp;is the first serial port (COM1).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 8-bit input data
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ In most MS-DOS systems, the serial device is unbuffered and is not
<br>
&nbsp; &nbsp;interrupt-driven. If the auxiliary device sends data faster than your
<br>
&nbsp; &nbsp;program can process it, characters may be lost.
<br>
<br>
&nbsp;■ At startup on the IBM PC, PC-DOS initializes the first serial port to
<br>
&nbsp; &nbsp;2400 baud, no parity, 1 stop bit, and 8 data bits. Other implementations
<br>
&nbsp; &nbsp;of MS-DOS may initialize the serial device differently.
<br>
<br>
&nbsp;■ There is no way for a user program to read the status of the auxiliary
<br>
&nbsp; &nbsp;device or to detect I/O errors (such as lost characters) through this
<br>
&nbsp; &nbsp;function call. On the IBM PC, more precise control can be obtained by
<br>
&nbsp; &nbsp;calling ROM BIOS Int 14H or by driving the communications controller
<br>
&nbsp; &nbsp;directly.
<br>
<br>
&nbsp;■ If a Ctrl-C is detected at the keyboard, an Int 23H is executed.
<br>
<br>
&nbsp;■ [2.0+] You can also input from the auxiliary device by requesting a read
<br>
&nbsp; &nbsp;(Int 21H Function 3FH) using the predefined handle for the standard
<br>
&nbsp; &nbsp;auxiliary device (0003H) or using a handle obtained by opening the
<br>
&nbsp; &nbsp;logical device AUX.
<br>
<br>
Example:
<br>
<br>
&nbsp;Read a character from the standard auxiliary input and store it in the
<br>
&nbsp;variable char.
<br>
<br>
&nbsp;char &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; input character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; char,al &nbsp; &nbsp; &nbsp; &nbsp; ; save character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 04H
<br>
Auxiliary output
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Outputs a character to the first serial port.
<br>
<br>
&nbsp;[2.0+] Outputs a character to the standard auxiliary device. The default
<br>
&nbsp;is the first serial port (COM1).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 8-bit data for output
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the output device is busy, this function waits until the device is
<br>
&nbsp; &nbsp;ready to accept a character.
<br>
<br>
&nbsp;■ There is no way to poll the status of the auxiliary device using this
<br>
&nbsp; &nbsp;function. On the IBM PC, more precise control can be obtained by calling
<br>
&nbsp; &nbsp;ROM BIOS Int 14H or by driving the communications controller directly.
<br>
<br>
&nbsp;■ If a Ctrl-C is detected at the keyboard, an Int 23H is executed.
<br>
<br>
&nbsp;■ [2.0+] You can also send strings to the auxiliary device by performing a
<br>
&nbsp; &nbsp;write (Int 21H Function 40H) using the predefined handle for the
<br>
&nbsp; &nbsp;standard auxiliary device (0003H) or using a handle obtained by opening
<br>
&nbsp; &nbsp;the logical device AUX.
<br>
<br>
Example:
<br>
<br>
&nbsp;Output a &quot;*'' character to the auxiliary device.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,'*' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; character to output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 05H
<br>
Printer output
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Sends a character to the first list device (PRN or LPT1).
<br>
<br>
&nbsp;[2.0+] Sends a character to the standard list device. The default device
<br>
&nbsp;is the printer on the first parallel port (LPT1), unless explicitly
<br>
&nbsp;redirected by the user with the MODE command.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 8-bit data for output
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the printer is busy, this function waits until the printer is ready
<br>
&nbsp; &nbsp;to accept the character.
<br>
<br>
&nbsp;■ There is no standardized way to poll the status of the printer under
<br>
&nbsp; &nbsp;MS-DOS.
<br>
<br>
&nbsp;■ If a Ctrl-C is detected at the keyboard, an Int 23H is executed.
<br>
<br>
&nbsp;■ [2.0+] You can also send strings to the printer by performing a write
<br>
&nbsp; &nbsp;(Int 21H Function 40H) using the predefined handle for the standard
<br>
&nbsp; &nbsp;printer device (0004H) or using a handle obtained by opening the logical
<br>
&nbsp; &nbsp;device PRN or LPT1.
<br>
<br>
Example:
<br>
<br>
&nbsp;Output the character &quot;*'' to the list device.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,'*' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; character to output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 06H
<br>
Direct console I/O
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Used by programs that need to read and write all possible characters and
<br>
&nbsp;control codes without any interference from the operating system.
<br>
<br>
&nbsp;[1] Reads a character from the keyboard or writes a character to the
<br>
&nbsp;display.
<br>
<br>
&nbsp;[2.0+] Reads a character from the standard input device or writes a
<br>
&nbsp;character to the standard output device. I/O may be redirected. (If I/O
<br>
&nbsp;has been redirected, there is no way to detect EOF or disk full.)
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 06H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= function requested
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─FEH &nbsp; if output request
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0FFH &nbsp; &nbsp; &nbsp;if input request
<br>
<br>
Returns:
<br>
<br>
&nbsp;If called with DL = 00H─0FEH
<br>
<br>
&nbsp;Nothing
<br>
<br>
&nbsp;If called with DL = FFH and a character is ready
<br>
<br>
&nbsp;Zero flag &nbsp; &nbsp; = clear
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 8-bit input data
<br>
<br>
&nbsp;If called with DL = FFH and no character is ready
<br>
<br>
&nbsp;Zero flag &nbsp; &nbsp; = set
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ No special action is taken upon entry of a Ctrl-C when this service is
<br>
&nbsp; &nbsp;used.
<br>
<br>
&nbsp;■ To read extended ASCII codes (such as the special function keys F1 to
<br>
&nbsp; &nbsp;F10) on the IBM PC and compatibles, you must call this function twice.
<br>
&nbsp; &nbsp;The first call returns the value 00H to signal the presence of an
<br>
&nbsp; &nbsp;extended code.
<br>
<br>
&nbsp;■ See also Int 21H Functions 01H, 07H, and 08H, which provide character
<br>
&nbsp; &nbsp;input with various combinations of echo and/or Ctrl-C sensing, and
<br>
&nbsp; &nbsp;Functions 02H and 09H, which may be used to write characters to the
<br>
&nbsp; &nbsp;standard output.
<br>
<br>
&nbsp;■ [2.0+] You can also read the keyboard by issuing a read (Int 21H
<br>
&nbsp; &nbsp;Function 3FH) using the predefined handle for the standard input
<br>
&nbsp; &nbsp;(0000H), if input has not been redirected, or a handle obtained by
<br>
&nbsp; &nbsp;opening the logical device CON.
<br>
<br>
&nbsp;■ [2.0+] You can also send characters to the display by issuing a write
<br>
&nbsp; &nbsp;(Int 21H Function 40H) using the predefined handle for the standard
<br>
&nbsp; &nbsp;output (0001H), if output has not been redirected, or a handle obtained
<br>
&nbsp; &nbsp;by opening the logical device CON.
<br>
<br>
Examples:
<br>
<br>
&nbsp;Send the character &quot;*&quot; to the standard output device.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,'*' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; character to output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;Read a character from the standard input device and save it in the
<br>
&nbsp;variable char. If no character is ready, wait until one is available.
<br>
<br>
&nbsp;char &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; input character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;wait: &nbsp; mov &nbsp; &nbsp; ah,6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,0ffh &nbsp; &nbsp; &nbsp; &nbsp; ; parameter for read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;wait &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; wait until char ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; char,al &nbsp; &nbsp; &nbsp; &nbsp; ; save the character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 07H
<br>
Unfiltered character input without echo
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Reads a character from the keyboard without echoing it to the display.
<br>
&nbsp;If no character is ready, waits until one is available.
<br>
<br>
&nbsp;[2.0+] Reads a character from the standard input device without echoing it
<br>
&nbsp;to the standard output device. If no character is ready, waits until one
<br>
&nbsp;is available. Input may be redirected. (If input has been redirected,
<br>
&nbsp;there is no way to detect EOF.)
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 07H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 8-bit input data
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ No special action is taken upon entry of a Ctrl-C when this function is
<br>
&nbsp; &nbsp;used. If Ctrl-C checking is required, use Int 21H Function 08H instead.
<br>
<br>
&nbsp;■ To read extended ASCII codes (such as the special function keys F1 to
<br>
&nbsp; &nbsp;F10) on the IBM PC and compatibles, you must call this function twice.
<br>
&nbsp; &nbsp;The first call returns the value 00H to signal the presence of an
<br>
&nbsp; &nbsp;extended code.
<br>
<br>
&nbsp;■ See also Int 21H Functions 01H, 06H, and 08H, which provide character
<br>
&nbsp; &nbsp;input with various combinations of echo and/or Ctrl-C sensing.
<br>
<br>
&nbsp;■ [2.0+] You can also read the keyboard by issuing a read (Int 21H
<br>
&nbsp; &nbsp;Function 3FH) using the predefined handle for the standard input
<br>
&nbsp; &nbsp;(0000H), if input has not been redirected, or a handle obtained by
<br>
&nbsp; &nbsp;opening the logical device CON.
<br>
<br>
Example:
<br>
<br>
&nbsp;Read a character from the standard input without echoing it to the
<br>
&nbsp;display, and store it in the variable char.
<br>
<br>
&nbsp;char &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; input character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; char,al &nbsp; &nbsp; &nbsp; &nbsp; ; save character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 08H
<br>
Character input without echo
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Reads a character from the keyboard without echoing it to the display.
<br>
&nbsp;If no character is ready, waits until one is available.
<br>
<br>
&nbsp;[2.0+] Reads a character from the standard input device without echoing it
<br>
&nbsp;to the standard output device. If no character is ready, waits until one
<br>
&nbsp;is available. Input may be redirected. (If input has been redirected,
<br>
&nbsp;there is no way to detect EOF.)
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 08H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 8-bit input data
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the standard input is not redirected, and the character read is a
<br>
&nbsp; &nbsp;Ctrl-C, an Int 23H is executed. If the standard input is redirected, a
<br>
&nbsp; &nbsp;Ctrl-C is detected at the console, and BREAK is ON, an Int 23H is
<br>
&nbsp; &nbsp;executed. To avoid possible interruption by a Ctrl-C, use Int 21H
<br>
&nbsp; &nbsp;Function 07H instead.
<br>
<br>
&nbsp;■ To read extended ASCII codes (such as the special function keys F1 to
<br>
&nbsp; &nbsp;F10) on the IBM PC and compatibles, you must call this function twice.
<br>
&nbsp; &nbsp;The first call returns the value 00H to signal the presence of an
<br>
&nbsp; &nbsp;extended code.
<br>
<br>
&nbsp;■ See also Int 21H Functions 01H, 06H, and 07H, which provide character
<br>
&nbsp; &nbsp;input with various combinations of echo and/or Ctrl-C sensing.
<br>
<br>
&nbsp;■ [2.0+] You can also read the keyboard by issuing a read (Int 21H
<br>
&nbsp; &nbsp;Function 3FH) using the predefined handle for the standard input
<br>
&nbsp; &nbsp;(0000H), if input has not been redirected, or a handle obtained by
<br>
&nbsp; &nbsp;opening the logical device CON.
<br>
<br>
Example:
<br>
<br>
&nbsp;Read a character from the standard input without echoing it to the
<br>
&nbsp;display, allowing possible detection of Ctrl-C, and store the character in
<br>
&nbsp;the variable char.
<br>
<br>
&nbsp;char &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; char,al &nbsp; &nbsp; &nbsp; &nbsp; ; save character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 09H
<br>
Display string
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Sends a string of characters to the display.
<br>
<br>
&nbsp;[2.0+] Sends a string of characters to the standard output device. Output
<br>
&nbsp;may be redirected. (If output has been redirected, there is no way to
<br>
&nbsp;detect disk full.)
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 09H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of string
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The string must be terminated with the character $ (24H), which is not
<br>
&nbsp; &nbsp;transmitted. Any other ASCII codes, including control codes, can be
<br>
&nbsp; &nbsp;embedded in the string.
<br>
<br>
&nbsp;■ See Int 21H Functions 02H and 06H for single-character output to the
<br>
&nbsp; &nbsp;video display or standard output device.
<br>
<br>
&nbsp;■ If a Ctrl-C is detected at the keyboard, an Int 23H is executed.
<br>
<br>
&nbsp;■ [2.0+] You can also send strings to the display by performing a write
<br>
&nbsp; &nbsp;(Int 21H Function 40H) using the predefined handle for the standard
<br>
&nbsp; &nbsp;output (0001H), if it has not been redirected, or a handle obtained by
<br>
&nbsp; &nbsp;opening the logical device CON.
<br>
<br>
Example:
<br>
<br>
&nbsp;Send the string Hello World, followed by a carriage return and line feed,
<br>
&nbsp;to the standard output device.
<br>
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh
<br>
&nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah
<br>
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;'Hello World',cr,lf,'$'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg msg &nbsp; &nbsp; &nbsp;; address of string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 0AH (10)
<br>
Buffered keyboard input
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Reads a line from the keyboard and places it in a user-designated
<br>
&nbsp;buffer. The characters are echoed to the display.
<br>
<br>
&nbsp;[2.0+] Reads a string of bytes from the standard input device, up to and
<br>
&nbsp;including an ASCII carriage return (0DH), and places them in a
<br>
&nbsp;user-designated buffer. The characters are echoed to the standard output
<br>
&nbsp;device. Input may be redirected. (If input has been redirected, there is
<br>
&nbsp;no way to detect EOF.)
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0AH
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing (data placed in buffer)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The buffer used by this function has the following format:
<br>
<br>
&nbsp; &nbsp;Byte &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contents
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maximum number of characters to read, set by program
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; number of characters actually read (excluding carriage
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return), set
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by MS-DOS
<br>
&nbsp; &nbsp;2+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;string read from keyboard or standard input, terminated by
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a carriage return (0DH)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;■ If the buffer fills to one fewer than the maximum number of characters
<br>
&nbsp; &nbsp;it can hold, subsequent input is ignored and the bell is sounded until a
<br>
&nbsp; &nbsp;carriage return is detected.
<br>
<br>
&nbsp;■ This input function is buffered with type-ahead capability, and all of
<br>
&nbsp; &nbsp;the standard keyboard editing commands are active.
<br>
<br>
&nbsp;■ If the standard input is not redirected, and a Ctrl-C is detected at the
<br>
&nbsp; &nbsp;console, an Int 23H is executed. If the standard input is redirected, a
<br>
&nbsp; &nbsp;Ctrl-C is detected at the console, and BREAK is ON, an Int 23H is
<br>
&nbsp; &nbsp;executed.
<br>
<br>
&nbsp;■ See Int 21H Functions 01H, 06H, 07H, and 08H for single-character input
<br>
&nbsp; &nbsp;from the keyboard or standard input device.
<br>
<br>
&nbsp;■ [2.0+] You can also read strings from the keyboard by performing a read
<br>
&nbsp; &nbsp;(Int 21H Function 3FH) using the predefined handle for the standard
<br>
&nbsp; &nbsp;input (0000H), if it has not been redirected, or a handle obtained by
<br>
&nbsp; &nbsp;opening the logical device CON.
<br>
<br>
Example:
<br>
<br>
&nbsp;Read a string that is a maximum of 80 characters long from the standard
<br>
&nbsp;input device, placing it in the buffer named buff.
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;81 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; maximum length of input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; actual length of input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;81 dup (0) &nbsp; &nbsp; &nbsp;; actual input placed here
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; input buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 0BH (11)
<br>
Check input status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Checks whether a character is available from the keyboard.
<br>
<br>
&nbsp;[2.0+] Checks whether a character is available from the standard input
<br>
&nbsp;device. Input can be redirected.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0BH
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H if no character is available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH if at least one character is available
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ [1] If a Ctrl-C is detected, an Int 23H is executed.
<br>
<br>
&nbsp;■ [2.0+] If the standard input is not redirected, and a Ctrl-C is detected
<br>
&nbsp; &nbsp;at the console, an Int 23H is executed. If the standard input is
<br>
&nbsp; &nbsp;redirected, a Ctrl-C is detected at the console, and BREAK is ON, an Int
<br>
&nbsp; &nbsp;23H is executed.
<br>
<br>
&nbsp;■ If a character is waiting, this function will continue to return a true
<br>
&nbsp; &nbsp;flag until the character is consumed with a call to Int 21H Function
<br>
&nbsp; &nbsp;01H, 06H, 07H, 08H, 0AH, or 3FH.
<br>
<br>
&nbsp;■ This function is equivalent to IOCTL Int 21H Function 44H Subfunction
<br>
&nbsp; &nbsp;06H.
<br>
<br>
Example:
<br>
<br>
&nbsp;Test whether a character is available from the standard input.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0bh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; character waiting?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; ready &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if char ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 0CH (12)
<br>
Flush input buffer and then input
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[1] Clears the type-ahead buffer and then invokes one of the keyboard
<br>
&nbsp;input functions.
<br>
<br>
&nbsp;[2.0+] Clears the standard input buffer and then invokes one of the
<br>
&nbsp;character input functions. Input can be redirected.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0CH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of input function to be invoked after resetting
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;buffer (must be 01H, 06H, 07H, 08H, or 0AH)
<br>
<br>
&nbsp;(if AL = 0AH)
<br>
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of input buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;(if called with AL = 01H, 06H, 07H, or 08H)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 8-bit input data
<br>
<br>
&nbsp;(if called with AL = 0AH)
<br>
<br>
&nbsp;Nothing (data placed in buffer)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The function exists to allow a program to defeat MS-DOS's type-ahead
<br>
&nbsp; &nbsp;feature. It discards any characters that are waiting in MS-DOS's
<br>
&nbsp; &nbsp;internal type-ahead buffer, forcing the specified input function to wait
<br>
&nbsp; &nbsp;for a character (usually a keyboard entry) that is truly entered after
<br>
&nbsp; &nbsp;the program's request.
<br>
<br>
&nbsp;■ The presence or absence of Ctrl-C checking during execution of this
<br>
&nbsp; &nbsp;function depends on the function number placed in register AL.
<br>
<br>
&nbsp;■ A function number in AL other than 01H, 06H, 07H, 08H, or 0AH simply
<br>
&nbsp; &nbsp;flushes the input buffer and returns control to the calling program.
<br>
<br>
Example:
<br>
<br>
&nbsp;Clear the type-ahead buffer, then wait for a character to be entered,
<br>
&nbsp;echoing it and then returning it in AL. Store the character in the
<br>
&nbsp;variable char.
<br>
<br>
&nbsp;char &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0ch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; subfunction = input char
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; char,al &nbsp; &nbsp; &nbsp; &nbsp; ; save character
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 0DH (13)
<br>
Disk reset
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Flushes all file buffers. All data that has been logically written by user
<br>
&nbsp;programs, but has been temporarily buffered within MS-DOS, is physically
<br>
&nbsp;written to the disk.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0DH
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function does not update the disk directory for any files that are
<br>
&nbsp; &nbsp;still open. If your program fails to properly close all files before the
<br>
&nbsp; &nbsp;disk is removed, and files have changed size, the data forced out to the
<br>
&nbsp; &nbsp;disk by this function may still be inaccessible because the directory
<br>
&nbsp; &nbsp;entries will not be correct.
<br>
<br>
&nbsp;■ [3.3+] Int 21H Function 68H (Commit File) should be used in preference
<br>
&nbsp; &nbsp;to this function, since it also updates the disk directory.
<br>
<br>
Example:
<br>
<br>
&nbsp;Flush all MS-DOS internal disk buffers.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 0EH (14)
<br>
Select disk
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects the specified drive to be the current, or default, disk drive and
<br>
&nbsp;returns the total number of logical drives in the system.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0EH
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive code (0 = A, 1 = B, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of logical drives in system
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ [1] 16 drive designators (0 through 0FH) are available.
<br>
<br>
&nbsp;■ [2] 63 drive designators (0 through 3FH) are available.
<br>
<br>
&nbsp;■ [3.0+] 26 drive designators (0 through 19H) are available.
<br>
<br>
&nbsp;■ To preserve upward compatibility, new applications should limit
<br>
&nbsp; &nbsp;themselves to the drive letters A─Z (0 = A, 1 = B, etc.).
<br>
<br>
&nbsp;■ Logical drives means the total number of block devices: floppy disks,
<br>
&nbsp; &nbsp;simulated disk drives (RAMdisks), and hard-disk drives. A single
<br>
&nbsp; &nbsp;physical hard-disk drive is frequently partitioned into two or more
<br>
&nbsp; &nbsp;logical drives.
<br>
<br>
&nbsp;■ [1] [2] In single-drive IBM PC─compatible systems, the value 2 is
<br>
&nbsp; &nbsp;returned in AL, because PC-DOS supports two logical drives (A: and B:)
<br>
&nbsp; &nbsp;on the single physical floppy-disk drive. The actual number of physical
<br>
&nbsp; &nbsp;drives in the system can be determined with ROM BIOS Int 11H.
<br>
<br>
&nbsp;■ [3.0+] The value returned in AL is either 5 or the drive code
<br>
&nbsp; &nbsp;corresponding to the LASTDRIVE entry (if any) in CONFIG.SYS, whichever
<br>
&nbsp; &nbsp;is greater.
<br>
<br>
Example:
<br>
<br>
&nbsp;Make drive B the current (default) disk drive. Save the total number of
<br>
&nbsp;logical drives in the system in the variable drives.
<br>
<br>
&nbsp;drives &nbsp;db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive 1 = B
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; drives,al &nbsp; &nbsp; &nbsp; ; save total drives
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 0FH (15)
<br>
Open file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Opens a file and makes it available for subsequent read/write operations.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0FH
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (file found)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and FCB filled in by MS-DOS as follows:
<br>
<br>
&nbsp;drive field (offset 00H) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 for drive A, 2 for drive B, etc.
<br>
&nbsp;current block field (offset 0CH) &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;record size field (offset 0EH) &nbsp; &nbsp; &nbsp; &nbsp;= 0080H
<br>
&nbsp;[2.0+] size field (offset 10H) &nbsp; &nbsp; &nbsp; &nbsp;= file size from directory
<br>
&nbsp;[2.0+] date field (offset 14H) &nbsp; &nbsp; &nbsp; &nbsp;= date stamp from directory
<br>
&nbsp;[2.0+] time field (offset 16H) &nbsp; &nbsp; &nbsp; &nbsp;= time stamp from directory
<br>
<br>
&nbsp;If function unsuccessful (file not found)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If your program is going to use a record size other than 128 bytes, it
<br>
&nbsp; &nbsp;should set the record-size field at FCB offset 0EH after the file is
<br>
&nbsp; &nbsp;successfully opened and before any other disk operation.
<br>
<br>
&nbsp;■ If random access is to be performed, the calling program must also set
<br>
&nbsp; &nbsp;the FCB relative-record field (offset 21H) after successfully opening
<br>
&nbsp; &nbsp;the file.
<br>
<br>
&nbsp;■ For format of directory time and date, see Int 21H Function 57H.
<br>
<br>
&nbsp;■ [2.0+] Int 21H Function 3DH, which allows full access to the
<br>
&nbsp; &nbsp;hierarchical directory structure, should be used in preference to this
<br>
&nbsp; &nbsp;function.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the file is opened for
<br>
&nbsp; &nbsp;read/write access in compatibility sharing mode.
<br>
<br>
Example:
<br>
<br>
&nbsp;Attempt to open the file named QUACK.DAT on the default disk drive.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'QUACK &nbsp; ' &nbsp; &nbsp; &nbsp;; filename, 8 characters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 characters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if open failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 10H (16)
<br>
Close file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Closes a file, flushes all MS-DOS internal disk buffers associated with
<br>
&nbsp;the file to disk, and updates the disk directory if the file has been
<br>
&nbsp;modified or extended.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (directory update successful)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful (file not found in directory)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ [1] [2] MS-DOS versions 1 and 2 do not reliably detect a floppy-disk
<br>
&nbsp; &nbsp;change, and an error can occur if the user changes disks while a file is
<br>
&nbsp; &nbsp;still open on that drive. In the worst case, the directory and file
<br>
&nbsp; &nbsp;allocation table of the newly inserted disk can be damaged or destroyed.
<br>
<br>
&nbsp;■ [2.0+] Int 21H Function 3EH should be used in preference to this
<br>
&nbsp; &nbsp;function.
<br>
<br>
Example:
<br>
<br>
&nbsp;Close the file that was previously opened using the file control block
<br>
&nbsp;named myfcb.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'QUACK &nbsp; ' &nbsp; &nbsp; &nbsp;; filename, 8 characters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 characters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if close failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 11H (17)
<br>
Find first file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Searches the current directory on the designated drive for a matching
<br>
&nbsp;filename.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (matching filename found)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and buffer at current disk transfer area (DTA) address filled in as an
<br>
&nbsp;unopened normal FCB or extended FCB, depending on which type of FCB was
<br>
&nbsp;input to function
<br>
<br>
&nbsp;If function unsuccessful (no matching filename found)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Use Int 21H Function 1AH to set the DTA to point to a buffer of
<br>
&nbsp; &nbsp;adequate size before calling this function.
<br>
<br>
&nbsp;■ The wildcard character ? is allowed in the filename in all versions of
<br>
&nbsp; &nbsp;MS-DOS. In versions 3.0 and later, the wildcard character * may also be
<br>
&nbsp; &nbsp;used in a filename. If ? or * is used, this function returns the first
<br>
&nbsp; &nbsp;matching filename.
<br>
<br>
&nbsp;■ An extended FCB must be used to search for files that have the system,
<br>
&nbsp; &nbsp;hidden, read-only, directory, or volume-label attributes.
<br>
<br>
&nbsp;■ If an extended FCB is used, its attribute byte determines the type of
<br>
&nbsp; &nbsp;search that will be performed. If the attribute byte contains 00H, only
<br>
&nbsp; &nbsp;ordinary files are found. If the volume-label attribute bit is set, only
<br>
&nbsp; &nbsp;volume labels will be returned (if any are present). If any other
<br>
&nbsp; &nbsp;attribute or combination of attributes is set (such as hidden, system,
<br>
&nbsp; &nbsp;or read-only), those files and all ordinary files will be matched.
<br>
<br>
&nbsp;■ [2.0+] Int 21H Function 4EH, which allows full access to the
<br>
&nbsp; &nbsp;hierarchical directory structure, should be used in preference to this
<br>
&nbsp; &nbsp;function.
<br>
<br>
Example:
<br>
<br>
&nbsp;Search for the first file with the extension .COM in the current
<br>
&nbsp;directory.
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;37 dup (0) &nbsp; &nbsp; &nbsp;; receives search result
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'????????' &nbsp; &nbsp; &nbsp;; wildcard filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'COM' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension = COM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set DTA address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; search for first match
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,11h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if no match
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 12H (18)
<br>
Find next file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given that a previous call to Int 21H Function 11H has been successful,
<br>
&nbsp;returns the next matching filename (if any).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (matching filename found)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and buffer at current disk transfer area (DTA) address set up as an
<br>
&nbsp;unopened normal FCB or extended FCB, depending on which type of FCB was
<br>
&nbsp;originally input to Int 21H Function 11H
<br>
<br>
&nbsp;If function unsuccessful (no more matching filenames found)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function assumes that the FCB used as input has been properly
<br>
&nbsp; &nbsp;initialized by a previous call to Int 21H Function 11H (and possible
<br>
&nbsp; &nbsp;subsequent calls to Int 21H Function 12H) and that the filename or
<br>
&nbsp; &nbsp;extension being searched for contained at least one wildcard character.
<br>
<br>
&nbsp;■ As with Int 21H Function 11H, it is important to use Int 21H Function
<br>
&nbsp; &nbsp;1AH to set the DTA to a buffer of adequate size before calling this
<br>
&nbsp; &nbsp;function.
<br>
<br>
&nbsp;■ [2.0+] Int 21H Functions 4EH and 4FH, which allow full access to the
<br>
&nbsp; &nbsp;hierarchical directory structure, should be used in preference to this
<br>
&nbsp; &nbsp;function.
<br>
<br>
Example:
<br>
<br>
&nbsp;Assuming a previous successful call to function 11H, search for the next
<br>
&nbsp;file with the extension .COM in the current directory. If the DTA has not
<br>
&nbsp;been changed since the previous search, another call to Function 1AH is
<br>
&nbsp;not necessary.
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;37 dup (0) &nbsp; &nbsp; &nbsp;; receives search result
<br>
<br>
&nbsp;my_fcb &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'????????' &nbsp; &nbsp; &nbsp;; wildcard filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'COM' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension = COM
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set DTA address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; search for next match
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,12h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if no match
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 13H (19)
<br>
Delete file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Deletes all matching files from the current directory on the default or
<br>
&nbsp;specified disk drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 13H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (file or files deleted)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful (no matching files were found, or at least one
<br>
&nbsp;matching file was read-only)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The wildcard character ? is allowed in the filename; if ? is present and
<br>
&nbsp; &nbsp;there is more than one matching filename, all matching files will be
<br>
&nbsp; &nbsp;deleted.
<br>
<br>
&nbsp;■ [2.0+] Int 21H Function 41H, which allows full access to the
<br>
&nbsp; &nbsp;hierarchical directory structure, should be used in preference to this
<br>
&nbsp; &nbsp;function.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Create
<br>
&nbsp; &nbsp;rights to the directory containing the file to be deleted.
<br>
<br>
Example:
<br>
<br>
&nbsp;Delete the file MYFILE.DAT from the current disk drive and directory.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'MYFILE &nbsp;' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,13h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, delete failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 14H (20)
<br>
Sequential read
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads the next sequential block of data from a file, then increments the
<br>
&nbsp;file pointer appropriately.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 14H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of previously opened file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if read successful
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if end of file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if segment wrap
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if partial record read at end of file
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The record is read into memory at the current disk transfer area (DTA)
<br>
&nbsp; &nbsp;address, specified by the most recent call to Int 21H Function 1AH. If
<br>
&nbsp; &nbsp;the size of the record and the location of the buffer are such that a
<br>
&nbsp; &nbsp;segment overflow or wraparound would occur, the function fails with a
<br>
&nbsp; &nbsp;return code of 02H.
<br>
<br>
&nbsp;■ The number of bytes of data to be read is specified by the record-size
<br>
&nbsp; &nbsp;field (offset 0EH) of the file control block (FCB).
<br>
<br>
&nbsp;■ The file location of the data that will be read is specified by the
<br>
&nbsp; &nbsp;combination of the current block field (offset 0CH) and current record
<br>
&nbsp; &nbsp;field (offset 20H) of the file control block (FCB). These fields are
<br>
&nbsp; &nbsp;also automatically incremented by this function.
<br>
<br>
&nbsp;■ If a partial record is read at the end of file, it is padded to the
<br>
&nbsp; &nbsp;requested record length with zeros.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Read
<br>
&nbsp; &nbsp;access rights to the directory containing the file to be read.
<br>
<br>
Example:
<br>
<br>
&nbsp;Read 1024 bytes of data from the file specified by the previously opened
<br>
&nbsp;file control block myfcb.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'QUACK &nbsp; ' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,14h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+0eH,1024
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if read failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 15H (21)
<br>
Sequential write
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Writes the next sequential block of data into a file, then increments the
<br>
&nbsp;file pointer appropriately.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 15H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of previously opened file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if write successful
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if disk is full
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if segment wrap
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The record is written (logically, not necessarily physically) to the
<br>
&nbsp; &nbsp;disk from memory at the current disk transfer area (DTA) address,
<br>
&nbsp; &nbsp;specified by the most recent call to Int 21H Function 1AH. If the size
<br>
&nbsp; &nbsp;of the record and the location of the buffer are such that a segment
<br>
&nbsp; &nbsp;overflow or wraparound would occur, the function fails with a return
<br>
&nbsp; &nbsp;code of 02H.
<br>
<br>
&nbsp;■ The number of bytes of data to be written is specified by the
<br>
&nbsp; &nbsp;record-size field (offset 0EH) of the file control block (FCB).
<br>
<br>
&nbsp;■ The file location of the data that will be written is specified by the
<br>
&nbsp; &nbsp;combination of the current block field (offset 0CH) and current record
<br>
&nbsp; &nbsp;field (offset 20H) of the file control block (FCB). These fields are
<br>
&nbsp; &nbsp;also automatically incremented by this function.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Write
<br>
&nbsp; &nbsp;access rights to the directory containing the file to be written.
<br>
<br>
Example:
<br>
<br>
&nbsp;Write 1024 bytes of data to the file specified by the previously opened
<br>
&nbsp;file control block myfcb.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'QUACK &nbsp; ' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,15h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+0eh,1024
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if write failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 16H (22)
<br>
Create file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Creates a new directory entry in the current directory or truncates any
<br>
&nbsp;existing file with the same name to zero length. Opens the file for
<br>
&nbsp;subsequent read/write operations.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 16H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of unopened file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (file was created or truncated)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and FCB filled in by MS-DOS as follows:
<br>
<br>
&nbsp;drive field (offset 00H) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 for drive A, 2 for drive B, etc.
<br>
&nbsp;current block field (offset 0CH) &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;record size field (offset 0EH) &nbsp; &nbsp; &nbsp; &nbsp;= 0080H
<br>
&nbsp;[2.0+] size field (offset 10H) &nbsp; &nbsp; &nbsp; &nbsp;= file size from directory
<br>
&nbsp;[2.0+] date field (offset 14H) &nbsp; &nbsp; &nbsp; &nbsp;= date stamp from directory
<br>
&nbsp;[2.0+] time field (offset 16H) &nbsp; &nbsp; &nbsp; &nbsp;= time stamp from directory
<br>
<br>
&nbsp;If function unsuccessful (directory full)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Since an existing file with the specified name is truncated to zero
<br>
&nbsp; &nbsp;length (i.e., all data in that file is irretrievably lost), this
<br>
&nbsp; &nbsp;function must be used with caution.
<br>
<br>
&nbsp;■ If this function is called with an extended file control block (FCB),
<br>
&nbsp; &nbsp;the new file may be assigned a special attribute, such as hidden or
<br>
&nbsp; &nbsp;system, during its creation by setting the appropriate bit in the
<br>
&nbsp; &nbsp;extended FCB's attribute byte.
<br>
<br>
&nbsp;■ Since this function also opens the file, a subsequent call to Int 21H
<br>
&nbsp; &nbsp;Function 0FH is not required.
<br>
<br>
&nbsp;■ For format of directory time and date, see Int 21H Function 57H.
<br>
<br>
&nbsp;■ [2.0+] Int 21H Functions 3CH, 5AH, 5BH, and 6CH, which provide full
<br>
&nbsp; &nbsp;access to the hierarchical directory structure, should be used in
<br>
&nbsp; &nbsp;preference to this function.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Create
<br>
&nbsp; &nbsp;rights to the directory that will contain the new file.
<br>
<br>
Example:
<br>
<br>
&nbsp;Create a file in the current directory using the name in the file control
<br>
&nbsp;block myfcb.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'QUACK &nbsp; ' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,16h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if create failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 17H (23)
<br>
Rename file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Alters the name of all matching files in the current directory on the disk
<br>
&nbsp;in the specified drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 17H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of &quot;special&quot; file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (one or more files renamed)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful (no matching files, or new filename matched an
<br>
&nbsp;existing file)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The special file control block has a drive code, filename, and extension
<br>
&nbsp; &nbsp;in the usual position (bytes 0 through 0BH) and a second filename
<br>
&nbsp; &nbsp;starting 6 bytes after the first (offset 11H).
<br>
<br>
&nbsp;■ The ? wildcard character can be used in the first filename. Every file
<br>
&nbsp; &nbsp;matching the first file specification will be renamed to match the
<br>
&nbsp; &nbsp;second file specification.
<br>
<br>
&nbsp;■ If the second file specification contains any ? wildcard characters, the
<br>
&nbsp; &nbsp;corresponding letters in the first filename are left unchanged.
<br>
<br>
&nbsp;■ The function terminates if the new name to be assigned to a file matches
<br>
&nbsp; &nbsp;that of an existing file.
<br>
<br>
&nbsp;■ [2.0+] An extended FCB can be used with this function to rename a
<br>
&nbsp; &nbsp;directory.
<br>
<br>
&nbsp;■ [2.0+] Int 21H Function 56H, which allows full access to the
<br>
&nbsp; &nbsp;hierarchical directory structure, should be used in preference to this
<br>
&nbsp; &nbsp;function.
<br>
<br>
Example:
<br>
<br>
&nbsp;Rename the file OLDNAME.DAT to NEWNAME.DAT.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'OLDNAME ' &nbsp; &nbsp; &nbsp;; old file name, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; old extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;6 dup (0) &nbsp; &nbsp; &nbsp; ; reserved area
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'NEWNAME ' &nbsp; &nbsp; &nbsp;; new file name, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; new extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;14 dup (0) &nbsp; &nbsp; &nbsp;; reserved area
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,17h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if rename failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 18H (24)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 19H (25)
<br>
Get current disk
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the drive code of the current, or default, disk drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 19H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive code (0 = A, 1 = B, etc.)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ To set the default drive, use Int 21H Function 0EH.
<br>
<br>
&nbsp;■ Some other Int 21H functions use drive codes beginning at 1 (that is,
<br>
&nbsp; &nbsp;1 = A, 2 = B, etc.) and reserve drive code zero for the default drive.
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the current disk drive and save the code in the variable cdrive.
<br>
<br>
&nbsp;cdrive &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; current drive code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,19h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cdrive,al &nbsp; &nbsp; &nbsp; ; save drive code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 1AH (26)
<br>
Set DTA address
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Specifies the address of the disk transfer area (DTA) to be used for
<br>
&nbsp;subsequent FCB-related function calls.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1AH
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of disk transfer area
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If this function is never called by the program, the DTA defaults to a
<br>
&nbsp; &nbsp;128-byte buffer at offset 0080H in the program segment prefix.
<br>
<br>
&nbsp;■ In general, it is the programmer's responsibility to ensure that the
<br>
&nbsp; &nbsp;buffer area specified is large enough for any disk operation that will
<br>
&nbsp; &nbsp;use it. The only exception to this is that MS-DOS will detect and abort
<br>
&nbsp; &nbsp;disk transfers that would cause a segment wrap.
<br>
<br>
&nbsp;■ Int 21H Function 2FH can be used to determine the current disk transfer
<br>
&nbsp; &nbsp;address.
<br>
<br>
&nbsp;■ The only handle-type operations that rely on the DTA address are the
<br>
&nbsp; &nbsp;directory search functions, Int 21H Functions 4EH and 4FH.
<br>
<br>
Example:
<br>
<br>
&nbsp;Set the current disk transfer area address to the buffer labeled buff.
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;128 dup (?)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; address of disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer area
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 1BH (27)
<br>
Get default drive data
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains selected information about the default disk drive and a pointer to
<br>
&nbsp;the media identification byte from its file allocation table.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1BH
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sectors per cluster
<br>
&nbsp;DS:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of media ID byte
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= size of physical sector (bytes)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of clusters for default drive
<br>
<br>
&nbsp;If function unsuccessful (invalid drive or critical error)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The media ID byte has the following meanings:
<br>
<br>
&nbsp;0F0H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.5-inch double-sided, 18 sectors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or &quot;other&quot;
<br>
&nbsp;0F8H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed disk
<br>
&nbsp;0F9H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25-inch double-sided, 15 sectors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or 3.5-inch double-sided, 9 sectors
<br>
&nbsp;0FCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25-inch single-sided, 9 sectors
<br>
&nbsp;0FDH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25-inch double-sided, 9 sectors
<br>
&nbsp;0FEH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25-inch single-sided, 8 sectors
<br>
&nbsp;0FFH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25-inch double-sided, 8 sectors
<br>
<br>
&nbsp;■ To obtain information about disks other than the one in the default
<br>
&nbsp; &nbsp;drive, use Int 21H Function 1CH or 36H.
<br>
<br>
&nbsp;■ [1] The address returned in DS:BX points to a copy of the first sector
<br>
&nbsp; &nbsp;of the actual FAT, with the media ID byte in the first byte.
<br>
<br>
&nbsp;■ [2.0+] The address returned in DS:BX points only to a copy of the media
<br>
&nbsp; &nbsp;ID byte from the disk's FAT; the memory above that address cannot be
<br>
&nbsp; &nbsp;assumed to contain the FAT or any other useful information. If direct
<br>
&nbsp; &nbsp;access to the FAT is required, use Int 25H to read it into memory.
<br>
<br>
Example:
<br>
<br>
&nbsp;Determine whether the current disk drive is fixed or removable.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1bh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; check media ID byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr [bx],0f8h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;fixed &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if fixed disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; floppy &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; else assume floppy
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 1CH (28)
<br>
Get drive data
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains allocation information about the specified disk drive and a
<br>
&nbsp;pointer to the media identification byte from its file allocation table.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1CH
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive code (0 = default, 1 = A, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sectors per cluster
<br>
&nbsp;DS:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of media ID byte
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= size of physical sector (bytes)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of clusters for default or specified drive
<br>
<br>
&nbsp;If function unsuccessful (invalid drive or critical error)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The media ID byte has the following meanings:
<br>
<br>
&nbsp;0F0H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.5-inch double-sided, 18 sectors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or &quot;other&quot;
<br>
&nbsp;0F8H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed disk
<br>
&nbsp;0F9H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25-inch double-sided, 15 sectors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or 3.5-inch double-sided, 9 sectors
<br>
&nbsp;0FCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25-inch single-sided, 9 sectors
<br>
&nbsp;0FDH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25-inch double-sided, 9 sectors
<br>
&nbsp;0FEH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25-inch single-sided, 8 sectors
<br>
&nbsp;0FFH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.25-inch double-sided, 8 sectors
<br>
<br>
&nbsp;■ In general, this call is identical to Int 21H Function 1BH, except for
<br>
&nbsp; &nbsp;the ability to designate a specific disk drive. See also Int 21H
<br>
&nbsp; &nbsp;Function 36H, which returns similar information.
<br>
<br>
&nbsp;■ [1] The address returned in DS:BX points to a copy of the first sector
<br>
&nbsp; &nbsp;of the actual FAT, with the media ID byte in the first byte.
<br>
<br>
&nbsp;■ [2.0+] The address returned in DS:BX points only to a copy of the media
<br>
&nbsp; &nbsp;ID byte from the disk's FAT; the memory above that address cannot be
<br>
&nbsp; &nbsp;assumed to contain the FAT or any other useful information. If direct
<br>
&nbsp; &nbsp;access to the FAT is required, use Int 25H to read it into memory.
<br>
<br>
Example:
<br>
<br>
&nbsp;Determine whether disk drive C is fixed or removable.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive code 3 = C
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; check media ID byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; byte ptr ds:[bx],0f8h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;fixed &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if fixed disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; floppy &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; else assume floppy
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 1DH (29)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 1EH (30)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 1FH (31)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 20H (32)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 21H (33)
<br>
Random read
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads a selected record from a file into memory.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 21H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of previously opened file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if read successful
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if end of file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if segment wrap, read canceled
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if partial record read at end of file
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The record is read into memory at the current disk transfer area
<br>
&nbsp; &nbsp;address, specified by the most recent call to Int 21H Function 1AH. It
<br>
&nbsp; &nbsp;is the programmer's responsibility to ensure that this area is large
<br>
&nbsp; &nbsp;enough for any record that will be transferred. If the size and location
<br>
&nbsp; &nbsp;of the buffer are such that a segment overflow or wraparound would
<br>
&nbsp; &nbsp;occur, the function fails with a return code of 02H.
<br>
<br>
&nbsp;■ The file location of the data to be read is determined by the
<br>
&nbsp; &nbsp;combination of the relative-record field (offset 21H) and the
<br>
&nbsp; &nbsp;record-size field (offset 0EH) of the FCB. The default record size is
<br>
&nbsp; &nbsp;128 bytes.
<br>
<br>
&nbsp;■ The current block field (offset 0CH) and current record field (offset
<br>
&nbsp; &nbsp;20H) are updated to agree with the relative-record field as a side
<br>
&nbsp; &nbsp;effect of the function.
<br>
<br>
&nbsp;■ The relative-record field of the FCB is not incremented by this
<br>
&nbsp; &nbsp;function; it is the responsibility of the application to update the FCB
<br>
&nbsp; &nbsp;appropriately if it wishes to read successive records. Compare with Int
<br>
&nbsp; &nbsp;21H Function 27H, which can read multiple records with one function
<br>
&nbsp; &nbsp;call and automatically increments the relative-record field.
<br>
<br>
&nbsp;■ If a partial record is read at end of file, it is padded to the
<br>
&nbsp; &nbsp;requested record length with zeros.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Read
<br>
&nbsp; &nbsp;access rights to the directory containing the file to be read.
<br>
<br>
Example:
<br>
<br>
&nbsp;Open the file MYFILE.DAT, set the record length to 1024 bytes, then read
<br>
&nbsp;record number 4 from the file into the buffer named buff.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'MYFILE &nbsp;' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;1024 dup (?) &nbsp; &nbsp;; receives read data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; open the file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check open status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if no file
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set DTA address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff &nbsp;; read buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+0eh,1024
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set record number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+21h,4
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+23h,0
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read the record
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb ; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if read failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 22H (34)
<br>
Random write
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Writes data from memory into a selected record in a file.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 22H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of previously opened file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if write successful
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if disk full
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if segment wrap, write canceled
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The record is written (logically, not necessarily physically) to the
<br>
&nbsp; &nbsp;file from memory at the current disk transfer address, specified by the
<br>
&nbsp; &nbsp;most recent call to Int 21H Function 1AH. If the size and location of
<br>
&nbsp; &nbsp;the buffer are such that a segment overflow or wraparound would occur,
<br>
&nbsp; &nbsp;the function fails with a return code of 02H.
<br>
<br>
&nbsp;■ The file location of the data to be written is determined by the
<br>
&nbsp; &nbsp;combination of the relative-record field (offset 21H) and the
<br>
&nbsp; &nbsp;record-size field (offset 0EH) of the FCB. The default record size is
<br>
&nbsp; &nbsp;128 bytes.
<br>
<br>
&nbsp;■ The current block field (offset 0CH) and current record field (offset
<br>
&nbsp; &nbsp;20H) are updated to agree with the relative-record field as a side
<br>
&nbsp; &nbsp;effect of the function.
<br>
<br>
&nbsp;■ The relative-record field of the FCB is not incremented by this
<br>
&nbsp; &nbsp;function; it is the responsibility of the application to update the FCB
<br>
&nbsp; &nbsp;appropriately if it wishes to write successive records. Compare with Int
<br>
&nbsp; &nbsp;21H Function 28H, which can write multiple records with one function
<br>
&nbsp; &nbsp;call and automatically increments the relative-record field.
<br>
<br>
&nbsp;■ If a record is written beyond the current end of file, the space between
<br>
&nbsp; &nbsp;the old end of file and the new record is allocated but not initialized.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Write
<br>
&nbsp; &nbsp;access rights to the directory containing the file to be written.
<br>
<br>
Example:
<br>
<br>
&nbsp;Open the file MYFILE.DAT, set the record length to 1024 bytes, write
<br>
&nbsp;record number 4 into the file from the buffer named buff, then close the
<br>
&nbsp;file.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'MYFILE &nbsp;' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;1024 dup (?) &nbsp; &nbsp;; buffer for write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; open the file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if no file
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set DTA address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff &nbsp;; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+0eh,1024
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set record number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+21h,4
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+23h,0
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the record
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,22h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb ; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if write failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; close the file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb ; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if close failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 23H (35)
<br>
Get file size
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Searches for a matching file in the current directory; if one is found,
<br>
&nbsp;updates the FCB with the file's size in terms of number of records.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 23H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of unopened file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (matching file found)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and FCB relative-record field (offset 21H) set to the number of records in
<br>
&nbsp;the file, rounded up if necessary to the next complete record
<br>
<br>
&nbsp;If function unsuccessful (no matching file found)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ An appropriate value must be placed in the FCB record-size field (offset
<br>
&nbsp; &nbsp;0EH) before calling this function. There is no default record size for
<br>
&nbsp; &nbsp;this function. Compare with the FCB-related open and create functions
<br>
&nbsp; &nbsp;(Int 21H Functions 0FH and 16H), which initialize the FCB for a
<br>
&nbsp; &nbsp;default record size of 128 bytes.
<br>
<br>
&nbsp;■ The record-size field can be set to 1 to find the size of the file in
<br>
&nbsp; &nbsp;bytes.
<br>
<br>
&nbsp;■ Because record numbers are zero based, this function can be used to
<br>
&nbsp; &nbsp;position the FCB's file pointer to the end of file.
<br>
<br>
Example:
<br>
<br>
&nbsp;Determine the size in bytes of the file MYFILE.DAT and leave the result in
<br>
&nbsp;registers DX:AX.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'MYFILE &nbsp;' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,23h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; record size = 1 byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+0eh,1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if no file
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get file size in bytes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,word ptr myfcb+21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,word ptr myfcb+23h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 24H (36)
<br>
Set relative record number
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the relative-record-number field of a file control block (FCB) to
<br>
&nbsp;correspond to the current file position as recorded in the opened FCB.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 24H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of previously opened file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL is destroyed (other registers not affected)
<br>
<br>
&nbsp;FCB relative-record field (offset 21H) updated
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is used when switching from sequential to random I/O
<br>
&nbsp; &nbsp;within a file. The contents of the relative-record field (offset 21H)
<br>
&nbsp; &nbsp;are derived from the record size (offset 0EH), current block (offset
<br>
&nbsp; &nbsp;0CH), and current record (offset 20H) fields of the file control block.
<br>
<br>
&nbsp;■ All four bytes of the FCB relative-record field (offset 21H) should be
<br>
&nbsp; &nbsp;initialized to zero before calling this function.
<br>
<br>
Example:
<br>
<br>
&nbsp;After a series of sequential record transfers have been performed using
<br>
&nbsp;the file control block myfcb, obtain the current relative-record position
<br>
&nbsp;in the file and leave the record number in DX.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'MYFILE &nbsp;' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; make FCB addressable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; initialize relative
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; record field to zero
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+21h,0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+23h,0
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now set record number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,24h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb ; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; load record number in DX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,word ptr myfcb+21h
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 25H (37)
<br>
Set interrupt vector
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes a CPU interrupt vector to point to an interrupt handling
<br>
&nbsp;routine.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 25H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= interrupt number
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of interrupt handling routine
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function should be used in preference to direct editing of the
<br>
&nbsp; &nbsp;interrupt-vector table by well-behaved applications.
<br>
<br>
&nbsp;■ Before an interrupt vector is modified, its original value should be
<br>
&nbsp; &nbsp;obtained with Int 21H Function 35H and saved, so that it can be restored
<br>
&nbsp; &nbsp;using this function before program termination.
<br>
<br>
Example:
<br>
<br>
&nbsp;Install a new interrupt handler, named zdiv, for &quot;divide by zero&quot; CPU
<br>
&nbsp;exceptions.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,25h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; interrupt number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg zdiv &nbsp; &nbsp; ; address of handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset zdiv
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;zdiv: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; int 00h handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; (does nothing)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 26H (38)
<br>
Create new PSP
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Copies the program segment prefix (PSP) of the currently executing program
<br>
&nbsp;to a specified segment address in free memory, then updates the new PSP to
<br>
&nbsp;make it usable by another program.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 26H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment of new program segment prefix
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ After the executing program's PSP is copied into the new segment, the
<br>
&nbsp; &nbsp;memory size information in the new PSP is updated appropriately and the
<br>
&nbsp; &nbsp;current contents of the termination (Int 22H), Ctrl-C handler (Int 23H),
<br>
&nbsp; &nbsp;and critical-error handler (Int 24H) vectors are saved starting at
<br>
&nbsp; &nbsp;offset 0AH.
<br>
<br>
&nbsp;■ This function does not load another program or in itself cause one to be
<br>
&nbsp; &nbsp;executed.
<br>
<br>
&nbsp;■ [2.0+] Int 21H Function 4BH (EXEC), which can be used to load and
<br>
&nbsp; &nbsp;execute programs or overlays in either .COM or .EXE format, should be
<br>
&nbsp; &nbsp;used in preference to this function.
<br>
<br>
Example:
<br>
<br>
&nbsp;Create a new program segment prefix 64 KB above the currently executing
<br>
&nbsp;program. This example assumes that the running program was loaded as a
<br>
&nbsp;.COM file so that the CS register points to its PSP throughout its
<br>
&nbsp;execution. If the running program was loaded as a .EXE file, the address
<br>
&nbsp;of the PSP must be obtained with Int 21H Function 62H (under MS-DOS 3.0
<br>
&nbsp;or later) or by saving the original contents of the DS or ES registers at
<br>
&nbsp;entry.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,26h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,cs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; PSP segment of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; this program
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; dx,1000h &nbsp; &nbsp; &nbsp; &nbsp;; add 64 KB as
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; paragraph address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 27H (39)
<br>
Random block read
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads one or more sequential records from a file into memory, starting at
<br>
&nbsp;a designated file location.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 27H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of records to read
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of previously opened file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if all requested records read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if end of file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if segment wrap
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if partial record read at end of file
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= actual number of records read
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The records are read into memory at the current disk transfer area
<br>
&nbsp; &nbsp;address, specified by the most recent call to Int 21H Function 1AH. It
<br>
&nbsp; &nbsp;is the programmer's responsibility to ensure that this area is large
<br>
&nbsp; &nbsp;enough for the group of records that will be transferred. If the size
<br>
&nbsp; &nbsp;and location of the buffer are such that a segment overflow or
<br>
&nbsp; &nbsp;wraparound would occur, the function fails with a return code of 02H.
<br>
<br>
&nbsp;■ The file location of the data to be read is determined by the
<br>
&nbsp; &nbsp;combination of the relative-record field (offset 21H) and the
<br>
&nbsp; &nbsp;record-size field (offset 0EH) of the FCB. The default record size is
<br>
&nbsp; &nbsp;128 bytes.
<br>
<br>
&nbsp;■ After the disk transfer is performed, the current block (offset 0CH),
<br>
&nbsp; &nbsp;current record (offset 20H), and relative-record (offset 21H) fields of
<br>
&nbsp; &nbsp;the FCB are updated to point to the next record in the file.
<br>
<br>
&nbsp;■ If a partial record is read at the end of file, the remainder of the
<br>
&nbsp; &nbsp;record is padded with zeros.
<br>
<br>
&nbsp;■ Compare with Int 21H Function 21H, which transfers only one record per
<br>
&nbsp; &nbsp;function call and does not update the FCB relative-record field.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Read
<br>
&nbsp; &nbsp;access rights to the directory containing the file to be read.
<br>
<br>
Example:
<br>
<br>
&nbsp;Read four 1024-byte records starting at record number 8 into the buffer
<br>
&nbsp;named buff, using the file control block myfcb.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'MYFILE &nbsp;' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;4096 dup (?) &nbsp; &nbsp;; buffer for data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set DTA address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; address of buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set relative-record number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+21h,8
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+23h,0
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+0eh,1024
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read the records
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,27h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; number of records
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb ; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if read error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 28H (40)
<br>
Random block write
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Writes one or more sequential records from memory to a file, starting at a
<br>
&nbsp;designated file location.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 28H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of records to write
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of previously opened file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if all requested records written
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if disk full
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if segment wrap
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= actual number of records written
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The records are written (logically, not necessarily physically) to disk
<br>
&nbsp; &nbsp;from memory at the current disk transfer area address, specified by the
<br>
&nbsp; &nbsp;most recent call to Int 21H Function 1AH. If the size and location of
<br>
&nbsp; &nbsp;the buffer are such that a segment overflow or wraparound would occur,
<br>
&nbsp; &nbsp;the function fails with a return code of 02H.
<br>
<br>
&nbsp;■ The file location of the data to be written is determined by the
<br>
&nbsp; &nbsp;combination of the relative-record field (offset 21H) and the
<br>
&nbsp; &nbsp;record-size field (offset 0EH) of the FCB. The default record size is
<br>
&nbsp; &nbsp;128 bytes.
<br>
<br>
&nbsp;■ After the disk transfer is performed, the current block (offset 0CH),
<br>
&nbsp; &nbsp;current record (offset 20H), and relative-record (offset 21H) fields of
<br>
&nbsp; &nbsp;the FCB are updated to point to the next record in the file.
<br>
<br>
&nbsp;■ If this function is called with CX = 0, no data is written to the disk
<br>
&nbsp; &nbsp;but the file is extended or truncated to the length specified by
<br>
&nbsp; &nbsp;combination of the record-size (offset 0EH) and the relative-record
<br>
&nbsp; &nbsp;(offset 21H) fields of the FCB.
<br>
<br>
&nbsp;■ Compare with Int 21H Function 22H, which transfers only one record per
<br>
&nbsp; &nbsp;function call and does not update the FCB relative-record field.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Write
<br>
&nbsp; &nbsp;access rights to the directory containing the file to be written.
<br>
<br>
Example:
<br>
<br>
&nbsp;Write four 1024-byte records, starting at record number 8, to disk from
<br>
&nbsp;the buffer named buff, using the file control block myfcb.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'MYFILE &nbsp;' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;4096 dup (?) &nbsp; &nbsp;; buffer for data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set DTA address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; address of buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set relative-record number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+21h,8
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+23h,0
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr myfcb+0eh,1024
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write the records
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,28h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; number of records
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb ; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if write error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 29H (41)
<br>
Parse filename
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Parses a text string into the various fields of a file control block
<br>
&nbsp;(FCB).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 29H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= flags to control parsing
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bit 3 &nbsp; &nbsp; &nbsp; &nbsp;= 1 &nbsp; &nbsp;if extension field in FCB will be
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified only if an extension is
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specified in the string being parsed.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0 &nbsp; &nbsp;if extension field in FCB will be
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified regardless; if no extension is
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; present in the parsed string, FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extension is set to ASCII blanks.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bit 2 &nbsp; &nbsp; &nbsp; &nbsp;= 1 &nbsp; &nbsp;if filename field in FCB will be
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified only if a filename is
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specified in the string being parsed.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0 &nbsp; &nbsp;if filename field in FCB will be
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified regardless; if no filename is
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; present in the parsed string, FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename is set to ASCII blanks.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bit 1 &nbsp; &nbsp; &nbsp; &nbsp;= 1 &nbsp; &nbsp;if drive ID byte in FCB will be
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified only if a drive was specified
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in the string being parsed.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0 &nbsp; &nbsp;if the drive ID byte in FCB will be
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified regardless; if no drive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specifier is present in the parsed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string, FCB drive-code field is set to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (default).
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bit 0 &nbsp; &nbsp; &nbsp; &nbsp;= 1 &nbsp; &nbsp;if leading separators will be scanned
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off (ignored).
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0 &nbsp; &nbsp;if leading separators will not be
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanned off.
<br>
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of string
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of file control block
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H if no wildcard characters encountered
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H if parsed string contained wildcard characters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH if drive specifier invalid
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of first character after parsed filename
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of formatted unopened file control block
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function regards the following as separator characters:
<br>
<br>
&nbsp;[1] &nbsp; &nbsp; &nbsp; &nbsp;: . ; , &nbsp; &nbsp; &nbsp;= + tab space / &quot; [ ]
<br>
&nbsp;[2.0+] &nbsp; &nbsp; : . ; , &nbsp; &nbsp; &nbsp;= + tab space
<br>
<br>
&nbsp;■ This function regards all control characters and the following as
<br>
&nbsp; &nbsp;terminator characters:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : . ; , &nbsp; &nbsp; &nbsp;= + tab space &lt; &gt; | / &quot; [ ]
<br>
<br>
&nbsp;■ If no valid filename is present in the string to be parsed, upon return
<br>
&nbsp; &nbsp;ES:DI + 1 points to an ASCII blank.
<br>
<br>
&nbsp;■ If the * wildcard character occurs in a filename or extension, it and
<br>
&nbsp; &nbsp;all remaining characters in the corresponding field in the FCB are set
<br>
&nbsp; &nbsp;to ?.
<br>
<br>
&nbsp;■ This function (and file control blocks in general) cannot be used with
<br>
&nbsp; &nbsp;file specifications that include a path.
<br>
<br>
Example:
<br>
<br>
&nbsp;Parse the string fname into the file control block myfcb.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'D:QUACK.DAT',0 ; filename to be parsed
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;37 dup (0) &nbsp; &nbsp; &nbsp;; becomes file control block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,29h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,01h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; skip leading separators
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,seg fname &nbsp; &nbsp;; address of filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,0ffh &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, drive invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 2AH (42)
<br>
Get date
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the system day of the month, day of the week, month, and year.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 2AH
<br>
<br>
Returns:
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= year (1980 through 2099)
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= month (1 through 12)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= day (1 through 31)
<br>
<br>
&nbsp;Under MS-DOS versions 1.1 and later
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= day of the week (0 = Sunday, 1 = Monday, etc.)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function's register format is the same as that required for Int 21H
<br>
&nbsp; &nbsp;Function 2BH (Set Date).
<br>
<br>
&nbsp;■ This function can be used together with Int 21H Function 2BH to find
<br>
&nbsp; &nbsp;the day of the week for an arbitrary date. The current date is first
<br>
&nbsp; &nbsp;obtained with Function 2AH and saved. The date of interest is then set
<br>
&nbsp; &nbsp;with Function 2BH, and the day of the week for that date is obtained
<br>
&nbsp; &nbsp;with a subsequent call to Function 2AH. Finally, the current date is
<br>
&nbsp; &nbsp;restored with an additional call to Function 2BH, using the values
<br>
&nbsp; &nbsp;obtained with the original Function 2AH call.
<br>
<br>
Example:
<br>
<br>
&nbsp;Obtain the current date and save its components in the variables year,
<br>
&nbsp;day, and month.
<br>
<br>
&nbsp;year &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0
<br>
&nbsp;month &nbsp; db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp;day &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,2ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; year,cx &nbsp; &nbsp; &nbsp; &nbsp; ; save year (word)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; month,dh &nbsp; &nbsp; &nbsp; &nbsp;; save month (byte)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; day,dl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save day (byte)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 2BH (43)
<br>
Set date
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes the system clock driver to a specific date. The system time is
<br>
&nbsp;not affected.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 2BH
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= year (1980 through 2099)
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= month (1 through 12)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= day (1 through 31)
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if date set successfully
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; if date not valid (ignored)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function's register format is the same as that required for Int 21H
<br>
&nbsp; &nbsp;Function 2AH (Get Date).
<br>
<br>
Example:
<br>
<br>
&nbsp;Set the system date according to the contents of the variables year, day,
<br>
&nbsp;and month.
<br>
<br>
&nbsp;year &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0
<br>
&nbsp;month &nbsp; db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp;day &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,2bh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,year &nbsp; &nbsp; &nbsp; &nbsp; ; get year (word)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dh,month &nbsp; &nbsp; &nbsp; &nbsp;; get month (byte)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,day &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get day (byte)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if date invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 2CH (44)
<br>
Get time
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the time of day from the system real-time clock driver, converted
<br>
&nbsp;to hours, minutes, seconds, and hundredths of seconds.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 2CH
<br>
<br>
Returns:
<br>
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hours (0 through 23)
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= minutes (0 through 59)
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= seconds (0 through 59)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hundredths of seconds (0 through 99)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function's register format is the same as that required for Int 21H
<br>
&nbsp; &nbsp;Function 2DH (Set Time).
<br>
<br>
&nbsp;■ On most IBM PC─compatible systems, the real-time clock does not have a
<br>
&nbsp; &nbsp;resolution of single hundredths of seconds. On such machines, the values
<br>
&nbsp; &nbsp;returned by this function in register DL are discontinuous.
<br>
<br>
Example:
<br>
<br>
&nbsp;Obtain the current time and save its two major components in the variables
<br>
&nbsp;hours and minutes.
<br>
<br>
&nbsp;hours &nbsp; db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp;minutes db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,2ch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; hours,ch &nbsp; &nbsp; &nbsp; &nbsp;; save hours (byte)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; minutes,cl &nbsp; &nbsp; &nbsp;; save minutes (byte)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 2DH (45)
<br>
Set time
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes the system real-time clock to a specified hour, minute,
<br>
&nbsp;second, and hundredth of second. The system date is not affected.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 2DH
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hours (0 through 23)
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= minutes (0 through 59)
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= seconds (0 through 59)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hundredths of seconds (0 through 99)
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if time set successfully
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; if time not valid (ignored)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function's register format is the same as that required for Int 21H
<br>
&nbsp; &nbsp;Function 2CH (Get Time).
<br>
<br>
Example:
<br>
<br>
&nbsp;Set the system time according to the contents of the variables hours and
<br>
&nbsp;minutes. Force the current seconds and hundredths of seconds to zero.
<br>
<br>
&nbsp;hours &nbsp; db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp;minutes db &nbsp; &nbsp; &nbsp;0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,2dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ch,hours &nbsp; &nbsp; &nbsp; &nbsp;; get hours (byte)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cl,minutes &nbsp; &nbsp; &nbsp;; get minutes (byte)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; force seconds and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; hundredths to zero
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if time invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Function 2EH (46)
<br>
Set verify flag
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Turns off or turns on the operating-system flag for automatic
<br>
&nbsp;read-after-write verification of data.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 2EH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if turning off verify flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if turning on verify flag
<br>
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H (MS-DOS versions 1 and 2)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Because read-after-write verification slows disk operations, the default
<br>
&nbsp; &nbsp;setting of the verify flag is OFF.
<br>
<br>
&nbsp;■ If a particular disk unit's device driver does not support
<br>
&nbsp; &nbsp;read-after-write verification, this function has no effect.
<br>
<br>
&nbsp;■ The current state of the verify flag can be determined using Int 21H
<br>
&nbsp; &nbsp;Function 54H.
<br>
<br>
&nbsp;■ The state of the verify flag is also controlled by the MS-DOS commands
<br>
&nbsp; &nbsp;VERIFY OFF and VERIFY ON.
<br>
<br>
Example:
<br>
<br>
&nbsp;Save the current state of the system verify flag in the variable vflag,
<br>
&nbsp;then force all subsequent disk writes to be verified.
<br>
<br>
&nbsp;vflag &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; previous verify flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get verify flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,54h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; vflag,al &nbsp; &nbsp; &nbsp; &nbsp;; save current flag state
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set verify flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,2eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AL = 1 for verify on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; DL must be zero
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 2FH (47)
<br>
Get DTA address
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the current address of the disk transfer area (DTA) for FCB file
<br>
&nbsp;read/write operations.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 2FH
<br>
<br>
Returns:
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of disk transfer area
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The disk transfer area address is set with Int 21H Function 1AH. The
<br>
&nbsp; &nbsp;default DTA is a 128-byte buffer at offset 80H in the program segment
<br>
&nbsp; &nbsp;prefix.
<br>
<br>
Example:
<br>
<br>
&nbsp;Obtain the current disk transfer area address and save it in the variable
<br>
&nbsp;olddta.
<br>
<br>
&nbsp;olddta &nbsp;dd &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save disk transfer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,2fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save it as DWORD pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr olddta,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr olddta+2,es
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 30H (48)
<br>
Get MS-DOS version number
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the version number of the host MS-DOS operating system. This
<br>
&nbsp;function is used by application programs to determine the capabilities of
<br>
&nbsp;their environment.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 30H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If running under MS-DOS version 1
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If running under MS-DOS versions 2.0 or later
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= major version number (MS-DOS 3.10 = 3, etc.)
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= minor version number (MS-DOS 3.10 = 0AH, etc.)
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= Original Equipment Manufacturer's (OEM's) serial number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(OEM-dependent──usually 00H for IBM's PC-DOS, 0FFH or
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;other values for MS-DOS)
<br>
&nbsp;BL:CX &nbsp; &nbsp; &nbsp; &nbsp; = 24-bit user serial number (optional, OEM-dependent)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Because this function was not defined under MS-DOS version 1, it should
<br>
&nbsp; &nbsp;always be called with AL = 00H. In an MS-DOS version 1 environment, AL
<br>
&nbsp; &nbsp;will be returned unchanged.
<br>
<br>
&nbsp;■ Care must be taken not to exit in an unacceptable fashion if an MS-DOS
<br>
&nbsp; &nbsp;version 1 environment is detected. For example, Int 21H Function 4CH
<br>
&nbsp; &nbsp;(Terminate Process with Return Code), Int 21H Function 40H (Write to
<br>
&nbsp; &nbsp;File or Device), and the standard error handle are not available in
<br>
&nbsp; &nbsp;MS-DOS version 1. In such cases a program should display an error
<br>
&nbsp; &nbsp;message using Int 21H Function 09H and then terminate with Int 20H or
<br>
&nbsp; &nbsp;Int 21H Function 00H.
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the MS-DOS version number, terminating the current process with an
<br>
&nbsp;error message if not running under MS-DOS version 2.0 or later.
<br>
<br>
&nbsp;cr &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII carriage return
<br>
&nbsp;lf &nbsp; &nbsp; &nbsp;equ &nbsp; &nbsp; 0ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCII line feed
<br>
<br>
&nbsp;msg &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;cr,lf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'Wrong MS-DOS version'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;cr,lf,'$'
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,3000h &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; version 2 or later?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jae &nbsp; &nbsp; label1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; yes, jump
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; display error message
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,09 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset msg &nbsp; ; message address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; terminate process
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp;label1: .
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 31H (49)
<br>
Terminate and stay resident
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Terminates execution of the currently executing program, passing a return
<br>
&nbsp;code to the parent process, but reserves part or all of the program's
<br>
&nbsp;memory so that it will not be overlaid by the next transient program to be
<br>
&nbsp;loaded. MS-DOS then takes the following actions:
<br>
<br>
&nbsp;■ File buffers are flushed and any open handles for files or devices owned
<br>
&nbsp; &nbsp;by the process are closed.
<br>
<br>
&nbsp;■ The termination handler vector (Int 22H) is restored from PSP:000AH.
<br>
<br>
&nbsp;■ The Ctrl-C handler vector (Int 23H) is restored from PSP:000EH.
<br>
<br>
&nbsp;■ [2.0+] The critical-error handler vector (Int 24H) is restored from
<br>
&nbsp; &nbsp;PSP:0012H.
<br>
<br>
&nbsp;■ Control is transferred to the termination handler.
<br>
<br>
&nbsp;If the program is returning to COMMAND.COM, control transfers to the
<br>
&nbsp;resident portion, and the transient portion is reloaded if necessary. If a
<br>
&nbsp;batch file is in progress, the next line of the file is fetched and
<br>
&nbsp;interpreted; otherwise, a prompt is issued for the next user command.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 31H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= return code
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= amount of memory to reserve (in paragraphs)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function call is typically used to allow user-written utilities,
<br>
&nbsp; &nbsp;drivers, or interrupt handlers to be loaded as ordinary .COM or .EXE
<br>
&nbsp; &nbsp;programs and then remain resident. Subsequent entrance to the code is
<br>
&nbsp; &nbsp;via a hardware or software interrupt.
<br>
<br>
&nbsp;■ This function attempts to set the initial memory allocation block to the
<br>
&nbsp; &nbsp;length in paragraphs specified in register DX. If other memory blocks
<br>
&nbsp; &nbsp;have been requested by the application using Int 21H Function 48H, they
<br>
&nbsp; &nbsp;will not be released by this function.
<br>
<br>
&nbsp;■ Other methods of performing a final exit are:
<br>
<br>
&nbsp; &nbsp;∙ Int 20H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 00H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 4CH
<br>
<br>
&nbsp; &nbsp;∙ Int 27H
<br>
<br>
&nbsp;■ The return code may be retrieved by a parent process with Int 21H
<br>
&nbsp; &nbsp;Function 4DH (Get Return Code). It can also be tested in a batch file
<br>
&nbsp; &nbsp;with an IF ERRORLEVEL statement. By convention, a return code of zero
<br>
&nbsp; &nbsp;indicates successful execution, and a nonzero return code indicates an
<br>
&nbsp; &nbsp;error.
<br>
<br>
&nbsp;■ This function should not be called by .EXE programs that are loaded at
<br>
&nbsp; &nbsp;the high end of the transient program area (that is, linked with the
<br>
&nbsp; &nbsp;/HIGH switch) because doing so reserves the memory that is normally used
<br>
&nbsp; &nbsp;by the transient part of COMMAND.COM. If COMMAND.COM cannot be reloaded,
<br>
&nbsp; &nbsp;the system will fail.
<br>
<br>
&nbsp;■ [2.0+] This function should be used in preference to Int 27H because it
<br>
&nbsp; &nbsp;supports return codes, allows larger amounts of memory to be reserved,
<br>
&nbsp; &nbsp;and does not require CS to contain the segment of the program segment
<br>
&nbsp; &nbsp;prefix.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, it should remove all
<br>
&nbsp; &nbsp;locks it has placed on file regions before terminating.
<br>
<br>
Example:
<br>
<br>
&nbsp;Exit with a return code of 1 but stay resident, reserving 16 KB of memory
<br>
&nbsp;starting at the program segment prefix of the process.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,31h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code for parent
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,0400h &nbsp; &nbsp; &nbsp; &nbsp;; paragraphs to reserve
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 32H (50)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 33H (51)
<br>
Get or set break flag, get boot drive
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains or changes the status of the operating system's break flag, which
<br>
&nbsp;influences Ctrl-C checking during function calls. Also returns the system
<br>
&nbsp;boot drive in version 4.0.
<br>
<br>
Call with:
<br>
<br>
&nbsp;If getting break flag
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 33H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If setting break flag
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 33H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if turning break flag OFF
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if turning break flag ON
<br>
<br>
&nbsp;[4] If getting boot drive
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 33H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If called with AL = 00H or 01H
<br>
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; break flag is OFF
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; break flag is ON
<br>
<br>
&nbsp;[4] If called with AL = 05H
<br>
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= boot drive (1 = A, 2 = B, etc.)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ When the system break flag is on, the keyboard is examined for a Ctrl-C
<br>
&nbsp; &nbsp;entry whenever any operating-system input or output is requested; if
<br>
&nbsp; &nbsp;Ctrl-C is detected, control is transferred to the Ctrl-C handler (Int
<br>
&nbsp; &nbsp;23H). When the break flag is off, MS-DOS only checks for a Ctrl-C entry
<br>
&nbsp; &nbsp;when executing the traditional character I/O functions (Int 21H
<br>
&nbsp; &nbsp;Functions 01H through 0CH).
<br>
<br>
&nbsp;■ The break flag is not part of the local environment of the currently
<br>
&nbsp; &nbsp;executing program; it affects all programs. An application that alters
<br>
&nbsp; &nbsp;the flag should first save the flag's original status, then restore the
<br>
&nbsp; &nbsp;flag before terminating.
<br>
<br>
Example:
<br>
<br>
&nbsp;Save the current state of the system break flag in the variable brkflag,
<br>
&nbsp;then turn the break flag off to disable Ctrl-C checking during most MS-DOS
<br>
&nbsp;function calls.
<br>
<br>
&nbsp;brkflag db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save break flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get current break flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,33h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AL = 0 to get flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; brkflag,dl &nbsp; &nbsp; &nbsp;; save current flag
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now set break flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,33h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AL = 1 to set flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set break flag OFF
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 34H (52)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 35H (53)
<br>
Get interrupt vector
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the address of the current interrupt-handler routine for the
<br>
&nbsp;specified machine interrupt.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 35H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= interrupt number
<br>
<br>
Returns:
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of interrupt handler
<br>
<br>
Note:
<br>
<br>
&nbsp;■ Together with Int 21H Function 25H (Set Interrupt Vector), this
<br>
&nbsp; &nbsp;function is used by well-behaved application programs to modify or
<br>
&nbsp; &nbsp;inspect the machine interrupt vector table.
<br>
<br>
Example:
<br>
<br>
&nbsp;Obtain the address of the current interrupt handler for hardware interrupt
<br>
&nbsp;level 0 (divide by zero) and save it in the variable oldint0.
<br>
<br>
&nbsp;oldint0 dd &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; previous handler address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,35h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; interrupt level
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save old handler address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr oldint0,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr oldint0+2,es
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 36H (54)
<br>
Get drive allocation information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains selected information about a disk drive, from which the drive's
<br>
&nbsp;capacity and remaining free space can be calculated.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 36H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive code (0 = default, 1 = A, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sectors per cluster
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of available clusters
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= bytes per sector
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= clusters per drive
<br>
<br>
&nbsp;If function unsuccessful (drive invalid)
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFFFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function regards &quot;lost&quot; clusters as being in use and does not
<br>
&nbsp; &nbsp;report them as part of the number of available clusters, even though
<br>
&nbsp; &nbsp;they are not assigned to a file.
<br>
<br>
&nbsp;■ Similar information is returned by Int 21H Functions 1BH and 1CH.
<br>
<br>
Example:
<br>
<br>
&nbsp;Calculate the capacity of disk drive C in bytes, leaving the result in the
<br>
&nbsp;variable drvsize. (This code assumes that the product of sectors/cluster *
<br>
&nbsp;bytes/sector will not overflow 16 bits.)
<br>
<br>
&nbsp;drvsize dd &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive C size in bytes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,36h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive C = 3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mul &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; sectors/cluster
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; * bytes/sector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mul &nbsp; &nbsp; dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; * total clusters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; result now in DX:AX
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; store low word
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr drvsize,ax
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; store high word
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; word ptr drvsize+2,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 37H (55)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 38H (56)
<br>
Get or set country information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;[2] Obtains internationalization information for the current country.
<br>
<br>
&nbsp;[3.0+] Obtains internationalization information for the current or
<br>
&nbsp;specified country or sets the current country code.
<br>
<br>
Call with:
<br>
<br>
&nbsp;If getting country information (MS-DOS version 2)
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 38H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0 &nbsp; &nbsp; &nbsp; &nbsp; to get &quot;current&quot; country information
<br>
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer for returned information
<br>
<br>
&nbsp;If getting country information (MS-DOS versions 3.0 and later)
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 38H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0 &nbsp; &nbsp; &nbsp; &nbsp; to get &quot;current&quot; country information
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1─FEH &nbsp; &nbsp; to get information for countries with code &lt; 255
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; to get information for countries with code &gt;=
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;255
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= country code, if AL = FFH
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer for returned information
<br>
<br>
&nbsp;If setting current country code (MS-DOS versions 3.0 and later)
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 38H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1─FEH &nbsp; &nbsp; country code for countries with code &lt; 255
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; for countries with code &gt;= 255
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= country code, if AL = 0FFH
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFFFH
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if getting internationalization information
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= country code
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer holding internationalization
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;information
<br>
<br>
&nbsp;and buffer filled in as follows:
<br>
<br>
&nbsp;(for PC-DOS 2.0 and 2.1)
<br>
<br>
&nbsp;Byte(s) &nbsp; &nbsp;Contents
<br>
&nbsp;00H─01H &nbsp; &nbsp;date format
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 = USA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m d y
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 = Europe &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d m y
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 = Japan &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y m d
<br>
<br>
&nbsp;02H─03H &nbsp; &nbsp;ASCIIZ currency symbol
<br>
&nbsp;04H─05H &nbsp; &nbsp;ASCIIZ thousands separator
<br>
&nbsp;06H─07H &nbsp; &nbsp;ASCIIZ decimal separator
<br>
&nbsp;08H─1FH &nbsp; &nbsp;reserved
<br>
<br>
&nbsp;(for MS-DOS versions 2.0 and later, PC-DOS versions 3.0 and later)
<br>
<br>
&nbsp;Byte(s) &nbsp; &nbsp;Contents
<br>
&nbsp;00H─01H &nbsp; &nbsp;date format
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 = USA &nbsp; m d y
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 = &nbsp; &nbsp; &nbsp; d m y
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Europe
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 = Japan y m d
<br>
<br>
&nbsp;02H─06H &nbsp; &nbsp;ASCIIZ currency symbol string
<br>
&nbsp;07H─08H &nbsp; &nbsp;ASCIIZ thousands separator character
<br>
&nbsp;09H─0AH &nbsp; &nbsp;ASCIIZ decimal separator character
<br>
&nbsp;0BH─0CH &nbsp; &nbsp;ASCIIZ date separator character
<br>
&nbsp;0DH─0EH &nbsp; &nbsp;ASCIIZ time separator character
<br>
&nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp;currency format
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0 if currency symbol precedes value
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if currency symbol follows value
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0 if no space between value and currency
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;symbol
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if one space between value and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;currency symbol
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0 if currency symbol and decimal are
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;separate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if currency symbol replaces decimal
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;separator
<br>
<br>
&nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp;number of digits after decimal in currency
<br>
&nbsp;11H &nbsp; &nbsp; &nbsp; &nbsp;time format
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0 if 12-hour clock
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if 24-hour clock
<br>
<br>
&nbsp;12H─15H &nbsp; &nbsp;case-map call address
<br>
&nbsp;16H─17H &nbsp; &nbsp;ASCIIZ data-list separator
<br>
&nbsp;18H─21H &nbsp; &nbsp;reserved
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The default country code is determined by the COUNTRY= directive in
<br>
&nbsp; &nbsp;CONFIG.SYS or by the KEYBxx keyboard driver file if one is loaded.
<br>
&nbsp; &nbsp;Otherwise, the default country code is OEM-dependent.
<br>
<br>
&nbsp;■ The previous contents of register CX may be destroyed by the Get Country
<br>
&nbsp; &nbsp;Information subfunction.
<br>
<br>
&nbsp;■ The case-map call address is the segment:offset of a FAR procedure that
<br>
&nbsp; &nbsp;performs country-specific mapping on character values from 80H through
<br>
&nbsp; &nbsp;0FFH. The procedure must be called with the character to be mapped in
<br>
&nbsp; &nbsp;register AL. If an alternate value exists for that character, it is
<br>
&nbsp; &nbsp;returned in AL; otherwise, AL is unchanged. In general, lowercase
<br>
&nbsp; &nbsp;characters are mapped to their uppercase equivalents, and accented or
<br>
&nbsp; &nbsp;otherwise modified vowels are mapped to their plain vowel equivalents.
<br>
<br>
&nbsp;■ [3.0+] The value in register DX is used by MS-DOS to select between the
<br>
&nbsp; &nbsp;Set Country and Get Country Information subfunctions.
<br>
<br>
&nbsp;■ [3.3+] Int 21H Function 65H (Get Extended Country Information) returns
<br>
&nbsp; &nbsp;a superset of the information supplied by this function.
<br>
<br>
Examples:
<br>
<br>
&nbsp;Obtain internationalization information for the current country in the
<br>
&nbsp;buffer ctrybuf.
<br>
<br>
&nbsp;ctrybuf db &nbsp; &nbsp; &nbsp;34 dup (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,38h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get current country
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg ctrybuf &nbsp;; address of buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; for country information
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset ctrybuf
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;If the program is running under PC-DOS 3.3 and the current country code is
<br>
&nbsp;49 (West Germany), ctrybuf is filled in with the following information:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0001h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; date format
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DM',0,0,0 &nbsp; &nbsp; &nbsp;; ASCIIZ currency symbol
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'.',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCIIZ thousands separator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;',',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCIIZ decimal separator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'.',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCIIZ date separator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'.',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCIIZ time separator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;02h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; currency format
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;02h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; digits after decimal
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;01h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; time format
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;026ah:176ch &nbsp; &nbsp; ; case-map call address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;';',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ASCIIZ data-list separator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;10 dup (0) &nbsp; &nbsp; &nbsp;; reserved
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 39H (57)
<br>
Create directory
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Creates a directory using the specified drive and path.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 39H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The function fails if:
<br>
<br>
&nbsp; &nbsp;∙ any element of the pathname does not exist.
<br>
<br>
&nbsp; &nbsp;∙ a directory with the same name at the end of the same path already
<br>
&nbsp; &nbsp; &nbsp;exists.
<br>
<br>
&nbsp; &nbsp;∙ the parent directory for the new directory is the root directory and
<br>
&nbsp; &nbsp; &nbsp;is full.
<br>
<br>
&nbsp; &nbsp;∙ [3.0+] the program is running on a network and the user running the
<br>
&nbsp; &nbsp; &nbsp;program has insufficient access rights.
<br>
<br>
Example:
<br>
<br>
&nbsp;Create a directory named MYSUB in the root directory on drive C.
<br>
<br>
&nbsp;dname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\MYSUB',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,39h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg dname &nbsp; &nbsp;; address of pathname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset dname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if create failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 3AH (58)
<br>
Delete directory
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Removes a directory using the specified drive and path.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 3AH
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The function fails if:
<br>
<br>
&nbsp; &nbsp;∙ any element of the pathname does not exist.
<br>
<br>
&nbsp; &nbsp;∙ the specified directory is also the current directory.
<br>
<br>
&nbsp; &nbsp;∙ the specified directory contains any files.
<br>
<br>
&nbsp; &nbsp;∙ [3.0+] the program is running on a network and the user running the
<br>
&nbsp; &nbsp; &nbsp;program has insufficient access rights.
<br>
<br>
Example:
<br>
<br>
&nbsp;Remove the directory named MYSUB in the root directory on drive C.
<br>
<br>
&nbsp;dname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\MYSUB',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg dname &nbsp; &nbsp;; address of pathname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset dname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if delete failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 3BH (59)
<br>
Set current directory
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the current, or default, directory using the specified drive and
<br>
&nbsp;path.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 3BH
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The function fails if any element of the pathname does not exist.
<br>
<br>
&nbsp;■ Int 21H Function 47H can be used to obtain the name of the current
<br>
&nbsp; &nbsp;directory before using Int 21H Function 3BH to select another, so that
<br>
&nbsp; &nbsp;the original directory can be restored later.
<br>
<br>
Example:
<br>
<br>
&nbsp;Change the current directory for drive C to the directory \MYSUB.
<br>
<br>
&nbsp;dname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\MYSUB',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3bh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg dname &nbsp; &nbsp;; address of pathname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset dname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if bad path
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 3CH (60)
<br>
Create file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given an ASCIIZ pathname, creates a new file in the designated or default
<br>
&nbsp;directory on the designated or default disk drive. If the specified file
<br>
&nbsp;already exists, it is truncated to zero length. In either case, the file
<br>
&nbsp;is opened and a handle is returned that can be used by the program for
<br>
&nbsp;subsequent access to the file.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 3CH
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= file attribute (bits may be combined)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; read-only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; hidden
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; system
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; volume label
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; archive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
<br>
&nbsp;If function failed
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The function fails if:
<br>
<br>
&nbsp; &nbsp;∙ any element of the pathname does not exist.
<br>
<br>
&nbsp; &nbsp;∙ the file is being created in the root directory and the root directory
<br>
&nbsp; &nbsp; &nbsp;is full.
<br>
<br>
&nbsp; &nbsp;∙ a file with the same name and the read-only attribute already exists
<br>
&nbsp; &nbsp; &nbsp;in the specified directory.
<br>
<br>
&nbsp; &nbsp;∙ [3.0+] the program is running on a network and the user running the
<br>
&nbsp; &nbsp; &nbsp;program has insufficient access rights.
<br>
<br>
&nbsp;■ A file is usually given a normal (0) attribute when it is created. The
<br>
&nbsp; &nbsp;file's attribute can subsequently be modified with Int 21H Function
<br>
&nbsp; &nbsp;43H.
<br>
<br>
&nbsp;■ [3.0+] A volume label can be created using an attribute of 0008H, if one
<br>
&nbsp; &nbsp;does not already exist. When files are created, bit 3 of the attribute
<br>
&nbsp; &nbsp;parameter should always be clear (0).
<br>
<br>
&nbsp;■ [3.0+] See the entries for Int 21H Functions 5AH and 5BH, which may
<br>
&nbsp; &nbsp;also be used to create files.
<br>
<br>
&nbsp;■ [4.0+] Int 21H Function 6CH combines the services of Functions 3CH,
<br>
&nbsp; &nbsp;3DH, and 5BH.
<br>
<br>
Example:
<br>
<br>
&nbsp;Create and open, or truncate to zero length and open, the file
<br>
&nbsp;C:\MYDIR\MYFILE.DAT, and save the handle for subsequent access to the
<br>
&nbsp;file.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\MYDIR\MYFILE.DAT',0
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3ch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; cx,cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; normal attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg fname &nbsp; &nbsp;; address of pathname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if create failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; fhandle,ax &nbsp; &nbsp; &nbsp;; save file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 3DH (61)
<br>
Open file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given an ASCIIZ pathname, opens the specified file in the designated or
<br>
&nbsp;default directory on the designated or default disk drive. A handle is
<br>
&nbsp;returned which can be used by the program for subsequent access to the
<br>
&nbsp;file.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 3DH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= access mode
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─2 &nbsp; &nbsp; &nbsp; access mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;000 = read access
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;001 = write access
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;010 = read/write access
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4─6 &nbsp; &nbsp; &nbsp; sharing mode (MS-DOS versions 3.0 and later)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;000 = compatibility mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;001 = deny all
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;010 = deny write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;011 = deny read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;100 = deny none
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; inheritance flag (MS-DOS versions 3.0 and later)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = child process inherits handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = child does not inherit handle
<br>
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Any normal, system, or hidden file with a matching name will be opened
<br>
&nbsp; &nbsp;by this function. If the file is read-only, the success of the operation
<br>
&nbsp; &nbsp;also depends on the access code in bits 0─2 of register AL. After
<br>
&nbsp; &nbsp;opening the file, the file read/write pointer is set to offset zero (the
<br>
&nbsp; &nbsp;first byte of the file).
<br>
<br>
&nbsp;■ The function fails if:
<br>
<br>
&nbsp; &nbsp;∙ any element of the pathname does not exist.
<br>
<br>
&nbsp; &nbsp;∙ the file is opened with an access mode of read/write and the file has
<br>
&nbsp; &nbsp; &nbsp;the read-only attribute.
<br>
<br>
&nbsp; &nbsp;∙ [3.0+] SHARE.EXE is loaded and the file has already been opened by one
<br>
&nbsp; &nbsp; &nbsp;or more other processes in a sharing mode that is incompatible with
<br>
&nbsp; &nbsp; &nbsp;the current program's request.
<br>
<br>
&nbsp;■ The file's date and time stamp can be accessed after a successful open
<br>
&nbsp; &nbsp;call with Int 21H Function 57H.
<br>
<br>
&nbsp;■ The file's attributes (hidden, system, read-only, or archive) can be
<br>
&nbsp; &nbsp;obtained with Int 21H Function 43H.
<br>
<br>
&nbsp;■ When a file handle is inherited by a child process or is duplicated with
<br>
&nbsp; &nbsp;Int 21H Function 45H or 46H, all sharing and access restrictions are
<br>
&nbsp; &nbsp;also inherited.
<br>
<br>
&nbsp;■ [2] Only bits 0─2 of register AL are significant; the remaining bits
<br>
&nbsp; &nbsp;should be zero for upward compatibility.
<br>
<br>
&nbsp;■ [3.0+] Bits 4─7 of register AL control access to the file by other
<br>
&nbsp; &nbsp;programs. (Bits 4─6 have no effect unless SHARE.EXE is loaded.)
<br>
<br>
&nbsp;■ [3.0+] A file-sharing error causes a critical-error exception (Int 24H)
<br>
&nbsp; &nbsp;with an error code of 02H. Int 21H Function 59H can be used to obtain
<br>
&nbsp; &nbsp;information about the sharing violation.
<br>
<br>
&nbsp;■ [4.0+] Int 21H Function 6CH combines the services of Functions 3CH,
<br>
&nbsp; &nbsp;3DH, and 5BH.
<br>
<br>
Example:
<br>
<br>
&nbsp;Open the file C:\MYDIR\MYFILE.DAT for both reading and writing, and save
<br>
&nbsp;the handle for subsequent access to the file.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\MYDIR\MYFILE.DAT',0
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; mode = read/write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg fname &nbsp; &nbsp;; address of pathname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if open failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; fhandle,ax &nbsp; &nbsp; &nbsp;; save file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 3EH (62)
<br>
Close file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given a handle that was obtained by a previous successful open or create
<br>
&nbsp;operation, flushes all internal buffers associated with the file to disk,
<br>
&nbsp;closes the file, and releases the handle for reuse. If the file was
<br>
&nbsp;modified, the time and date stamp and file size are updated in the file's
<br>
&nbsp;directory entry.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 3EH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ If you accidentally call this function with a zero handle, the standard
<br>
&nbsp; &nbsp;input device is closed, and the keyboard appears to go dead. Make sure
<br>
&nbsp; &nbsp;you always call the close function with a valid, nonzero handle.
<br>
<br>
Example:
<br>
<br>
&nbsp;Close the file whose handle is saved in the variable fhandle.
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,fhandle &nbsp; &nbsp; &nbsp;; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if close failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 3FH (63)
<br>
Read file or device
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given a valid file handle from a previous open or create operation, a
<br>
&nbsp;buffer address, and a length in bytes, transfers data at the current
<br>
&nbsp;file-pointer position from the file into the buffer and then updates the
<br>
&nbsp;file pointer position.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 3FH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of bytes to read
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= bytes transferred
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If reading from a character device (such as the standard input) in
<br>
&nbsp; &nbsp;cooked mode, at most one line of input will be read (i.e., up to a
<br>
&nbsp; &nbsp;carriage return character or the specified length, whichever comes
<br>
&nbsp; &nbsp;first).
<br>
<br>
&nbsp;■ If the carry flag is returned clear but AX = 0, then the file pointer
<br>
&nbsp; &nbsp;was already at end of file when the program requested the read.
<br>
<br>
&nbsp;■ If the carry flag is returned clear but AX &lt; CX, then a partial record
<br>
&nbsp; &nbsp;was read at end of file or there is an error.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Read
<br>
&nbsp; &nbsp;access rights to the directory and file.
<br>
<br>
Example:
<br>
<br>
&nbsp;Using the file handle from a previous open or create operation, read 1024
<br>
&nbsp;bytes at the current file pointer into the buffer named buff.
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;1024 dup (?) &nbsp; &nbsp;; buffer for read
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; contains file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,fhandle &nbsp; &nbsp; &nbsp;; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,1024 &nbsp; &nbsp; &nbsp; &nbsp; ; length to read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, read failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check length of read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jl &nbsp; &nbsp; &nbsp;done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump, end of file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 40H (64)
<br>
Write file or device
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given a valid file handle from a previous open or create operation, a
<br>
&nbsp;buffer address, and a length in bytes, transfers data from the buffer into
<br>
&nbsp;the file and then updates the file pointer position.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 40H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of bytes to write
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= bytes transferred
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the carry flag is returned clear but AX &lt; CX, then a partial record
<br>
&nbsp; &nbsp;was written or there is an error. This can be caused by a Ctrl-Z (1AH)
<br>
&nbsp; &nbsp;embedded in the data if the destination is a character device in cooked
<br>
&nbsp; &nbsp;mode or by a disk full condition if the destination is a file.
<br>
<br>
&nbsp;■ If the function is called with CX = 0, the file is truncated or extended
<br>
&nbsp; &nbsp;to the current file pointer position.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Write
<br>
&nbsp; &nbsp;access rights to the directory and file.
<br>
<br>
Example:
<br>
<br>
&nbsp;Using the handle from a previous open or create operation, write 1024
<br>
&nbsp;bytes to disk at the current file pointer from the buffer named buff.
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;1024 dup (?) &nbsp; &nbsp;; buffer for write
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; contains file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,40h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,fhandle &nbsp; &nbsp; &nbsp;; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,1024 &nbsp; &nbsp; &nbsp; &nbsp; ; length to write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, write failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; ax,1024 &nbsp; &nbsp; &nbsp; &nbsp; ; entire record written?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jne &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, jump
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 41H (65)
<br>
Delete file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Deletes a file from the specified or default disk and directory.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 41H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function deletes a file by replacing the first character of its
<br>
&nbsp; &nbsp;filename in the directory with the character e (E5H) and marking the
<br>
&nbsp; &nbsp;file's clusters as &quot;free&quot; in the disk's file allocation table. The
<br>
&nbsp; &nbsp;actual data stored in those clusters is not overwritten.
<br>
<br>
&nbsp;■ Only one file at a time may be deleted with this function. Unlike the
<br>
&nbsp; &nbsp;FCB-related Delete File function (Int 21H Function 13H), the * and ?
<br>
&nbsp; &nbsp;wildcard characters are not allowed in the file specification.
<br>
<br>
&nbsp;■ The function fails if:
<br>
<br>
&nbsp; &nbsp;∙ any element of the pathname does not exist.
<br>
<br>
&nbsp; &nbsp;∙ the designated file exists but has the read-only attribute. (Int 21H
<br>
&nbsp; &nbsp; &nbsp;Function 43H can be used to examine and modify a file's attribute
<br>
&nbsp; &nbsp; &nbsp;before attempting to delete it.)
<br>
<br>
&nbsp; &nbsp;∙ [3.0+] the program is running on a network, and the user running the
<br>
&nbsp; &nbsp; &nbsp;program has insufficient access rights.
<br>
<br>
Example:
<br>
<br>
&nbsp;Delete the file named MYFILE.DAT from the directory \MYDIR on drive C.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\MYDIR\MYFILE.DAT',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,41h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg fname &nbsp; &nbsp;; filename address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if delete failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 42H (66)
<br>
Set file pointer
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the file location pointer relative to the start of file, end of file,
<br>
&nbsp;or current file position.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 42H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= method code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H absolute offset from start of file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H signed offset from current file pointer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H signed offset from end of file
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= most significant half of offset
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= least significant half of offset
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= most significant half of resulting file pointer
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= least significant half of resulting file pointer
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function uses a method code and a double-precision (32-bit) value
<br>
&nbsp; &nbsp;to set the file pointer. The next record read or written in the file
<br>
&nbsp; &nbsp;will begin at the new file pointer location. No matter what method is
<br>
&nbsp; &nbsp;used in the call to this function, the file pointer returned in DX:AX is
<br>
&nbsp; &nbsp;always the resulting absolute byte offset from the start of file.
<br>
<br>
&nbsp;■ Method 02H may be used to find the size of the file by calling Int 21H
<br>
&nbsp; &nbsp;Function 42H with an offset of 0 and examining the pointer location
<br>
&nbsp; &nbsp;that is returned.
<br>
<br>
&nbsp;■ Using methods 01H or 02H, it is possible to set the file pointer to a
<br>
&nbsp; &nbsp;location that is before the start of file. If this is done, no error is
<br>
&nbsp; &nbsp;returned by this function, but an error will be encountered upon a
<br>
&nbsp; &nbsp;subsequent attempt to read or write the file.
<br>
<br>
Examples:
<br>
<br>
&nbsp;Using the file handle from a previous open or create operation, set the
<br>
&nbsp;current file pointer position to 1024 bytes after the start of file.
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,42h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; method = absolute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,fhandle &nbsp; &nbsp; &nbsp;; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; upper half of offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,1024 &nbsp; &nbsp; &nbsp; &nbsp; ; lower half of offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;The following subroutine accepts a record number, record size, and handle
<br>
&nbsp;and sets the file pointer appropriately.
<br>
<br>
&nbsp;; call this routine with BX = handle
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AX = record number
<br>
&nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CX = record size
<br>
&nbsp;; returns all registers unchanged
<br>
&nbsp;;
<br>
&nbsp;setptr &nbsp;proc &nbsp; &nbsp;near
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save record number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; &nbsp;dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save whatever's in DX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mul &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; size * record number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; upper part to CX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xchg &nbsp; &nbsp;cx,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; lower part to DX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4200h &nbsp; &nbsp; &nbsp; &nbsp;; function number &amp; method
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore previous DX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore record size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore record number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; back to caller
<br>
&nbsp;setptr &nbsp;endp
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 43H (67)
<br>
Get or set file attributes
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains or alters the attributes of a file (read-only, hidden, system, or
<br>
&nbsp;archive) or directory.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 43H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; to get attributes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; to set attributes
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= file attribute, if AL = 01H (bits can be combined)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; read-only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; hidden
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; system
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3─4 &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; archive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= file attribute
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; read-only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; hidden
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; system
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; volume label
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; directory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; archive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Bits 3 and 4 of register CX must always be clear (0) when this function
<br>
&nbsp; &nbsp;is called; in other words, you cannot change an existing file into a
<br>
&nbsp; &nbsp;directory or volume label. However, you can assign the &quot;hidden&quot;
<br>
&nbsp; &nbsp;attribute to an existing directory with this function.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the user must have Create
<br>
&nbsp; &nbsp;access rights to the directory containing the file whose attribute is to
<br>
&nbsp; &nbsp;be modified.
<br>
<br>
Example:
<br>
<br>
&nbsp;Change the attribute of the file D:\MYDIR\MYFILE.DAT to read-only, so that
<br>
&nbsp;it cannot be accidentally modified or deleted by other application
<br>
&nbsp;programs.
<br>
<br>
&nbsp;rdonly &nbsp;equ &nbsp; &nbsp; 01h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file attributes
<br>
&nbsp;hidden &nbsp;equ &nbsp; &nbsp; 02h
<br>
&nbsp;system &nbsp;equ &nbsp; &nbsp; 04h
<br>
&nbsp;volume &nbsp;equ &nbsp; &nbsp; 08h
<br>
&nbsp;subdir &nbsp;equ &nbsp; &nbsp; 10h
<br>
&nbsp;archive equ &nbsp; &nbsp; 20h
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'D:\MYDIR\MYFILE.DAT',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,43h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,01h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; subfunction = modify
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,rdonly &nbsp; &nbsp; &nbsp; ; read-only attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg fname &nbsp; &nbsp;; filename address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if modify failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 44H (68)
<br>
IOCTL (I/O control)
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Provides a direct path of communication between an application program and
<br>
&nbsp;a device driver. Allows a program to obtain hardware-dependent information
<br>
&nbsp;and to request operations that are not supported by other MS-DOS function
<br>
&nbsp;calls.
<br>
<br>
&nbsp;The IOCTL subfunctions and the MS-DOS versions in which they first became
<br>
&nbsp;available are:
<br>
<br>
<br>
&nbsp;Subfunction &nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS-DOS version
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Device Information &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Device Information &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Receive Control Data from Character &nbsp; &nbsp; &nbsp; 2.0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Device Driver
<br>
&nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Send Control Data to Character Device &nbsp; &nbsp; 2.0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Driver
<br>
&nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Receive Control Data from Block Device &nbsp; &nbsp;2.0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Driver
<br>
&nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Send Control Data to Block Device Driver &nbsp;2.0
<br>
&nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Check Input Status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
&nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Check Output Status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.0
<br>
&nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Check If Block Device Is Removable &nbsp; &nbsp; &nbsp; &nbsp;3.0
<br>
&nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Check If Block Device Is Remote &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.1
<br>
&nbsp;0AH (10) &nbsp; &nbsp; &nbsp; Check If Handle Is Remote &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.1
<br>
&nbsp;0BH (11) &nbsp; &nbsp; &nbsp; Change Sharing Retry Count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.1
<br>
&nbsp;0CH (12) &nbsp; &nbsp; &nbsp; Generic I/O Control for Character Devices
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 45H: Set Iteration Count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 4AH: Select Code Page &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 4CH: Start Code Page Preparation &nbsp; &nbsp; 3.3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 4DH: End Code Page Preparation &nbsp; &nbsp; &nbsp; 3.3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 5FH: Set Display Information &nbsp; &nbsp; &nbsp; &nbsp; 4.0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 65H: Get Iteration Count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 6AH: Query Selected Code Page &nbsp; &nbsp; &nbsp; &nbsp;3.3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 6BH: Query Prepare List &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 7FH: Get Display Information &nbsp; &nbsp; &nbsp; &nbsp; 4.0
<br>
&nbsp;0DH (13) &nbsp; &nbsp; &nbsp; Generic I/O Control for Block Devices
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 40H: Set Device Parameters &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 41H: Write Track &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 42H: Format and Verify Track &nbsp; &nbsp; &nbsp; &nbsp; 3.2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 47H: Set Access Flag &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 60H: Get Device Parameters &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 61H: Read Track &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 62H: Verify Track &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CL = 67H: Get Access Flag &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.0
<br>
&nbsp;0EH (14) &nbsp; &nbsp; &nbsp; Get Logical Drive Map &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.2
<br>
&nbsp;0FH (15) &nbsp; &nbsp; &nbsp; Set Logical Drive Map &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.2
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;Only IOCTL Subfunctions 00H, 06H, and 07H may be used for handles
<br>
&nbsp;associated with files. Subfunctions 00H─08H are not supported on network
<br>
&nbsp;devices.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 44H (68) Subfunction 00H
<br>
IOCTL: get device information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a device information word for the file or device associated with
<br>
&nbsp;the specified handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device information word
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;For a file:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─5 &nbsp; &nbsp; &nbsp; drive number (0 = A, 1 = B, etc.)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; 0 if file has been written
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if file has not been written
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; 0, indicating a file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8─15 &nbsp; &nbsp; &nbsp;reserved
<br>
<br>
&nbsp;For a device:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; 1 if standard input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; 1 if standard output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; 1 if NUL device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; 1 if clock device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; 0 if handle in ASCII mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if handle in binary mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; 0 if end of file on input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; 1, indicating a device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8─13 &nbsp; &nbsp; &nbsp;reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 &nbsp; &nbsp; &nbsp; &nbsp;0 if IOCTL subfunctions 02H and 03H not
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if IOCTL subfunctions 02H and 03H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;15 &nbsp; &nbsp; &nbsp; &nbsp;reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Bits 8─15 of DX correspond to the upper 8 bits of the device-driver
<br>
&nbsp; &nbsp;attribute word.
<br>
<br>
&nbsp;■ Bit 5 of the device information word for a handle associated with a
<br>
&nbsp; &nbsp;character device signifies whether MS-DOS considers that handle to be in
<br>
&nbsp; &nbsp;binary (&quot;raw&quot;) mode or ASCII (&quot;cooked&quot;) mode. In ASCII mode, MS-DOS
<br>
&nbsp; &nbsp;filters the character stream and may take special action when the
<br>
&nbsp; &nbsp;characters Ctrl-C, Ctrl-S, Ctrl-P, Ctrl-Z, and carriage return are
<br>
&nbsp; &nbsp;detected. In binary mode, all characters are treated as data, and the
<br>
&nbsp; &nbsp;exact number of characters requested is always read or written.
<br>
<br>
Example:
<br>
<br>
&nbsp;See Int 21H Function 44H Subfunction 01H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 44H (68) Subfunction 01H
<br>
IOCTL: set device information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets certain flags for a handle associated with a character device. This
<br>
&nbsp;subfunction may not be used for a handle that is associated with a file.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device information word
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; 1 if standard input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; 1 if standard output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; 1 if NUL device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; 1 if clock device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; 0 to select ASCII mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 to select binary mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; 1, indicating a device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If register DH does not contain 00H, control returns to the program with
<br>
&nbsp; &nbsp;the carry flag set and error code 0001H (invalid function) in register
<br>
&nbsp; &nbsp;AX.
<br>
<br>
&nbsp;■ Bit 5 of the information word for a handle associated with a character
<br>
&nbsp; &nbsp;device signifies whether MS-DOS considers that handle to be in binary
<br>
&nbsp; &nbsp;(&quot;raw&quot;) or ASCII (&quot;cooked&quot;) mode. See Notes for Int 21H Function 44H
<br>
&nbsp; &nbsp;Subfunction 00H.
<br>
<br>
Example:
<br>
<br>
&nbsp;Place the standard output handle into binary (&quot;raw&quot;) mode. This speeds up
<br>
&nbsp;output by disabling checking for Ctrl-C, Ctrl-S, and Ctrl-P between each
<br>
&nbsp;character.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get device information
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4400h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dh,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; force DH = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;dl,20h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set binary mode bit
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set device information
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4401h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 44H (68) Subfunction 02H
<br>
IOCTL: read control data from character device driver
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads control data from a character-device driver. The length and contents
<br>
&nbsp;of the data are specific to each device driver and do not follow any
<br>
&nbsp;standard format. This function does not necessarily result in any input
<br>
&nbsp;from the physical device.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of bytes to read
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= bytes read
<br>
<br>
&nbsp;and buffer contains control data from driver
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If supported by the driver, this subfunction can be used to obtain
<br>
&nbsp; &nbsp;hardware-dependent status and availability information that is not
<br>
&nbsp; &nbsp;supported by other MS-DOS function calls.
<br>
<br>
&nbsp;■ Character-device drivers are not required to support IOCTL Subfunction
<br>
&nbsp; &nbsp;02H. A program can test bit 14 of the device information word returned
<br>
&nbsp; &nbsp;by IOCTL Subfunction 00H to determine whether the driver supports this
<br>
&nbsp; &nbsp;subfunction. If Subfunction 02H is requested and the driver does not
<br>
&nbsp; &nbsp;have the ability to process control data, control returns to the program
<br>
&nbsp; &nbsp;with the carry flag set and error code 0001H (invalid function) in
<br>
&nbsp; &nbsp;register AX.
<br>
<br>
Example:
<br>
<br>
&nbsp;Read a control string from the standard list driver into the buffer buff.
<br>
<br>
&nbsp;stdprn &nbsp;equ &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard list handle
<br>
&nbsp;buflen &nbsp;equ &nbsp; &nbsp; 64 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; length of buffer
<br>
<br>
&nbsp;ctllen &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; length of control string
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;buflen dup (0) &nbsp;; receives control string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4402h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdprn &nbsp; &nbsp; &nbsp; ; standard list handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,buflen &nbsp; &nbsp; &nbsp; ; buffer length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if read failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ctllen,ax &nbsp; &nbsp; &nbsp; ; save control string length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 44H (68) Subfunction 03H
<br>
IOCTL: write control data to character-device driver
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Transfers control data from an application to a character-device driver.
<br>
&nbsp;The length and contents of the data are specific to each device driver and
<br>
&nbsp;do not follow any standard format. This function does not necessarily
<br>
&nbsp;result in any output to the physical device.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of bytes to write
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of data
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= bytes transferred
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If supported by the driver, this subfunction can be used to request
<br>
&nbsp; &nbsp;hardware-dependent operations (such as setting baud rate for a serial
<br>
&nbsp; &nbsp;port) that are not supported by other MS-DOS function calls.
<br>
<br>
&nbsp;■ Character-device drivers are not required to support IOCTL Subfunction
<br>
&nbsp; &nbsp;03H. A program can test bit 14 of the device information word returned
<br>
&nbsp; &nbsp;by IOCTL Subfunction 00H to determine whether the driver supports this
<br>
&nbsp; &nbsp;subfunction. If Subfunction 03H is requested and the driver does not
<br>
&nbsp; &nbsp;have the ability to process control data, control returns to the program
<br>
&nbsp; &nbsp;with the carry flag set and error code 0001H (invalid function) in
<br>
&nbsp; &nbsp;register AX.
<br>
<br>
Example:
<br>
<br>
&nbsp;Write a control string from the buffer buff to the standard list device
<br>
&nbsp;driver. The length of the string is assumed to be in the variable ctllen.
<br>
<br>
&nbsp;stdprn &nbsp;equ &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard list handle
<br>
&nbsp;buflen &nbsp;equ &nbsp; &nbsp; 64 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; length of buffer
<br>
<br>
&nbsp;ctllen &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; length of control data
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;buflen dup (?) &nbsp;; contains control data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4403h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdprn &nbsp; &nbsp; &nbsp; ; standard list handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,ctllen &nbsp; &nbsp; &nbsp; ; length of control data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if write failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 44H (68) Subfunction 04H
<br>
IOCTL: read control data from block-device driver
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Transfers control data from a block-device driver directly into an
<br>
&nbsp;application program's buffer. The length and contents of the data are
<br>
&nbsp;specific to each device driver and do not follow any standard format. This
<br>
&nbsp;function does not necessarily result in any input from the physical
<br>
&nbsp;device.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive code (0 = default, 1 = A, 2 = B, etc.)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of bytes to read
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= bytes transferred
<br>
<br>
&nbsp;and buffer contains control data from device driver
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ When supported by the driver, this subfunction can be used to obtain
<br>
&nbsp; &nbsp;hardware-dependent status and availability information that is not
<br>
&nbsp; &nbsp;provided by other MS-DOS function calls.
<br>
<br>
&nbsp;■ Block-device drivers are not required to support IOCTL Subfunction 04H.
<br>
&nbsp; &nbsp;If this subfunction is requested and the driver does not have the
<br>
&nbsp; &nbsp;ability to process control data, control returns to the program with the
<br>
&nbsp; &nbsp;carry flag set and error code 0001H (invalid function) in register AX.
<br>
<br>
Example:
<br>
<br>
&nbsp;Read a control string from the block-device driver for drive C into the
<br>
&nbsp;buffer buff.
<br>
<br>
&nbsp;buflen &nbsp;equ &nbsp; &nbsp; 64 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; length of buffer
<br>
<br>
&nbsp;ctllen &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; length of control string
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;buflen dup (0) &nbsp;; receives control string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4404h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive C = 3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,buflen &nbsp; &nbsp; &nbsp; ; buffer length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; buffer address
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if read failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ctllen,ax &nbsp; &nbsp; &nbsp; ; save control string length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 44H (68) Subfunction 05H
<br>
IOCTL: write control data to block-device driver
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Transfers control data from an application program directly to a
<br>
&nbsp;block-device driver. The length and contents of the control data are
<br>
&nbsp;specific to each device driver and do not follow any standard format. This
<br>
&nbsp;function does not necessarily result in any output to the physical device.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive code (0 = default, 1 = A, 2 = B, etc.)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of bytes to write
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of data
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= bytes transferred
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ When supported by the driver, this subfunction can be used to request
<br>
&nbsp; &nbsp;hardware-dependent operations (such as tape rewind or disk eject) that
<br>
&nbsp; &nbsp;are not provided by other MS-DOS function calls.
<br>
<br>
&nbsp;■ Block-device drivers are not required to support IOCTL Subfunction 05H.
<br>
&nbsp; &nbsp;If this subfunction is requested and the driver does not have the
<br>
&nbsp; &nbsp;ability to process control data, control returns to the program with the
<br>
&nbsp; &nbsp;carry flag set and error code 0001H (invalid function) in register AX.
<br>
<br>
Example:
<br>
<br>
&nbsp;Write a control string from the buffer buff to the block-device driver for
<br>
&nbsp;drive C. The length of the string is assumed to be in the variable ctllen.
<br>
<br>
&nbsp;buflen &nbsp;equ &nbsp; &nbsp; 64 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; length of buffer
<br>
<br>
&nbsp;ctllen &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; length of control data
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;buflen dup (?) &nbsp;; contains control data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4405h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive C = 3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg buff &nbsp; &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,ctllen &nbsp; &nbsp; &nbsp; ; length of control data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if write failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 44H (68) Subfunction 06H
<br>
IOCTL: check input status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a code indicating whether the device or file associated with a
<br>
&nbsp;handle is ready for input.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 06H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, for a device:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if device not ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; if device ready
<br>
<br>
&nbsp;or, for a file:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if file pointer at EOF
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; if file pointer not at EOF
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function can be used to check the status of character devices, such
<br>
&nbsp; &nbsp;as the serial port, that do not have their own &quot;traditional&quot; MS-DOS
<br>
&nbsp; &nbsp;status calls.
<br>
<br>
Example:
<br>
<br>
&nbsp;Check whether a character is ready from the standard auxiliary device
<br>
&nbsp;(usually COM1).
<br>
<br>
&nbsp;stdaux &nbsp;equ &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard auxiliary handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4406h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdaux &nbsp; &nbsp; &nbsp; ; standard auxiliary handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; test status flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; ready &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if character ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 44H (68) Subfunction 07H
<br>
IOCTL: check output status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a code indicating whether the device associated with a handle is
<br>
&nbsp;ready for output.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 07H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, for a device:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if device not ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; if device ready
<br>
<br>
&nbsp;or, for a file:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ When used with a handle for a file, this function always returns a ready
<br>
&nbsp; &nbsp;status, even if the disk is full or no disk is in the drive.
<br>
<br>
Example:
<br>
<br>
&nbsp;Check whether the standard auxiliary device (usually COM1) can accept a
<br>
&nbsp;character for output.
<br>
<br>
&nbsp;stdaux &nbsp;equ &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard auxiliary handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4407h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdaux &nbsp; &nbsp; &nbsp; ; standard auxiliary handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; test status flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; ready &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if not busy
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.0]
<br>
Function 44H (68) Subfunction 08H
<br>
IOCTL: check if block device is removable
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Checks whether the specified block device contains a removable storage
<br>
&nbsp;medium, such as a floppy disk.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 08H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive number (0 = default, 1 = A, 2 = B, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if medium is removable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if medium is not removable
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If a file is not found as expected on a particular drive, a program can
<br>
&nbsp; &nbsp;use this subfunction to determine whether the user should be prompted to
<br>
&nbsp; &nbsp;insert another disk.
<br>
<br>
&nbsp;■ This subfunction may not be used for a network drive.
<br>
<br>
&nbsp;■ Block drivers are not required to support Subfunction 08H. If this
<br>
&nbsp; &nbsp;subfunction is requested and the block device cannot supply the
<br>
&nbsp; &nbsp;information, control returns to the program with the carry flag set and
<br>
&nbsp; &nbsp;error code 0001H (invalid function) in register AX.
<br>
<br>
Example:
<br>
<br>
&nbsp;Check whether drive C is removable.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4408h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive 3 = C
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; test type of medium
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; fixed &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if not removable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.1]
<br>
Function 44H (68) Subfunction 09H
<br>
IOCTL: check if block device is remote
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Checks whether the specified block device is local (attached to the
<br>
&nbsp;computer running the program) or remote (redirected to a network server).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 09H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive number (0 = default, 1 = A, 2 = B, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device attribute word
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bit 12 &nbsp; &nbsp; &nbsp; &nbsp;= 0 if drive is local
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if drive is remote
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ Use of this subfunction should be avoided. Application programs should
<br>
&nbsp; &nbsp;not distinguish between files on local and remote devices.
<br>
<br>
Example:
<br>
<br>
&nbsp;Check whether drive D is mounted on the machine running the program or is
<br>
&nbsp;a network drive.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,4409h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive 4 = D
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; dx,1000h &nbsp; &nbsp; &nbsp; &nbsp;; test local/remote bit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; remote &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if network drive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.1]
<br>
Function 44H (68) Subfunction 0AH (10)
<br>
IOCTL: check if handle is remote
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Checks whether the specified handle refers to a file or device that is
<br>
&nbsp;local (located on the PC that is running the program) or remote (located
<br>
&nbsp;on a network server).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0AH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute word for file or device
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bit 15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0 if local
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if remote
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Application programs should not ordinarily attempt to distinguish
<br>
&nbsp; &nbsp;between files on local and remote devices.
<br>
<br>
&nbsp;■ If the network has not been started, control returns to the calling
<br>
&nbsp; &nbsp;program with the carry flag set and error code 0001H (invalid function)
<br>
&nbsp; &nbsp;in register AX.
<br>
<br>
Example:
<br>
<br>
&nbsp;Check if the handle saved in the variable fhandle is associated with a
<br>
&nbsp;file or device on the machine running the program or on a network server.
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; device handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,440ah &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,fhandle &nbsp; &nbsp; &nbsp;; file/device handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; dx,8000h &nbsp; &nbsp; &nbsp; &nbsp;; test local/remote bit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; remote &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if network handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.1]
<br>
Function 44H (68) Subfunction 0BH (11)
<br>
IOCTL: change sharing retry count
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the number of times MS-DOS retries a disk operation after a failure
<br>
&nbsp;caused by a file-sharing violation before it returns an error to the
<br>
&nbsp;requesting process. This subfunction is not available unless the
<br>
&nbsp;file-sharing module (SHARE.EXE) is loaded.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0BH
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= delays per retry (default = 1)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of retries (default = 3)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The length of a delay is a machine-dependent value determined by the CPU
<br>
&nbsp; &nbsp;type and clock speed. Each delay consists of the following instruction
<br>
&nbsp; &nbsp;sequence:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; cx,cx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop &nbsp; &nbsp;$
<br>
<br>
&nbsp;which executes 65,536 times before falling out of the loop.
<br>
<br>
&nbsp;■ The sharing retry count affects the behavior of the system as a whole
<br>
&nbsp; &nbsp;and is not a local parameter for the process. If a program changes the
<br>
&nbsp; &nbsp;sharing retry count, it should restore the default values before
<br>
&nbsp; &nbsp;terminating.
<br>
<br>
Example:
<br>
<br>
&nbsp;Change the number of automatic retries for a file-sharing violation to
<br>
&nbsp;five.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,440bh &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; delays per retry
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; number of retries
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.2]
<br>
Function 44H (68) Subfunction 0CH (12)
<br>
IOCTL: generic I/O control for character devices
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Provides a general-purpose mechanism for communication between application
<br>
&nbsp;programs and character-device drivers.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0CH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= category (major) code:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = unknown
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = COM1, COM2, COM3, or COM4 (3.3)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H = CON (keyboard and display) (3.3)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H = LPT1, LPT2, or LPT3 (3.2)
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= function (minor) code:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;45H = Set Iteration Count (3.2)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4AH = Select Code Page (3.3)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4CH = Start Code Page Preparation (3.3)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4DH = End Code Page Preparation (3.3)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5FH = Set Display Information (4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;65H = Get Iteration Count (3.2)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6AH = Query Selected Code Page (3.3)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6BH = Query Prepare List (3.3)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7FH = Get Display Information (4.0)
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of parameter block
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if called with CL = 65H, 6AH, 6BH, or 7FH
<br>
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of parameter block
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the minor code is 45H (Set Iteration Count) or 65H (Get Iteration
<br>
&nbsp; &nbsp;Count), the parameter block is simply a 2-byte buffer containing or
<br>
&nbsp; &nbsp;receiving the iteration count for the printer. This call is valid only
<br>
&nbsp; &nbsp;for printer drivers that support Output Until Busy, and determines the
<br>
&nbsp; &nbsp;number of times the device driver will wait for the device to signal
<br>
&nbsp; &nbsp;ready before returning from the output call.
<br>
<br>
&nbsp;■ The parameter block for minor code 4DH (End Code Page Preparation) has
<br>
&nbsp; &nbsp;the following format:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; length of following data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (reserved)
<br>
<br>
&nbsp;■ For MS-DOS version 3.3, the parameter block for minor codes 4AH (Select
<br>
&nbsp; &nbsp;Code Page) and 6AH (Query Code Page) has the following format:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; length of following data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; code page ID
<br>
<br>
&nbsp;For MS-DOS version 4.0, minor codes 4AH and 6AH also set or get the
<br>
&nbsp;double-byte character set (DBCS) lead byte table, and the following format
<br>
&nbsp;is used:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;(n+2)*2+1 &nbsp; &nbsp; &nbsp; ; length of following data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; code page ID
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;start,end &nbsp; &nbsp; &nbsp; ; DBCS lead byte range 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;start,end &nbsp; &nbsp; &nbsp; ; DBCS lead byte range n
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0,0
<br>
<br>
&nbsp;■ The parameter block for minor code 4CH (Start Code Page Preparation) has
<br>
&nbsp; &nbsp;the following format:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; font type
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bit 0 &nbsp; = 0 downloaded
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; = 1 cartridge
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bits 1-15 = reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;(n+1)*2 &nbsp; &nbsp; &nbsp; &nbsp; ; length of remainder of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; parameter block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; number of code pages in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; the following list
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; code page 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; code page 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; code page n
<br>
<br>
&nbsp;■ The parameter block for minor code 6BH (Query Prepare List) has the
<br>
&nbsp; &nbsp;following format, assuming n hardware code pages and m prepared code
<br>
&nbsp; &nbsp;pages (n &lt;= 12, m &lt;= 12):
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;(n+m+2)*2 &nbsp; &nbsp; &nbsp; ; length of following data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; number of hardware code pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; hardware code page 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; hardware code page 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; hardware code page n
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;m &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; number of prepared code pages
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; prepared code page 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; prepared code page 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; prepared code page m
<br>
<br>
&nbsp;■ After a minor code 4CH (Start Code Page Preparation) call, the data
<br>
&nbsp; &nbsp;defining the code page font is written to the driver using one or more
<br>
&nbsp; &nbsp;calls to the IOCTL Write Control Data subfunction (Interrupt 21H,
<br>
&nbsp; &nbsp;Function 44H, Subfunction 03H). The format of the data is device- and
<br>
&nbsp; &nbsp;driver-specific. After the font data has been written to the driver, a
<br>
&nbsp; &nbsp;minor code 4DH (End Code Page Preparation) call must be issued. If no
<br>
&nbsp; &nbsp;data is written to the driver between the minor code 4CH and 4DH calls,
<br>
&nbsp; &nbsp;the driver interprets the newly prepared code pages as hardware code
<br>
&nbsp; &nbsp;pages.
<br>
<br>
&nbsp;■ A special variation of the minor code 4CH (Start Code Page Preparation)
<br>
&nbsp; &nbsp;call, called &quot;Refresh,&quot; is required to actually load the peripheral
<br>
&nbsp; &nbsp;device with the prepared code pages. The refresh operation is obtained
<br>
&nbsp; &nbsp;by requesting minor code 4CH with each code page position in the
<br>
&nbsp; &nbsp;parameter block set to -1, followed by an immediate call for minor code
<br>
&nbsp; &nbsp;4DH (End Code Page Preparation).
<br>
<br>
&nbsp;■ [4.0+] For minor codes 5FH (Set Display Information) and 7FH (Get
<br>
&nbsp; &nbsp;Display Information), the parameter block is formatted as follows:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; level (0 in MS-DOS 4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; reserved (must be 0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; length of following data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; control flags
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bit 0 &nbsp; &nbsp; = 0 intensity
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 1 blink
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; bits 1-15 = reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; mode type (1 = text, 2 = APA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; reserved (must be 0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; colors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 0 = monochrome compatible
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 1 = 2 colors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 2 = 4 colors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 4 = 16 colors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 8 = 256 colors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; pixel columns
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; pixel rows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; character columns
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; character rows
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the current code page for the standard list device.
<br>
<br>
&nbsp;stdprn &nbsp;equ &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; standard list handle
<br>
<br>
&nbsp;pars &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; length of data
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; receives code page
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,440ch &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdprn &nbsp; &nbsp; &nbsp; ; standard list handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ch,5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; LPTx category
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cl,6ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; query code page
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg pars &nbsp; &nbsp; ; parameter block address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset pars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.2]
<br>
Function 44H Subfunction 0DH (13)
<br>
IOCTL: generic I/O control for block devices
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Provides a general-purpose mechanism for communication between application
<br>
&nbsp;programs and block-device drivers. Allows a program to inspect or change
<br>
&nbsp;device parameters for a logical drive and to read, write, format, and
<br>
&nbsp;verify disk tracks in a hardware-independent manner.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0DH
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive code (0 = default, 1 = A, 2 = B, etc.)
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= category (major) code:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;08H = disk drive
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= function (minor) code:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;40H = Set Device Parameters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;41H = Write Track
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;42H = Format and Verify Track
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;47H = Set Access Flag (4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;60H = Get Device Parameters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;61H = Read Track
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;62H = Verify Track
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;67H = Get Access Flag (4.0)
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of parameter block
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if called with CL = 60H or 61H
<br>
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of parameter block
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The minor code 40H (Set Device Parameters) function must be used before
<br>
&nbsp; &nbsp;an attempt to write, read, format, or verify a track on a logical drive.
<br>
&nbsp; &nbsp;In general, the following sequence applies to any of these operations:
<br>
<br>
&nbsp; &nbsp;∙ Get the current parameters (minor code 60H). Examine and save them.
<br>
<br>
&nbsp; &nbsp;∙ Set the new parameters (minor code 40H).
<br>
<br>
&nbsp; &nbsp;∙ Perform the task.
<br>
<br>
&nbsp; &nbsp;∙ Retrieve the original parameters and restore them with minor code 40H.
<br>
<br>
&nbsp;■ For minor codes 40H (Set Device Parameters) and 60H (Get Device
<br>
&nbsp; &nbsp;Parameters), the parameter block is formatted as follows:
<br>
<br>
&nbsp; &nbsp;Special-functions field: offset 00H, length = 1 byte
<br>
<br>
&nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Value &nbsp; &nbsp; &nbsp;Meaning
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;device BPB field contains a new default BPB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;use current BPB
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;use all fields in parameter block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;use track layout field only
<br>
&nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sectors in track may be different sizes (should
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; always be avoided)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sectors in track are all same size; sector numbers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; range from 1 to the total number of sectors in the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; track (should always be used)
<br>
&nbsp; &nbsp;3─7 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reserved
<br>
<br>
&nbsp; &nbsp;Device type field: offset 01H, length 1 byte
<br>
<br>
&nbsp; &nbsp;Value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 320/360 KB, 5.25-inch disk
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.2 MB, 5.25-inch disk
<br>
&nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 720 KB, 3.5-inch disk
<br>
&nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; single-density, 8-inch disk
<br>
&nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double-density, 8-inch disk
<br>
&nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fixed disk
<br>
&nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tape drive
<br>
&nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; other type of block device
<br>
<br>
&nbsp; &nbsp;Device attributes field: offset 02H, length 1 word
<br>
<br>
&nbsp; &nbsp;Bit(s) &nbsp; &nbsp; &nbsp; &nbsp;Value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Meaning
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;removable storage medium
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nonremovable storage medium
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;door lock not supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;door lock supported
<br>
&nbsp; &nbsp;2─15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reserved
<br>
<br>
&nbsp; &nbsp;Number of cylinders field: offset 04H, length 1 word
<br>
&nbsp; &nbsp;Maximum number of cylinders supported on the block device
<br>
<br>
&nbsp; &nbsp;Media type field: offset 06H, length 1 byte
<br>
<br>
&nbsp; &nbsp;Value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.2 MB, 5.25-inch disk
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 320/360 KB, 5.25-inch disk
<br>
<br>
&nbsp; &nbsp;Device BPB field: offset 07H, length 31 bytes
<br>
&nbsp; &nbsp;For format of the device BPB, see separate Note below.
<br>
&nbsp; &nbsp;If bit 0 = 0 in special-functions field, this field contains the new
<br>
&nbsp; &nbsp;default BPB for the device.
<br>
&nbsp; &nbsp;If bit 0 = 1 in special-functions field, the BPB in this field is
<br>
&nbsp; &nbsp;returned by the device driver in response to subsequent Build BPB
<br>
&nbsp; &nbsp;requests.
<br>
<br>
&nbsp; &nbsp;Track layout field: offset 26H, variable-length table
<br>
<br>
&nbsp; &nbsp;Length &nbsp; &nbsp; &nbsp;Meaning
<br>
&nbsp; &nbsp;Word &nbsp; &nbsp; &nbsp; &nbsp;number of sectors in track
<br>
&nbsp; &nbsp;Word &nbsp; &nbsp; &nbsp; &nbsp;number of first sector in track
<br>
&nbsp; &nbsp;Word &nbsp; &nbsp; &nbsp; &nbsp;size of first sector in track
<br>
&nbsp; &nbsp;.
<br>
&nbsp; &nbsp;.
<br>
&nbsp; &nbsp;.
<br>
&nbsp; &nbsp;Word &nbsp; &nbsp; &nbsp; &nbsp;number of last sector in track
<br>
&nbsp; &nbsp;Word &nbsp; &nbsp; &nbsp; &nbsp;size of last sector in track
<br>
<br>
&nbsp;■ The device BPB field is a 31-byte data structure that describes the
<br>
&nbsp; &nbsp;current disk and its control areas. The field is formatted as follows:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; &nbsp; Meaning
<br>
&nbsp; &nbsp;00H─01H &nbsp; &nbsp; bytes per sector
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; sectors per cluster (allocation unit)
<br>
&nbsp; &nbsp;03─04H &nbsp; &nbsp; &nbsp;reserved sectors, beginning at sector 0
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; number of file allocation tables (FATs)
<br>
&nbsp; &nbsp;06H─07H &nbsp; &nbsp; maximum number of root-directory entries
<br>
&nbsp; &nbsp;08H─09H &nbsp; &nbsp; number of sectors
<br>
&nbsp; &nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; media descriptor
<br>
&nbsp; &nbsp;0BH─0CH &nbsp; &nbsp; sectors per FAT
<br>
&nbsp; &nbsp;0DH─0EH &nbsp; &nbsp; sectors per track
<br>
&nbsp; &nbsp;0FH─10H &nbsp; &nbsp; number of heads
<br>
&nbsp; &nbsp;11H─14H &nbsp; &nbsp; number of hidden sectors
<br>
&nbsp; &nbsp;15H─18H &nbsp; &nbsp; large number of sectors (if bytes 08H─09H=0)
<br>
&nbsp; &nbsp;19H─1EH &nbsp; &nbsp; reserved
<br>
<br>
&nbsp;■ When minor code 40H (Set Device Parameters) is used, the number of
<br>
&nbsp; &nbsp;cylinders should not be altered, or some or all of the volume may become
<br>
&nbsp; &nbsp;inaccessible.
<br>
<br>
&nbsp;■ For minor codes 41H (Write Track) and 61H (Read Track), the parameter
<br>
&nbsp; &nbsp;block is formatted as follows:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; &nbsp; Meaning
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; special-functions field (must be 0)
<br>
&nbsp; &nbsp;01H─02H &nbsp; &nbsp; head
<br>
&nbsp; &nbsp;03H─04H &nbsp; &nbsp; cylinder
<br>
&nbsp; &nbsp;05H─06H &nbsp; &nbsp; starting sector
<br>
&nbsp; &nbsp;07H─08H &nbsp; &nbsp; sectors to transfer
<br>
&nbsp; &nbsp;09H─0CH &nbsp; &nbsp; transfer buffer address
<br>
<br>
&nbsp;■ For minor codes 42H (Format and Verify Track) and 62H (Verify Track),
<br>
&nbsp; &nbsp;the parameter block is formatted as follows:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; &nbsp; Meaning
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; special-functions field
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 = Format/Verify track
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = Format status call (MS-DOS 4.0 only)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1─7 &nbsp; &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp;01H─02H &nbsp; &nbsp; head
<br>
&nbsp; &nbsp;03H─04H &nbsp; &nbsp; cylinder
<br>
<br>
&nbsp; &nbsp;In MS-DOS 4.0, this function may be called with bit 0 of the
<br>
&nbsp; &nbsp;special-functions field set after a minor code 40H call (Set Device
<br>
&nbsp; &nbsp;Parameters) to determine whether the driver supports the specified
<br>
&nbsp; &nbsp;number of tracks and sectors per track. A status is returned in the
<br>
&nbsp; &nbsp;special-functions field which is interpreted as follows:
<br>
<br>
&nbsp; &nbsp;Value &nbsp; &nbsp; &nbsp; Meaning
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specified number of tracks and sectors per track supported
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this function not supported by the ROM BIOS
<br>
&nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specified number of tracks and sectors per track not
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;supported
<br>
&nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no disk in drive
<br>
<br>
&nbsp;■ For minor codes 47H (Set Access Flag) and 67H (Get Access Flag), the
<br>
&nbsp; &nbsp;parameter block is formatted as follows:
<br>
<br>
&nbsp; &nbsp;Byte &nbsp; &nbsp; &nbsp; &nbsp;Meaning
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; special-functions field (must be 0)
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; disk access flag
<br>
<br>
&nbsp; &nbsp;When the disk access flag is zero, access to the medium is blocked by
<br>
&nbsp; &nbsp;the driver. The flag is set to zero when the driver detects an
<br>
&nbsp; &nbsp;unformatted medium or a medium with an invalid boot record. When the
<br>
&nbsp; &nbsp;access flag is nonzero, read/write operations to the medium are allowed
<br>
&nbsp; &nbsp;by the driver. A formatting program must clear the disk access flag with
<br>
&nbsp; &nbsp;minor code 47H before it requests minor code 42H (Format and Verify
<br>
&nbsp; &nbsp;Track).
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the device parameter block for disk drive C.
<br>
<br>
&nbsp;dbpb &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;128 dup (0) &nbsp; &nbsp; ; device parameter block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,440dh &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive C = 3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ch,8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; disk category
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cl,60h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get device parameters
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg dbpb &nbsp; &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset dbpb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.2]
<br>
Function 44H (68) Subfunction 0EH (14)
<br>
IOCTL: get logical drive map
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the logical drive code that was most recently used to access the
<br>
&nbsp;specified block device.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0EH
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive code (0 = default, 1 = A, 2 = B, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= mapping code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if only one logical drive code assigned to the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;block device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H─1AH &nbsp; logical drive code (1 = A, 2 = B, etc.) mapped
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to the block device
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ If a drive has not been assigned a logical mapping with Function 44H
<br>
&nbsp; &nbsp;Subfunction 0FH, the logical and physical drive codes are the same.
<br>
<br>
Example:
<br>
<br>
&nbsp;Check whether drive A has more than one logical drive code.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,440eh &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive 1 = A
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; test drive code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;label1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump, no drive aliases
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.2]
<br>
Function 44H (68) Subfunction 0FH (15)
<br>
IOCTL: set logical drive map
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the next logical drive code that will be used to reference a block
<br>
&nbsp;device.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0FH
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive code (0 = default, 1 = A, 2 = B, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= mapping code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if only one logical drive code assigned to the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;block device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H─1AH &nbsp; logical drive code (1 = A, 2 = B, etc.) mapped
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to the block device
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ When a physical block device is aliased to more than one logical drive
<br>
&nbsp; &nbsp;code, this function can be used to inform the driver which drive code
<br>
&nbsp; &nbsp;will next be used to access the device.
<br>
<br>
Example:
<br>
<br>
&nbsp;Notify the floppy-disk driver that the next access will be for logical
<br>
&nbsp;drive B.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,440fh &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive 2 = B
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 45H (69)
<br>
Duplicate handle
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given a handle for a currently open device or file, returns a new handle
<br>
&nbsp;that refers to the same device or file at the same position.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 45H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle to be duplicated
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= new handle
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ A seek, read, or write operation that moves the file pointer for one of
<br>
&nbsp; &nbsp;the two handles also moves the file pointer associated with the other.
<br>
<br>
&nbsp;■ This function can be used to efficiently update the directory for a file
<br>
&nbsp; &nbsp;that has changed in length, without incurring the overhead of closing
<br>
&nbsp; &nbsp;and then reopening the file. The handle for the file is simply
<br>
&nbsp; &nbsp;duplicated with this function and the duplicate is closed, leaving the
<br>
&nbsp; &nbsp;original handle open for further read/write operations.
<br>
<br>
&nbsp;■ [3.3] See also Int 21H Function 68H (Commit File).
<br>
<br>
Example:
<br>
<br>
&nbsp;Duplicate the handle stored in the variable fhandle, then close the
<br>
&nbsp;duplicate. This ensures that all buffered data is physically written to
<br>
&nbsp;disk and that the directory entry for the corresponding file is updated,
<br>
&nbsp;but leaves the original handle open for subsequent file operations.
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get duplicate handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,45h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,fhandle &nbsp; &nbsp; &nbsp;; original file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if dup failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now close dup'd handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; put handle into BX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS &nbsp; &nbsp; &nbsp; &nbsp; jc &nbsp; &nbsp; &nbsp;error
<br>
&nbsp; ; jump if close failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 46H (70)
<br>
Redirect handle
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given two handles, makes the second handle refer to the same device or
<br>
&nbsp;file at the same location as the first handle. The second handle is then
<br>
&nbsp;said to be redirected.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 46H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle for file or device
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle to be redirected
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the handle passed in CX already refers to an open file, that file is
<br>
&nbsp; &nbsp;closed first.
<br>
<br>
&nbsp;■ A seek, read, or write operation that moves the file pointer for one of
<br>
&nbsp; &nbsp;the two handles also moves the file pointer associated with the other.
<br>
<br>
&nbsp;■ This function is commonly used to redirect the standard input and output
<br>
&nbsp; &nbsp;handles to another file or device before a child process is executed
<br>
&nbsp; &nbsp;with Int 21H Function 4BH.
<br>
<br>
Example:
<br>
<br>
&nbsp;Redirect the standard output to the list device, so that all output
<br>
&nbsp;directed to the console will appear on the printer instead. Later, restore
<br>
&nbsp;the original meaning of the standard output handle.
<br>
<br>
&nbsp;stdin &nbsp; equ &nbsp; &nbsp; 0
<br>
&nbsp;stdout &nbsp;equ &nbsp; &nbsp; 1
<br>
&nbsp;stderr &nbsp;equ &nbsp; &nbsp; 2
<br>
&nbsp;stdaux &nbsp;equ &nbsp; &nbsp; 3
<br>
&nbsp;stdprn &nbsp;equ &nbsp; &nbsp; 4
<br>
<br>
&nbsp;dhandle dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; duplicate handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get dup of stdout
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,45h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdout &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if dup failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dhandle,ax &nbsp; &nbsp; &nbsp;; save dup'd handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; redirect standard output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to standard list device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,46h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,stdprn &nbsp; &nbsp; &nbsp; ; standard list handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,stdout &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if redirect failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; restore standard output
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to original meaning
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,46h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,dhandle &nbsp; &nbsp; &nbsp;; saved duplicate handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,stdout &nbsp; &nbsp; &nbsp; ; standard output handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if redirect failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; close duplicate handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; because no longer needed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,dhandle &nbsp; &nbsp; &nbsp;; saved duplicate handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if close failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 47H (71)
<br>
Get current directory
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains an ASCIIZ string that describes the path from the root to the
<br>
&nbsp;current directory, and the name of that directory.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 47H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive code (0 = default, 1 = A, etc.)
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of 64-byte buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and buffer is filled in with full pathname from root of current directory.
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The returned path name does not include the drive identifier or a
<br>
&nbsp; &nbsp;leading backslash (\). It is terminated with a null (00H) byte.
<br>
&nbsp; &nbsp;Consequently, if the current directory is the root directory, the first
<br>
&nbsp; &nbsp;byte in the buffer will contain 00H.
<br>
<br>
&nbsp;■ The function fails if the drive code is invalid.
<br>
<br>
&nbsp;■ The current directory may be set with Int 21H Function 3BH.
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the name of the current directory for drive C into the buffer named
<br>
&nbsp;dbuff.
<br>
<br>
&nbsp;dbuff &nbsp; db &nbsp; &nbsp; &nbsp;64 dup (0) &nbsp; &nbsp; &nbsp;; receives path string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,47h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dl,03 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive C = 3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,seg dbuff &nbsp; &nbsp;; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset dbuff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 48H (72)
<br>
Allocate memory block
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Allocates a block of memory and returns a pointer to the beginning of the
<br>
&nbsp;allocated area.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 48H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of paragraphs of memory needed
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= base segment address of allocated block
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= size of largest available block (paragraphs)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the function succeeds, the base address of the newly allocated block
<br>
&nbsp; &nbsp;is AX:0000.
<br>
<br>
&nbsp;■ The default allocation strategy used by MS-DOS is &quot;first fit&quot;; that is,
<br>
&nbsp; &nbsp;the memory block at the lowest address that is large enough to satisfy
<br>
&nbsp; &nbsp;the request is allocated. The allocation strategy can be altered with
<br>
&nbsp; &nbsp;Int 21H Function 58H.
<br>
<br>
&nbsp;■ When a .COM program is loaded, it ordinarily already &quot;owns&quot; all of the
<br>
&nbsp; &nbsp;memory in the transient program area, leaving none for dynamic
<br>
&nbsp; &nbsp;allocation. The amount of memory initially allocated to a .EXE program
<br>
&nbsp; &nbsp;at load time depends on the MINALLOC and MAXALLOC fields in the .EXE
<br>
&nbsp; &nbsp;file header. See Int 21H Function 4AH.
<br>
<br>
Example:
<br>
<br>
&nbsp;Request a 64 KB block of memory for use as a buffer.
<br>
<br>
&nbsp;bufseg &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; segment base of new block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,48h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,1000h &nbsp; &nbsp; &nbsp; &nbsp;; block size (paragraphs)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if allocation failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bufseg,ax &nbsp; &nbsp; &nbsp; ; save segment of new block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 49H (73)
<br>
Release memory block
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Releases a memory block and makes it available for use by other programs.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 49H
<br>
&nbsp;ES &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment of block to be released
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function assumes that the memory block being released was
<br>
&nbsp; &nbsp;previously obtained by a successful call to Int 21H Function 48H.
<br>
<br>
&nbsp;■ The function will fail or can cause unpredictable system errors if:
<br>
<br>
&nbsp; &nbsp;∙ the program releases a memory block that does not belong to it.
<br>
<br>
&nbsp; &nbsp;∙ the segment address passed in register ES is not a valid base address
<br>
&nbsp; &nbsp; &nbsp;for an existing memory block.
<br>
<br>
Example:
<br>
<br>
&nbsp;Release the memory block that was previously allocated in the example for
<br>
&nbsp;Int 21H Function 48H (page 438).
<br>
<br>
&nbsp;bufseg &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; segment base of block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,49h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,bufseg &nbsp; &nbsp; &nbsp; ; base segment of block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if release failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 4AH (74)
<br>
Resize memory block
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Dynamically shrinks or extends a memory block, according to the needs of
<br>
&nbsp;an application program.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4AH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= desired new block size in paragraphs
<br>
&nbsp;ES &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment of block to be modified
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= maximum block size available (paragraphs)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function modifies the size of a memory block that was previously
<br>
&nbsp; &nbsp;allocated with a call to Int 21H Function 48H.
<br>
<br>
&nbsp;■ If the program is requesting an increase in the size of an allocated
<br>
&nbsp; &nbsp;block, and this function fails, the maximum possible size for the
<br>
&nbsp; &nbsp;specified block is returned in register BX. The program can use this
<br>
&nbsp; &nbsp;value to determine whether it should terminate, or continue in a
<br>
&nbsp; &nbsp;degraded fashion with less memory.
<br>
<br>
&nbsp;■ A program that uses EXEC (Int 21H Function 4BH) to load and execute a
<br>
&nbsp; &nbsp;child program must call this function first to make memory available for
<br>
&nbsp; &nbsp;the child, passing the address of its PSP in register ES and the amount
<br>
&nbsp; &nbsp;of memory needed for its own code, data, and stacks in register BX.
<br>
<br>
Example:
<br>
<br>
&nbsp;Resize the memory block that was allocated in the example for Int 21H
<br>
&nbsp;Function 48H (page 438), shrinking it to 32 KB.
<br>
<br>
&nbsp;bufseg &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; segment base of block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,0800h &nbsp; &nbsp; &nbsp; &nbsp;; new size (paragraphs)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,bufseg &nbsp; &nbsp; &nbsp; ; segment base of block
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump, resize failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 4BH (75)
<br>
Execute program (EXEC)
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Allows an application program to run another program, regaining control
<br>
&nbsp;when it is finished. Can also be used to load overlays, although this use
<br>
&nbsp;is uncommon.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = Load and Execute Program
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H = Load Overlay
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of parameter block
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ program pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;[2] &nbsp; &nbsp; &nbsp; &nbsp; all registers except for CS:IP may be destroyed
<br>
&nbsp;[3.0+] &nbsp; &nbsp; &nbsp;registers are preserved in the usual fashion
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The parameter block format for Subfunction 00H (Load and Execute
<br>
&nbsp; &nbsp;Program) is as follows:
<br>
<br>
&nbsp; &nbsp;Bytes &nbsp; &nbsp; &nbsp; Contents
<br>
&nbsp; &nbsp;00H─01H &nbsp; &nbsp; segment pointer to environment block
<br>
&nbsp; &nbsp;02H─03H &nbsp; &nbsp; offset of command line tail
<br>
&nbsp; &nbsp;04H─05H &nbsp; &nbsp; segment of command line tail
<br>
&nbsp; &nbsp;06H─07H &nbsp; &nbsp; offset of first FCB to be copied into new PSP + 5CH
<br>
&nbsp; &nbsp;08H─09H &nbsp; &nbsp; segment of first FCB
<br>
&nbsp; &nbsp;0AH─0BH &nbsp; &nbsp; offset of second FCB to be copied into new PSP + 6CH
<br>
&nbsp; &nbsp;0CH─0DH &nbsp; &nbsp; segment of second FCB
<br>
<br>
&nbsp;■ The parameter block format for Subfunction 03H (Load Overlay) is as
<br>
&nbsp; &nbsp;follows:
<br>
<br>
&nbsp; &nbsp;Bytes &nbsp; &nbsp; &nbsp; Contents
<br>
&nbsp; &nbsp;00H─01H &nbsp; &nbsp; segment address where overlay is to be loaded
<br>
&nbsp; &nbsp;02H─03H &nbsp; &nbsp; relocation factor to apply to loaded image
<br>
<br>
&nbsp;■ The environment block must be paragraph-aligned. It consists of a
<br>
&nbsp; &nbsp;sequence of ASCIIZ strings in the form:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'COMSPEC=A:\COMMAND.COM',0
<br>
<br>
&nbsp; &nbsp;The entire set of strings is terminated by an extra null (00H) byte.
<br>
<br>
&nbsp;■ The command tail format consists of a count byte, followed by an ASCII
<br>
&nbsp; &nbsp;string, terminated by a carriage return (which is not included in the
<br>
&nbsp; &nbsp;count). The first character in the string should be an ASCII space (20H)
<br>
&nbsp; &nbsp;for compatibility with the command tail passed to programs by
<br>
&nbsp; &nbsp;COMMAND.COM. For example:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;6,' *.DAT',0dh
<br>
<br>
&nbsp;■ Before a program uses Int 21H Function 4BH to run another program, it
<br>
&nbsp; &nbsp;must release all memory it is not actually using with a call to Int 21H
<br>
&nbsp; &nbsp;Function 4AH, passing the segment address of its own PSP and the number
<br>
&nbsp; &nbsp;of paragraphs to retain.
<br>
<br>
&nbsp;■ Ordinarily, all active handles of the parent program are inherited by
<br>
&nbsp; &nbsp;the child program, although the parent can prevent this in MS-DOS 3.0
<br>
&nbsp; &nbsp;and later by setting the inheritance bit when the file or device is
<br>
&nbsp; &nbsp;opened. Any redirection of the standard input and/or output in the
<br>
&nbsp; &nbsp;parent process also affects the child process.
<br>
<br>
&nbsp;■ The environment block can be used to pass information to the child
<br>
&nbsp; &nbsp;process. If the environment block pointer in the parameter block is
<br>
&nbsp; &nbsp;zero, the child program inherits an exact copy of the parent's
<br>
&nbsp; &nbsp;environment. In any case, the segment address of the child's environment
<br>
&nbsp; &nbsp;is found at offset 002CH in the child's PSP.
<br>
<br>
&nbsp;■ After return from the EXEC function call, the termination type and
<br>
&nbsp; &nbsp;return code of the child program may be obtained with Int 21H Function
<br>
&nbsp; &nbsp;4DH.
<br>
<br>
Example:
<br>
<br>
&nbsp;See Chapter 12.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 4CH (76)
<br>
Terminate process with return code
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Terminates the current process, passing a return code to the parent
<br>
&nbsp;process. This is one of several methods that a program can use to perform
<br>
&nbsp;a final exit. MS-DOS then takes the following actions:
<br>
<br>
&nbsp;■ All memory belonging to the process is released.
<br>
<br>
&nbsp;■ File buffers are flushed and any open handles for files or devices owned
<br>
&nbsp; &nbsp;by the process are closed.
<br>
<br>
&nbsp;■ The termination handler vector (Int 22H) is restored from PSP:000AH.
<br>
<br>
&nbsp;■ The Ctrl-C handler vector (Int 23H) is restored from PSP:000EH.
<br>
<br>
&nbsp;■ [2.0+] The critical-error handler vector (Int 24H) is restored from
<br>
&nbsp; &nbsp;PSP:0012H.
<br>
<br>
&nbsp;■ Control is transferred to the termination handler.
<br>
<br>
&nbsp;If the program is returning to COMMAND.COM, control transfers to the
<br>
&nbsp;resident portion and the transient portion is reloaded if necessary. If a
<br>
&nbsp;batch file is in progress, the next line of the file is fetched and
<br>
&nbsp;interpreted; otherwise, a prompt is issued for the next user command.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4CH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= return code
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ [2.0+] This is the preferred method of termination for application
<br>
&nbsp; &nbsp;programs because it allows a return code to be passed to the parent
<br>
&nbsp; &nbsp;program and does not rely on the contents of any segment register. Other
<br>
&nbsp; &nbsp;methods of performing a final exit are:
<br>
<br>
&nbsp; &nbsp;∙ Int 20H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 00H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 31H
<br>
<br>
&nbsp; &nbsp;∙ Int 27H
<br>
<br>
&nbsp;■ Any files that have been opened using FCBs and modified by the program
<br>
&nbsp; &nbsp;should be closed before program termination; otherwise, data may be
<br>
&nbsp; &nbsp;lost.
<br>
<br>
&nbsp;■ The return code can be retrieved by the parent process with Int 21H
<br>
&nbsp; &nbsp;Function 4DH (Get Return Code). It can also be tested in a batch file
<br>
&nbsp; &nbsp;with an IF ERRORLEVEL statement. By convention, a return code of zero
<br>
&nbsp; &nbsp;indicates successful execution, and a non-zero return code indicates an
<br>
&nbsp; &nbsp;error.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, it should remove all
<br>
&nbsp; &nbsp;locks it has placed on file regions before terminating.
<br>
<br>
Example:
<br>
<br>
&nbsp;Terminate the current process, passing a return code of 1 to the parent
<br>
&nbsp;process.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4ch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,01h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; return code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 4DH (77)
<br>
Get return code
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Used by a parent process, after the successful execution of an EXEC call
<br>
&nbsp;(Int 21H Function 4BH), to obtain the return code and termination type of
<br>
&nbsp;a child process.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4DH
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= exit type
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H if normal termination by Int 20H, Int 21H Function
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H, or Int 21H Function 4CH
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H if termination by user's entry of CtrlDC
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H if termination by critical-error handler
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H if termination by Int 21H Function 31H or Int 27H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= return code passed by child process (0 if child terminated
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by Int 20H, Int 21H Function 00H, or Int 27H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function will yield the return code of a child process only once. A
<br>
&nbsp; &nbsp;subsequent call without an intervening EXEC (Int 21H Function 4BH) will
<br>
&nbsp; &nbsp;not necessarily return any valid information.
<br>
<br>
&nbsp;■ This function does not set the carry flag to indicate an error. If no
<br>
&nbsp; &nbsp;previous child process has been executed, the values returned in AL and
<br>
&nbsp; &nbsp;AH are undefined.
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the return code and termination kind of child process that was
<br>
&nbsp;previously executed with Int 21H Function 4BH (EXEC).
<br>
<br>
&nbsp;retcode dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return code, termination type
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; retcode,ax &nbsp; &nbsp; &nbsp;; save child process info
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 4EH (78)
<br>
Find first file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given a file specification in the form of an ASCIIZ string, searches the
<br>
&nbsp;default or specified directory on the default or specified drive for the
<br>
&nbsp;first matching file.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4EH
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= search attribute (bits may be combined)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; read-only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; hidden
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; system
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; volume label
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; directory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; archive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (matching file found)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and search results returned in current disk transfer area as follows:
<br>
<br>
&nbsp;Byte(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Description
<br>
&nbsp;00H─14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reserved (0)
<br>
&nbsp;15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;attribute of matched file or directory
<br>
&nbsp;16H─17H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;file time
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits 00H─04H = 2-second increments (0─29)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits 05H─0AH = minutes (0─59)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits 0BH─0FH = hours (0─23)
<br>
&nbsp;18H─19H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;file date
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits 00H─04H = day (1─31)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits 05H─08H = month (1─12)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits 09H─0FH = year (relative to 1980)
<br>
&nbsp;1AH─1DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;file size
<br>
&nbsp;1EH─2AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ASCIIZ filename and extension
<br>
<br>
&nbsp;If function unsuccessful (no matching files)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function assumes that the DTA has been previously set by the
<br>
&nbsp; &nbsp;program with Int 21H Function 1AH to point to a buffer of adequate
<br>
&nbsp; &nbsp;size.
<br>
<br>
&nbsp;■ The * and ? wildcard characters are allowed in the filename. If wildcard
<br>
&nbsp; &nbsp;characters are present, this function returns only the first matching
<br>
&nbsp; &nbsp;filename.
<br>
<br>
&nbsp;■ If the attribute is 0, only ordinary files are found. If the volume
<br>
&nbsp; &nbsp;label attribute bit is set, only volume labels will be returned (if any
<br>
&nbsp; &nbsp;are present). Any other attribute or combination of attributes (hidden,
<br>
&nbsp; &nbsp;system, and directory) results in those files and all normal files being
<br>
&nbsp; &nbsp;matched.
<br>
<br>
Example:
<br>
<br>
&nbsp;Find the first .COM file in the directory \MYDIR on drive C.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\MYDIR\*.COM',0
<br>
<br>
&nbsp;dbuff &nbsp; db &nbsp; &nbsp; &nbsp;43 dup (0) &nbsp; &nbsp; &nbsp;; receives search results
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set DTA address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,1ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg dbuff &nbsp; &nbsp;; result buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset dbuff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; search for first match
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; normal attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg fname &nbsp; &nbsp;; address of filename
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if no match
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 4FH (79)
<br>
Find next file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Assuming a previous successful call to Int 21H Function 4EH, finds the
<br>
&nbsp;next file in the default or specified directory on the default or
<br>
&nbsp;specified drive that matches the original file specification.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4FH
<br>
<br>
&nbsp;Assumes DTA points to working buffer used by previous successful Int 21H
<br>
&nbsp;Function 4EH or 4FH.
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (matching file found)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and search results returned in current disk transfer area as described for
<br>
&nbsp;Int 21H Function 4EH
<br>
<br>
&nbsp;If function unsuccessful (no more matching files)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Use of this call assumes that the original file specification passed to
<br>
&nbsp; &nbsp;Int 21H Function 4EH contained one or more * or ? wildcard characters.
<br>
<br>
&nbsp;■ When this function is called, the current disk transfer area (DTA) must
<br>
&nbsp; &nbsp;contain information from a previous successful call to Int 21H Function
<br>
&nbsp; &nbsp;4EH or 4FH.
<br>
<br>
Example:
<br>
<br>
&nbsp;Continuing the search operation in the example for Int 21H Function 4EH,
<br>
&nbsp;find the next .COM file (if any) in the directory \MYDIR on drive C.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\MYDIR\*.COM',0
<br>
<br>
&nbsp;dbuff &nbsp; db &nbsp; &nbsp; &nbsp;43 dup (0) &nbsp; &nbsp; &nbsp;; receives search results
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; search for next match
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if no more files
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 50H (80)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 51H (81)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 52H (82)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 53H (83)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 54H (84)
<br>
Get verify flag
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the current value of the system verify (read-after-write) flag.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 54H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= current verify flag value
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H if verify off
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H if verify on
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Because read-after-write verification slows disk operations, the default
<br>
&nbsp; &nbsp;state of the system verify flag is OFF.
<br>
<br>
&nbsp;■ The state of the system verify flag can be changed through a call to Int
<br>
&nbsp; &nbsp;21H Function 2EH or by the MS-DOS commands VERIFY ON and VERIFY OFF.
<br>
<br>
Example:
<br>
<br>
&nbsp;Obtain the state of the system verify flag.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,54h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; al,01h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; check verify state
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;je &nbsp; &nbsp; &nbsp;label1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; jump if verify on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; else assume verify off
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 55H (85)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 56H (86)
<br>
Rename file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Renames a file and/or moves its directory entry to a different directory
<br>
&nbsp;on the same disk. In MS-DOS version 3.0 and later, this function can also
<br>
&nbsp;be used to rename directories.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 56H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of current ASCIIZ pathname
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of new ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The function fails if:
<br>
<br>
&nbsp; &nbsp;∙ any element of the pathname does not exist.
<br>
<br>
&nbsp; &nbsp;∙ a file with the new pathname already exists.
<br>
<br>
&nbsp; &nbsp;∙ the current pathname specification contains a different disk drive
<br>
&nbsp; &nbsp; &nbsp;than does the new pathname.
<br>
<br>
&nbsp; &nbsp;∙ the file is being moved to the root directory, and the root directory
<br>
&nbsp; &nbsp; &nbsp;is full.
<br>
<br>
&nbsp; &nbsp;∙ [3.0+] the program is running on a network and the user has
<br>
&nbsp; &nbsp; &nbsp;insufficient access rights to either the existing file or the new
<br>
&nbsp; &nbsp; &nbsp;directory.
<br>
<br>
&nbsp;■ The * and ? wildcard characters are not allowed in either the current or
<br>
&nbsp; &nbsp;new pathname specifications.
<br>
<br>
Example:
<br>
<br>
&nbsp;Change the name of the file MYFILE.DAT in the directory \MYDIR on drive C
<br>
&nbsp;to MYTEXT.DAT. At the same time, move the file to the directory \SYSTEM on
<br>
&nbsp;the same drive.
<br>
<br>
&nbsp;oldname db &nbsp; &nbsp; &nbsp;'C:\MYDIR\MYFILE.DAT',0
<br>
<br>
&nbsp;newname db &nbsp; &nbsp; &nbsp;'C:\SYSTEM\MYTEXT.DAT',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,56h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg oldname &nbsp;; old filename address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset oldname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,seg newname &nbsp;; new filename address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset newname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if rename failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.0]
<br>
Function 57H (87)
<br>
Get or set file date and time
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains or modifies the date and time stamp in a file's directory entry.
<br>
<br>
Call with:
<br>
<br>
&nbsp;If getting date and time
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 57H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
<br>
&nbsp;If setting date and time
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 57H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= time
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bits 00H─04H = 2-second increments (0─29)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bits 05H─0AH = minutes (0─59)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bits 0BH─0FH = hours (0─23)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= date
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bits 00H─04H = day (1─31)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bits 05H─08H = month (1─12)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bits 09H─0FH = year (relative to 1980)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if called with AL = 00H
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= time
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= date
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The file must have been previously opened or created via a successful
<br>
&nbsp; &nbsp;call to Int 21H Function 3CH, 3DH, 5AH, 5BH, or 6CH.
<br>
<br>
&nbsp;■ If the 16-bit date for a file is set to zero, that file's date and time
<br>
&nbsp; &nbsp;are not displayed on directory listings.
<br>
<br>
&nbsp;■ A date and time set with this function will prevail, even if the file is
<br>
&nbsp; &nbsp;modified afterwards before the handle is closed.
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the date that the file MYFILE.DAT was created or last modified, and
<br>
&nbsp;then decompose the packed date into its constituent parts in the variables
<br>
&nbsp;month, day, and year.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'MYFILE.DAT',0
<br>
<br>
&nbsp;month &nbsp; dw &nbsp; &nbsp; &nbsp;0
<br>
&nbsp;day &nbsp; &nbsp; dw &nbsp; &nbsp; &nbsp;0
<br>
&nbsp;year &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; first open the file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3dh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; read-only mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg fname &nbsp; &nbsp;; filename address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if open failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get file date/time
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; copy handle to BX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,57h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 0 = get subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; day,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; decompose date
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; day,01fh &nbsp; &nbsp; &nbsp; &nbsp;; isolate day
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cl,5
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; dx,cl
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; month,dx &nbsp; &nbsp; &nbsp; &nbsp;; isolate month
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; month,0fh
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cl,4
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shr &nbsp; &nbsp; dx,cl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; isolate year
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and &nbsp; &nbsp; dx,03fh &nbsp; &nbsp; &nbsp; &nbsp; ; relative to 1980
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; dx,1980 &nbsp; &nbsp; &nbsp; &nbsp; ; correct to real year
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; year,dx &nbsp; &nbsp; &nbsp; &nbsp; ; save year
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now close file,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; handle still in BX
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,3eh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if close failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.0]
<br>
Function 58H (88)
<br>
Get or set allocation strategy
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains or changes the code indicating the current MS-DOS strategy for
<br>
&nbsp;allocating memory blocks.
<br>
<br>
Call with:
<br>
<br>
&nbsp;If getting strategy code
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 58H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If setting strategy code
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 58H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= desired strategy code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = first fit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = best fit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = last fit
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if called with AL = 00H
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= current strategy code
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The memory allocation strategies are:
<br>
<br>
&nbsp; &nbsp;∙ First fit: MS-DOS searches the available memory blocks from low
<br>
&nbsp; &nbsp; &nbsp;addresses to high addresses, assigning the first one large enough to
<br>
&nbsp; &nbsp; &nbsp;satisfy the block allocation request.
<br>
<br>
&nbsp; &nbsp;∙ Best fit: MS-DOS searches all available memory blocks and assigns the
<br>
&nbsp; &nbsp; &nbsp;smallest available block that will satisfy the request, regardless of
<br>
&nbsp; &nbsp; &nbsp;its position.
<br>
<br>
&nbsp; &nbsp;∙ Last fit: MS-DOS searches the available memory blocks from high
<br>
&nbsp; &nbsp; &nbsp;addresses to low addresses, assigning the highest one large enough to
<br>
&nbsp; &nbsp; &nbsp;satisfy the block allocation request.
<br>
<br>
&nbsp;■ The default MS-DOS memory allocation strategy is First Fit (code 0).
<br>
<br>
Example:
<br>
<br>
&nbsp;Save the code indicating the current memory allocation strategy in the
<br>
&nbsp;variable strat, then change the system's memory allocation strategy to
<br>
&nbsp;&quot;best fit.&quot;
<br>
<br>
&nbsp;strat &nbsp; dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; previous strategy code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get current strategy
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,58h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 0 = get strategy
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; strat,ax &nbsp; &nbsp; &nbsp; &nbsp;; save strategy code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; now set new strategy
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,58h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 1 = set strategy
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 1 = best fit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.0]
<br>
Function 59H (89)
<br>
Get extended error information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains detailed error information after a previous unsuccessful Int 21H
<br>
&nbsp;function call, including the recommended remedial action.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 59H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= extended error code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; function number invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; file not found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; path not found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; too many open files
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; access denied
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; handle invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; memory control blocks destroyed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; insufficient memory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; memory block address invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0AH (10) &nbsp;environment invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0BH (11) &nbsp;format invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0CH (12) &nbsp;access code invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0DH (13) &nbsp;data invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0EH (14) &nbsp;unknown unit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0FH (15) &nbsp;disk drive invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10H (16) &nbsp;attempted to remove current directory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11H (17) &nbsp;not same device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12H (18) &nbsp;no more files
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13H (19) &nbsp;disk write-protected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14H (20) &nbsp;unknown unit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;15H (21) &nbsp;drive not ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16H (22) &nbsp;unknown command
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;17H (23) &nbsp;data error (CRC)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18H (24) &nbsp;bad request structure length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;19H (25) &nbsp;seek error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1AH (26) &nbsp;unknown media type
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1BH (27) &nbsp;sector not found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1CH (28) &nbsp;printer out of paper
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1DH (29) &nbsp;write fault
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1EH (30) &nbsp;read fault
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1FH (31) &nbsp;general failure
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;20H (32) &nbsp;sharing violation
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;21H (33) &nbsp;lock violation
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;22H (34) &nbsp;disk change invalid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;23H (35) &nbsp;FCB unavailable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24H (36) &nbsp;sharing buffer exceeded
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;25H─31H &nbsp; reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32H (50) &nbsp;unsupported network request
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;33H (51) &nbsp;remote machine not listening
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;34H (52) &nbsp;duplicate name on network
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;35H (53) &nbsp;network name not found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;36H (54) &nbsp;network busy
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;37H (55) &nbsp;device no longer exists on network
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;38H (56) &nbsp;netBIOS command limit exceeded
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;39H (57) &nbsp;error in network adapter hardware
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3AH (58) &nbsp;incorrect response from network
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3BH (59) &nbsp;unexpected network error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3CH (60) &nbsp;remote adapter incompatible
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3DH (61) &nbsp;print queue full
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3EH (62) &nbsp;not enough space for print file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3FH (63) &nbsp;print file canceled
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;40H (64) &nbsp;network name deleted
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;41H (65) &nbsp;network access denied
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;42H (66) &nbsp;incorrect network device type
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;43H (67) &nbsp;network name not found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;44H (68) &nbsp;network name limit exceeded
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;45H (69) &nbsp;netBIOS session limit exceeded
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;46H (70) &nbsp;file sharing temporarily paused
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;47H (71) &nbsp;network request not accepted
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;48H (72) &nbsp;print or disk redirection paused
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;49H─4FH &nbsp; reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;50H (80) &nbsp;file already exists
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;51H (81) &nbsp;reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;52H (82) &nbsp;cannot make directory
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;53H (83) &nbsp;fail on Int 24H (critical error)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;54H (84) &nbsp;too many redirections
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;55H (85) &nbsp;duplicate redirection
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;56H (86) &nbsp;invalid password
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;57H (87) &nbsp;invalid parameter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;58H (88) &nbsp;network device fault
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;59H (89) &nbsp;function not supported by network
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5AH (90) &nbsp;required system component not installed
<br>
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error class
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if out of resource (such as storage or handles)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if not error, but temporary situation (such as
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locked region in file) that can be expected to
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if authorization problem
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; if internal error in system software
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; if hardware failure
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; if system software failure not the fault of the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;active process (such as missing configuration
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;files)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; if application program error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; if file or item not found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; if file or item of invalid type or format
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0AH (10) &nbsp;if file or item locked
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0BH (11) &nbsp;if wrong disk in drive, bad spot on disk, or
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;storage medium problem
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0CH (12) &nbsp;if item already exists
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0DH (13) &nbsp;unknown error
<br>
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= recommended action
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; retry reasonable number of times, then prompt
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;user to select abort or ignore
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; retry reasonable number of times with delay
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;between retries, then prompt user to select
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;abort or ignore
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; get corrected information from user (typically
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;caused by incorrect filename or drive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;specification)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; abort application with cleanup (i.e., terminate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the program in as orderly a manner as possible:
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;releasing locks, closing files, etc.)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; perform immediate exit without cleanup
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; ignore error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; retry after user intervention to remove cause of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;error
<br>
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error locus
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; unknown
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; block device (disk or disk emulator)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; network
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; serial device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; memory
<br>
<br>
&nbsp;and, for MS-DOS 3.0 and later,
<br>
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = ASCIIZ volume label of disk to insert, if AX = 0022H
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(invalid disk change)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function may be called after any other Int 21H function call that
<br>
&nbsp; &nbsp;returned an error status, in order to obtain more detailed information
<br>
&nbsp; &nbsp;about the error type and the recommended action. If the previous Int 21H
<br>
&nbsp; &nbsp;function call had no error, 0000H is returned in register AX. This
<br>
&nbsp; &nbsp;function may also be called during the execution of a critical-error
<br>
&nbsp; &nbsp;(Int 24H) handler.
<br>
<br>
&nbsp;■ The contents of registers CL, DX, SI, DI, BP, DS, and ES are destroyed
<br>
&nbsp; &nbsp;by this function.
<br>
<br>
&nbsp;■ Note that extended error codes 13H─1FH (19─31) and 34 (22H) correspond
<br>
&nbsp; &nbsp;exactly to the error codes 0─0CH (0─12) and 0FH (15) returned by Int
<br>
&nbsp; &nbsp;24H.
<br>
<br>
&nbsp;■ You should not code your programs to recognize only specific error
<br>
&nbsp; &nbsp;numbers if you wish to ensure upward compatibility, because new error
<br>
&nbsp; &nbsp;codes are added in each version of MS-DOS.
<br>
<br>
Example:
<br>
<br>
&nbsp;Attempt to open the file named NOSUCH.DAT using a file control block; if
<br>
&nbsp;the open request fails, get the extended error code.
<br>
<br>
&nbsp;myfcb &nbsp; db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; drive = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'NOSUCH &nbsp;' &nbsp; &nbsp; &nbsp;; filename, 8 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'DAT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; extension, 3 chars
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;25 dup (0) &nbsp; &nbsp; &nbsp;; remainder of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;label1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; open the file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,0fh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg myfcb &nbsp; &nbsp;; address of FCB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset myfcb
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;al,al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check open status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;success &nbsp; &nbsp; &nbsp; &nbsp; ; jump if opened OK
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; open failed, get
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; extended error info
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,59h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; bx,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; BX must = 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;ax,ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; double check for error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;success &nbsp; &nbsp; &nbsp; &nbsp; ; jump if no error
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; bl,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; should we retry?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jle &nbsp; &nbsp; label1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; yes, jump
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no, give up
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.0]
<br>
Function 5AH (90)
<br>
Create temporary file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Creates a file with a unique name, in the current or specified directory
<br>
&nbsp;on the default or specified disk drive, and returns a handle that can be
<br>
&nbsp;used by the program for subsequent access to the file. The name generated
<br>
&nbsp;for the file is also returned in a buffer specified by the program.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5AH
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute (bits may be combined)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; read-only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; hidden
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; system
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3─4 &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; archive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ path
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of complete ASCIIZ pathname
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The ASCIIZ path supplied to this function should be followed by at least
<br>
&nbsp; &nbsp;13 additional bytes of buffer space. MS-DOS adds a backslash (\) to the
<br>
&nbsp; &nbsp;supplied path, if necessary, then appends a null-terminated filename
<br>
&nbsp; &nbsp;that is a function of the current time.
<br>
<br>
&nbsp;■ Files created with this function are not automatically deleted when the
<br>
&nbsp; &nbsp;calling program terminates.
<br>
<br>
&nbsp;■ The function fails if
<br>
<br>
&nbsp; &nbsp;∙ any element of the pathname does not exist.
<br>
<br>
&nbsp; &nbsp;∙ the file is being created in the root directory, and the root
<br>
&nbsp; &nbsp; &nbsp;directory is full.
<br>
<br>
&nbsp;■ See also Int 21H Functions 3CH, 5BH, and 6CH, which provide
<br>
&nbsp; &nbsp;additional facilities for creating files.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, the file is created and
<br>
&nbsp; &nbsp;opened for read/write access in compatibility sharing mode.
<br>
<br>
Example:
<br>
<br>
&nbsp;Create a temporary file with a unique name and normal attribute in
<br>
&nbsp;directory \TEMP of drive C. Note that you must allow room for MS-DOS to
<br>
&nbsp;append the generated filename to the supplied path. The complete file
<br>
&nbsp;specification should be used to delete the temporary file before your
<br>
&nbsp;program terminates.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\TEMP\' &nbsp; &nbsp; &nbsp;; pathname for temp file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;13 dup (0) &nbsp; &nbsp; &nbsp;; receives filename
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,5ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; normal attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg fname &nbsp; &nbsp;; address of pathname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if create failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; fhandle,ax &nbsp; &nbsp; &nbsp;; save file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.0]
<br>
Function 5BH (91)
<br>
Create new file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given an ASCIIZ pathname, creates a file in the designated or default
<br>
&nbsp;directory on the designated or default drive, and returns a handle that
<br>
&nbsp;can be used by the program for subsequent access to the file. If a file
<br>
&nbsp;with the same name already exists, the function fails.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5BH
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute (bits may be combined)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; read-only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; hidden
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; system
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; volume label
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; archive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The function fails if:
<br>
<br>
&nbsp; &nbsp;∙ any element of the specified path does not exist.
<br>
<br>
&nbsp; &nbsp;∙ a file with the identical pathname (i.e., the same filename and
<br>
&nbsp; &nbsp; &nbsp;extension in the same location in the directory structure) already
<br>
&nbsp; &nbsp; &nbsp;exists.
<br>
<br>
&nbsp; &nbsp;∙ the file is being created in the root directory, and the root
<br>
&nbsp; &nbsp; &nbsp;directory is full.
<br>
<br>
&nbsp; &nbsp;∙ [3.0+] the program is running on a network, and the user has
<br>
&nbsp; &nbsp; &nbsp;insufficient access rights to the directory that will contain the
<br>
&nbsp; &nbsp; &nbsp;file.
<br>
<br>
&nbsp;■ The file is usually given a normal attribute (0) when it is created, and
<br>
&nbsp; &nbsp;is opened for both read and write operations. The attribute can
<br>
&nbsp; &nbsp;subsequently be modified with Int 21H Function 43H.
<br>
<br>
&nbsp;■ See also Int 21H Functions 3CH, 5AH, and 6CH, which provide
<br>
&nbsp; &nbsp;alternative ways of creating files.
<br>
<br>
&nbsp;■ This function may be used to implement semaphores in a network or
<br>
&nbsp; &nbsp;multitasking environment. If the function succeeds, the program has
<br>
&nbsp; &nbsp;acquired the semaphore. To release the semaphore, the program simply
<br>
&nbsp; &nbsp;deletes the file.
<br>
<br>
Example:
<br>
<br>
&nbsp;Create and open a file named MYFILE.DAT in the directory \MYDIR on drive
<br>
&nbsp;C; MS-DOS returns an error if a file with the same name already exists in
<br>
&nbsp;that location.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\MYDIR\MYFILE.DAT',0
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,5bh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; cx,cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; normal attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg fname &nbsp; &nbsp;; filename address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if create failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; fhandle,ax &nbsp; &nbsp; &nbsp;; save file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.0]
<br>
Function 5CH (92)
<br>
Lock or unlock file region
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Locks or unlocks the specified region of a file. This function is not
<br>
&nbsp;available unless the file-sharing module (SHARE.EXE) is loaded.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5CH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if locking region
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if unlocking region
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= high part of region offset
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= low part of region offset
<br>
&nbsp;SI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= high part of region length
<br>
&nbsp;DI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= low part of region length
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is useful for file and record synchronization in a
<br>
&nbsp; &nbsp;multitasking environment or network. Access to the file as a whole is
<br>
&nbsp; &nbsp;controlled by the attribute and file-sharing parameters passed in open
<br>
&nbsp; &nbsp;or create calls and by the file's attributes, which are stored in its
<br>
&nbsp; &nbsp;directory entry.
<br>
<br>
&nbsp;■ The beginning location in the file to be locked or unlocked is supplied
<br>
&nbsp; &nbsp;as a positive double precision integer, which is a byte offset into the
<br>
&nbsp; &nbsp;file. The length of the region to be locked or unlocked is similarly
<br>
&nbsp; &nbsp;supplied as a positive double precision integer.
<br>
<br>
&nbsp;■ For every call to lock a region of a file, there must be a subsequent
<br>
&nbsp; &nbsp;unlock call with exactly the same file offset and length.
<br>
<br>
&nbsp;■ Locking beyond the current end of file is not an error.
<br>
<br>
&nbsp;■ Duplicate handles created with Int 21H Function 45H, or handles
<br>
&nbsp; &nbsp;redirected to the file with Int 21H Function 46H, are allowed access to
<br>
&nbsp; &nbsp;locked regions within the same process.
<br>
<br>
&nbsp;■ Programs that are loaded with the EXEC call (Int 21H Function 4BH)
<br>
&nbsp; &nbsp;inherit the handles of their parent but not any active locks.
<br>
<br>
&nbsp;■ If a process terminates without releasing active locks on a file, the
<br>
&nbsp; &nbsp;result is undefined. Therefore, programs using this function should
<br>
&nbsp; &nbsp;install their own Int 23H and Int 24H handlers so that they cannot be
<br>
&nbsp; &nbsp;terminated unexpectedly.
<br>
<br>
Example:
<br>
<br>
&nbsp;Assume that a file was previously opened and that its handle was saved in
<br>
&nbsp;the variable fhandle. Lock a 4096 byte region of the file, starting at
<br>
&nbsp;32,768 bytes from the beginning of the file, so that it cannot be accessed
<br>
&nbsp;by other programs.
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,5ch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; subfunction 0 = lock
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,fhandle &nbsp; &nbsp; &nbsp;; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; upper part of offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,32768 &nbsp; &nbsp; &nbsp; &nbsp;; lower part of offset
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; upper part of length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,4096 &nbsp; &nbsp; &nbsp; &nbsp; ; lower part of length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if lock failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 5DH (93)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.1]
<br>
Function 5EH (94) Subfunction 00H
<br>
Get machine name
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the address of an ASCIIZ (null-terminated) string identifying the
<br>
&nbsp;local computer. This function call is only available when Microsoft
<br>
&nbsp;Networks is running.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5EH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer to receive string
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if name not defined
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&gt; 00H &nbsp; &nbsp;if name defined
<br>
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= netBIOS name number (if CH &lt;&gt; 0)
<br>
&nbsp;DX:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of identifier (if CH &lt;&gt; 0 )
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The computer identifier is a 15-byte string, padded with spaces and
<br>
&nbsp; &nbsp;terminated with a null (00H) byte.
<br>
<br>
&nbsp;■ The effect of this call is unpredictable if the file-sharing support
<br>
&nbsp; &nbsp;module is not loaded.
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the machine name of the local computer into the buffer named mname.
<br>
<br>
&nbsp;mname &nbsp; db &nbsp; &nbsp; &nbsp;16 dup (?)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,5e00h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,seg mname &nbsp; &nbsp;; address of buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,dx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset mname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;ch,ch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; make sure name exists
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jz &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if no name defined
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.1]
<br>
Function 5EH (94) Subfunction 02H
<br>
Set printer setup string
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Specifies a string to be sent in front of all files directed to a
<br>
&nbsp;particular network printer, allowing users at different network nodes to
<br>
&nbsp;specify individualized operating modes on the same printer. This function
<br>
&nbsp;call is only available when Microsoft Networks is running.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5EH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= redirection list index
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= length of setup string
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of setup string
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The redirection list index passed in register BX is obtained with
<br>
&nbsp; &nbsp;Function 5FH Subfunction 02H (Get Redirection List Entry).
<br>
<br>
&nbsp;■ See also Function 5EH Subfunction 03H, which may be used to obtain the
<br>
&nbsp; &nbsp;existing setup string for a particular network printer.
<br>
<br>
Example:
<br>
<br>
&nbsp;Initialize the setup string for the printer designated by redirection list
<br>
&nbsp;index 2 so that the device is put into boldface mode before printing a
<br>
&nbsp;file requested by this network node.
<br>
<br>
&nbsp;setup &nbsp; db &nbsp; &nbsp; &nbsp;01bh,045h &nbsp; &nbsp; &nbsp; ; selects boldface mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,5e02h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; redirection list index 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; length of setup string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,seg setup &nbsp; &nbsp;; address of setup string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset setup
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.1]
<br>
Function 5EH (94) Subfunction 03H
<br>
Get printer setup string
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the printer setup string for a particular network printer. This
<br>
&nbsp;function call is only available when Microsoft Networks is running.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5EH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= redirection list index
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer to receive setup string
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= length of printer setup string
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = address of buffer holding setup string
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The redirection list index passed in register BX is obtained with
<br>
&nbsp; &nbsp;Function 5FH Subfunction 02H (Get Redirection List Entry).
<br>
<br>
&nbsp;■ See also Int 21H Function 5EH Subfunction 02H, which is used to specify
<br>
&nbsp; &nbsp;a setup string for a network printer.
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the setup string for this network node associated with the printer
<br>
&nbsp;designated by redirection list index 2.
<br>
<br>
&nbsp;setup &nbsp; db &nbsp; &nbsp; &nbsp;64 dup (?) &nbsp; &nbsp; &nbsp;; receives setup string
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,5e03h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; redirection list index 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,seg setup &nbsp; &nbsp;; address of buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset setup
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.1]
<br>
Function 5FH (95) Subfunction 02H
<br>
Get redirection list entry
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Allows inspection of the system redirection list, which associates local
<br>
&nbsp;logical names with network files, directories, or printers. This function
<br>
&nbsp;call is only available when Microsoft Networks is running and the
<br>
&nbsp;file-sharing module (SHARE.EXE) has been loaded.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5FH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= redirection list index
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of 16-byte buffer to receive local device
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of 128-byte buffer to receive network name
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device status flag
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bit 0 &nbsp; &nbsp; = 0 if device valid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if not valid
<br>
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device type
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if printer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; if drive
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= stored parameter value
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= destroyed
<br>
&nbsp;BP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= destroyed
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ local device name
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ network name
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The parameter returned in CX is a value that was previously passed to
<br>
&nbsp; &nbsp;MS-DOS in register CX with Int 21H Function 5FH Subfunction 03H
<br>
&nbsp; &nbsp;(Redirect Device). It represents data that is private to the
<br>
&nbsp; &nbsp;applications which store and retrieve it and has no meaning to MS-DOS.
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the local and network names for the device specified by the first
<br>
&nbsp;redirection list entry.
<br>
<br>
&nbsp;local &nbsp; db &nbsp; &nbsp; &nbsp;16 dup (?) &nbsp; &nbsp; &nbsp;; receives local device name
<br>
<br>
&nbsp;network db &nbsp; &nbsp; &nbsp;128 dup (?) &nbsp; &nbsp; ; receives network name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,5f02h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; redirection list entry 0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,seg local &nbsp; &nbsp;; local name buffer addr
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset local
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,seg network &nbsp;; network name buffer addr
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset network
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if call failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or &nbsp; &nbsp; &nbsp;bh,bh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; check device status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jnz &nbsp; &nbsp; error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if device not valid
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.1]
<br>
Function 5FH (95) Subfunction 03H
<br>
Redirect device
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Establishes redirection across the network by associating a local device
<br>
&nbsp;name with a network name. This function call is only available when
<br>
&nbsp;Microsoft Networks is running and the file-sharing module (SHARE.EXE) has
<br>
&nbsp;been loaded.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5FH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device type
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if printer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; if drive
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= parameter to save for caller
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ local device name
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ network name, followed by ASCIIZ
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;password
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The local name can be a drive designator (a letter followed by a colon,
<br>
&nbsp; &nbsp;such as &quot;D:&quot;), a printer name, or a null string. Printer names must be
<br>
&nbsp; &nbsp;one of the following: PRN, LPT1, LPT2, or LPT3. If a null string
<br>
&nbsp; &nbsp;followed by a password is used, MS-DOS attempts to grant access to the
<br>
&nbsp; &nbsp;network directory with the specified password.
<br>
<br>
&nbsp;■ The parameter passed in CX can be retrieved by later calls to Int 21H
<br>
&nbsp; &nbsp;Function 5FH Subfunction 02H. It represents data that is private to the
<br>
&nbsp; &nbsp;applications which store and retrieve it and has no meaning to MS-DOS.
<br>
<br>
Example:
<br>
<br>
&nbsp;Redirect the local drive E to the directory \FORTH on the server named
<br>
&nbsp;LMI, using the password FRED.
<br>
<br>
&nbsp;locname db &nbsp; &nbsp; &nbsp;'E:',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; local drive
<br>
<br>
&nbsp;netname db &nbsp; &nbsp; &nbsp;'\\LMI\FORTH',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'FRED',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,5f03h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bl,4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; code 4 = disk drive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,seg locname &nbsp;; address of local name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset locname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,seg netname &nbsp;; address of network name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset netname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if redirect failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.1]
<br>
Function 5FH (95) Subfunction 04H
<br>
Cancel device redirection
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Cancels a previous redirection request by removing the association of a
<br>
&nbsp;local device name with a network name. This function call is only
<br>
&nbsp;available when Microsoft Networks is running and the file-sharing module
<br>
&nbsp;(SHARE.EXE) has been loaded.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5FH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ local device name
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The supplied name can be a drive designator (a letter followed by a
<br>
&nbsp; &nbsp;colon, such as &quot;D:&quot;), a printer name, or a string starting with two
<br>
&nbsp; &nbsp;backslashes (\\). Printer names must be one of the following: PRN, LPT1,
<br>
&nbsp; &nbsp;LPT2, or LPT3. If the string with two backslashes is used, the
<br>
&nbsp; &nbsp;connection between the local machine and the network directory is
<br>
&nbsp; &nbsp;terminated.
<br>
<br>
Example:
<br>
<br>
&nbsp;Cancel the redirection of local drive E to the network server.
<br>
<br>
&nbsp;locname db &nbsp; &nbsp; &nbsp;'E:',0
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; ax,5f04h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,seg locname &nbsp;; address of local name
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset locname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if cancel failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 60H (96)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 61H (97)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.0]
<br>
Function 62H (98)
<br>
Get PSP address
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the segment (paragraph) address of the program segment prefix
<br>
&nbsp;(PSP) for the currently executing program.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 62H
<br>
<br>
Returns:
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment address of program segment prefix
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Before a program receives control from MS-DOS, its program segment
<br>
&nbsp; &nbsp;prefix is set up to contain certain vital information, such as:
<br>
<br>
&nbsp; &nbsp;∙ the segment address of the program's environment block
<br>
<br>
&nbsp; &nbsp;∙ the command line originally entered by the user
<br>
<br>
&nbsp; &nbsp;∙ the original contents of the terminate, Ctrl-C, and critical-error
<br>
&nbsp; &nbsp; &nbsp;handler vectors
<br>
<br>
&nbsp; &nbsp;∙ the top address of available RAM
<br>
<br>
&nbsp;■ The segment address of the PSP is normally passed to the program in
<br>
&nbsp; &nbsp;registers DS and ES when it initially receives control from MS-DOS. This
<br>
&nbsp; &nbsp;function allows a program to conveniently recover the PSP address at any
<br>
&nbsp; &nbsp;point during its execution, without having to save it at program entry.
<br>
<br>
Example:
<br>
<br>
&nbsp;Get the segment base of the program segment prefix, then copy the command
<br>
&nbsp;tail from the PSP into the local buffer named buff.
<br>
<br>
&nbsp;ctail &nbsp; equ &nbsp; &nbsp; 080H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; PSP offset, command tail
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;80 dup (?) &nbsp; &nbsp; &nbsp;; copy of command tail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get PSP address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,62H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; copy command tail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; PSP segment to DS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset ctail ; offset of command tail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,seg buff &nbsp; &nbsp; ; local buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cl,[si] &nbsp; &nbsp; &nbsp; &nbsp; ; length of command tail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; cl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; include count byte
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; ch,ch
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cld
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rep movsb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; copy to local buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[2.25 only]
<br>
Function 63H (99)
<br>
Get DBCS lead byte table
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the address of the system table of legal lead byte ranges for
<br>
&nbsp;double-byte character sets (DBCS), or sets or obtains the interim console
<br>
&nbsp;flag. Int 21H Function 63H is available only in MS-DOS version 2.25; it
<br>
&nbsp;is not supported in MS-DOS versions 3.0 and later.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 63H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if getting address of DBCS lead byte table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if setting or clearing interim console flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if obtaining value of interim console flag
<br>
<br>
&nbsp;If AL = 01H
<br>
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if clearing interim console flag
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if setting interim console flag
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if called with AL = 00H
<br>
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of DBCS lead byte table
<br>
<br>
&nbsp;or, if called with AL = 02H
<br>
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= value of interim console flag
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The DBCS lead byte table consists of a variable number of two byte
<br>
&nbsp; &nbsp;entries, terminated by two null (00H) bytes. Each pair defines the
<br>
&nbsp; &nbsp;beginning and ending value for a range of lead bytes. The value of a
<br>
&nbsp; &nbsp;legal lead byte is always in the range 80─0FFH.
<br>
<br>
&nbsp;■ Entries in the lead byte table must be in ascending order. If no legal
<br>
&nbsp; &nbsp;lead bytes are defined in a given system, the table consists only of the
<br>
&nbsp; &nbsp;two null bytes.
<br>
<br>
&nbsp;■ If the interim console flag is set, Int 21H Functions 07H (Unfiltered
<br>
&nbsp; &nbsp;Character Input), 08H (Character Input without Echo), and 0BH
<br>
&nbsp; &nbsp;(Keyboard Status) will support interim characters.
<br>
<br>
&nbsp;■ Unlike most other MS-DOS services, this function call does not
<br>
&nbsp; &nbsp;necessarily preserve any registers except SS:SP.
<br>
<br>
&nbsp;■ [4.0] The address of the DBCS lead byte table can also be obtained with
<br>
&nbsp; &nbsp;Int 21H Function 65H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 64H (100)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.3]
<br>
Function 65H (101)
<br>
Get extended country information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains information about the specified country and/or code page.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 65H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = Get General Internationalization Information
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = Get Pointer to Uppercase Table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H = Get Pointer to Filename Uppercase Table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;06H = Get Pointer to Collating Table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;07H = Get Pointer to Double-Byte Character Set (DBCS)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Vector (MS-DOS versions 4.0 and later)
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= code page of interest (-1 = active CON device)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= length of buffer to receive information (must be &gt;= 5)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= country ID (-1 = default)
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = address of buffer to receive information
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and requested data placed in calling program's buffer
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The information returned by this function is a superset of the
<br>
&nbsp; &nbsp;information returned by Int 21H Function 38H.
<br>
<br>
&nbsp;■ This function may fail if either the country code or the code page
<br>
&nbsp; &nbsp;number is invalid, or if the code page does not match the country code.
<br>
<br>
&nbsp;■ The function fails if the specified buffer length is less than five
<br>
&nbsp; &nbsp;bytes. If the buffer to receive the information is at least five bytes
<br>
&nbsp; &nbsp;long but is too short for the requested information, the data is
<br>
&nbsp; &nbsp;truncated and no error is returned.
<br>
<br>
&nbsp;■ The format of the data returned by Subfunction 01H is:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; &nbsp; &nbsp; &nbsp;Contents
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;information ID code (1)
<br>
&nbsp; &nbsp;01H─02H &nbsp; &nbsp; &nbsp; &nbsp;length of following buffer
<br>
&nbsp; &nbsp;03H─04H &nbsp; &nbsp; &nbsp; &nbsp;country ID
<br>
&nbsp; &nbsp;05H─06H &nbsp; &nbsp; &nbsp; &nbsp;code page number
<br>
&nbsp; &nbsp;07H─08H &nbsp; &nbsp; &nbsp; &nbsp;date format
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 = USA &nbsp; &nbsp; &nbsp; &nbsp; m d y
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 = Europe &nbsp; &nbsp; &nbsp;d m y
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 = Japan &nbsp; &nbsp; &nbsp; y m d
<br>
<br>
&nbsp; &nbsp;09H─0DH &nbsp; &nbsp; &nbsp; &nbsp;ASCIIZ currency symbol
<br>
&nbsp; &nbsp;0EH─0FH &nbsp; &nbsp; &nbsp; &nbsp;ASCIIZ thousands separator
<br>
&nbsp; &nbsp;10H─11H &nbsp; &nbsp; &nbsp; &nbsp;ASCIIZ decimal separator
<br>
&nbsp; &nbsp;12H─13H &nbsp; &nbsp; &nbsp; &nbsp;ASCIIZ date separator
<br>
&nbsp; &nbsp;14H─15H &nbsp; &nbsp; &nbsp; &nbsp;ASCIIZ time separator
<br>
&nbsp; &nbsp;16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;currency format flags
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt;0 if currency symbol precedes value
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt;1 if currency symbol follows value
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt;0 if no space between value and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currency symbol
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt;1 if one space between value and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currency symbol
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt;0 if currency symbol and decimal are
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; separate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt;1 if currency symbol replaces decimal
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; separator
<br>
<br>
&nbsp; &nbsp;17H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number of digits after decimal in currency
<br>
&nbsp; &nbsp;18H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;time format
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0 if 12-hour clock
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 1 if 24-hour clock
<br>
<br>
&nbsp; &nbsp;19H─1CH &nbsp; &nbsp; &nbsp; &nbsp;case-map routine call address
<br>
&nbsp; &nbsp;1DH─1EH &nbsp; &nbsp; &nbsp; &nbsp;ASCIIZ data list separator
<br>
&nbsp; &nbsp;1FH─28H &nbsp; &nbsp; &nbsp; &nbsp;reserved
<br>
<br>
&nbsp;■ The format of the data returned by Subfunctions 02H, 04H, 06H, and 07H
<br>
&nbsp; &nbsp;is:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; &nbsp; &nbsp; &nbsp;Contents
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;information ID code (2, 4, or 6)
<br>
&nbsp; &nbsp;01H─05H &nbsp; &nbsp; &nbsp; &nbsp;double-word pointer to table
<br>
<br>
&nbsp;■ The uppercase and filename uppercase tables are a maximum of 130 bytes
<br>
&nbsp; &nbsp;long. The first two bytes contain the size of the table; the following
<br>
&nbsp; &nbsp;bytes contain the uppercase equivalents, if any, for character codes
<br>
&nbsp; &nbsp;80H─FFH. The main use of these tables is to map accented or otherwise
<br>
&nbsp; &nbsp;modified vowels to their plain vowel equivalents. Text translated with
<br>
&nbsp; &nbsp;the help of this table can be sent to devices that do not support the
<br>
&nbsp; &nbsp;IBM graphics character set, or used to create filenames that do not
<br>
&nbsp; &nbsp;require a special keyboard configuration for entry.
<br>
<br>
&nbsp;■ The collating table is a maximum of 258 bytes long. The first two bytes
<br>
&nbsp; &nbsp;contain the table length, and the subsequent bytes contain the values to
<br>
&nbsp; &nbsp;be used for the corresponding character codes (0─FFH) during a sort
<br>
&nbsp; &nbsp;operation. This table maps uppercase and lowercase ASCII characters to
<br>
&nbsp; &nbsp;the same collating codes so that sorts will be case-insensitive, and it
<br>
&nbsp; &nbsp;maps accented vowels to their plain vowel equivalents.
<br>
<br>
&nbsp;■ [4.0+] Subfunction 07H returns a pointer to a variable length table of
<br>
&nbsp; &nbsp;that defines ranges for double-byte character set (DBCS) lead bytes. The
<br>
&nbsp; &nbsp;table is terminated by a pair of zero bytes, unless it must be truncated
<br>
&nbsp; &nbsp;to fit in the buffer, and has the following format:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;start1,end1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;start2,end2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0,0
<br>
<br>
&nbsp; &nbsp;For example:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;4
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;81h,9fh
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0e0h,0fch
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0,0
<br>
<br>
&nbsp;■ In some cases a truncated translation table may be presented to the
<br>
&nbsp; &nbsp;program by MS-DOS. Applications should always check the length at the
<br>
&nbsp; &nbsp;beginning of the table, to make sure it contains a translation code for
<br>
&nbsp; &nbsp;the particular character of interest.
<br>
<br>
Examples:
<br>
<br>
&nbsp;Obtain the extended country information associated with the default
<br>
&nbsp;country and code page 437.
<br>
<br>
&nbsp;buffer &nbsp;db &nbsp; &nbsp; &nbsp;41 dup (0) &nbsp; &nbsp; &nbsp;; receives country info
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,6501h &nbsp; &nbsp; &nbsp; &nbsp;; function &amp; subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,437 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; code page
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,41 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; buffer length
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; default country
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,seg buffer &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;In this case, MS-DOS filled the following extended country information
<br>
&nbsp;into the buffer:
<br>
<br>
&nbsp;buffer &nbsp;db &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; info ID code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;38 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; length of following buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; country ID (USA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;437 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; code page number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; date format
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'$',0,0,0,0 &nbsp; &nbsp; ; currency symbol
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;',',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; thousands separator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'.',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; decimal separator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;'-',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; date separator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;':',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; time separator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; currency format flags
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; digits in currency
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; time format
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;026ah:176ch &nbsp; &nbsp; ; case map entry point
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;',',0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; data list separator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;10 dup (0) &nbsp; &nbsp; &nbsp;; reserved
<br>
<br>
&nbsp;Obtain the pointer to the uppercase table associated with the default
<br>
&nbsp;country and code page 437.
<br>
<br>
&nbsp;buffer &nbsp;db &nbsp; &nbsp; &nbsp;5 dup (0) &nbsp; &nbsp; &nbsp; ; receives pointer info
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,6502h &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,437 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; code page
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; length of buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; default country
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,seg buffer &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; es,di
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; di,offset buffer
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
&nbsp;In this case, MS-DOS filled the following values into the buffer:
<br>
<br>
&nbsp;buffer &nbsp;db &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; info ID code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;0204h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; offset of uppercase table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;1140h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; segment of uppercase table
<br>
<br>
&nbsp;and the table at 1140:0204H contains the following data:
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;8 &nbsp;9 &nbsp;A &nbsp;B &nbsp;C &nbsp;D &nbsp;E &nbsp;F &nbsp;0123456789ABCDEF
<br>
&nbsp;1140:0200 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80 00 80 9A 45 41 8E 41 8F 80 45 45 &nbsp; &nbsp; &nbsp;....EA.A..EE
<br>
&nbsp;1140:0210 &nbsp;45 49 49 49 8E 8F 90 92 92 4F 99 4F 55 55 59 99 &nbsp;EIII.....O.OUUY.
<br>
&nbsp;1140:0220 &nbsp;9A 9B 9C 9D 9E 9F 41 49 4F 55 A5 A5 A6 A7 A8 A9 &nbsp;......AIOU......
<br>
&nbsp;1140:0230 &nbsp;AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 &nbsp;................
<br>
&nbsp;1140:0240 &nbsp;BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 &nbsp;................
<br>
&nbsp;1140:0250 &nbsp;CA CB CC CD CE CF D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 &nbsp;................
<br>
&nbsp;1140:0260 &nbsp;DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 &nbsp;................
<br>
&nbsp;1140:0270 &nbsp;EA EB EC ED EE EF F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 &nbsp;................
<br>
&nbsp;1140:0280 &nbsp;FA FB FC FD FE FF &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;......
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.3]
<br>
Function 66H (102)
<br>
Get or set code page
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains or selects the current code page.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 66H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = Get Code Page
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = Select Code Page
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= code page to select, if AL = 02H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if called with AL = 01H
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= active code page
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= default code page
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ When the Select Code Page subfunction is used, MS-DOS gets the new code
<br>
&nbsp; &nbsp;page from the COUNTRY.SYS file. The device must be previously prepared
<br>
&nbsp; &nbsp;for code page switching with the appropriate DEVICE= directive in the
<br>
&nbsp; &nbsp;CONFIG.SYS file and NLSFUNC and MODE CP PREPARE commands (placed in the
<br>
&nbsp; &nbsp;AUTOEXEC.BAT file, usually).
<br>
<br>
Example:
<br>
<br>
&nbsp;Force the active code page to be the same as the system's default code
<br>
&nbsp;page, that is, restore the code page that was active when the system was
<br>
&nbsp;first booted.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get current and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; default code page
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,6601h &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; set code page
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,dx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; active = default
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,6602h &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.3]
<br>
Function 67H (103)
<br>
Set handle count
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the maximum number of files and devices that may be opened
<br>
&nbsp;simultaneously using handles by the current process.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 67H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of desired handles
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function call controls the size of the table that relates handle
<br>
&nbsp; &nbsp;numbers for the current process to MS-DOS's internal, global table for
<br>
&nbsp; &nbsp;all of the open files and devices in the system. The default table is
<br>
&nbsp; &nbsp;located in the reserved area of the process's PSP and is large enough
<br>
&nbsp; &nbsp;for 20 handles.
<br>
<br>
&nbsp;■ The function fails if the requested number of handles is greater than 20
<br>
&nbsp; &nbsp;and there is not sufficient free memory in the system to allocate a new
<br>
&nbsp; &nbsp;block to hold the enlarged table.
<br>
<br>
&nbsp;■ If the number of handles requested is larger than the available entries
<br>
&nbsp; &nbsp;in the system's global table for file and device handles (controlled by
<br>
&nbsp; &nbsp;the FILES entry in CONFIG.SYS), no error is returned. However, a
<br>
&nbsp; &nbsp;subsequent attempt to open a file or device, or create a new file, will
<br>
&nbsp; &nbsp;fail if all the entries in the system's global file table are in use,
<br>
&nbsp; &nbsp;even if the requesting process has not used up all its own handles.
<br>
<br>
Example:
<br>
<br>
&nbsp;Set the maximum handle count for the current process to thirty, so that
<br>
&nbsp;the process can have as many as 30 files or devices opened simultaneously.
<br>
&nbsp;(Five of the handles are already assigned to the standard devices when the
<br>
&nbsp;process starts up.) Note that a FILES=30 (or greater value) entry in the
<br>
&nbsp;CONFIG.SYS file would also be required for the process to successfully
<br>
&nbsp;open 30 files or devices.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,67h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,30 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; maximum number of handles
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if function failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.3]
<br>
Function 68H (104)
<br>
Commit file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Forces all data in MS-DOS's internal buffers associated with a specified
<br>
&nbsp;handle to be physically written to the device. If the handle refers to a
<br>
&nbsp;file, and the file has been modified, the time and date stamp and file
<br>
&nbsp;size in the file's directory entry are updated.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 68H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The effect of this function is equivalent to closing and reopening a
<br>
&nbsp; &nbsp;file, or to duplicating a handle for the file with Int 21H Function
<br>
&nbsp; &nbsp;45H and then closing the duplicate. However, this function has the
<br>
&nbsp; &nbsp;advantage that it will not fail due to lack of handles, and the
<br>
&nbsp; &nbsp;application does not risk losing control of the file in multitasking or
<br>
&nbsp; &nbsp;network environments.
<br>
<br>
&nbsp;■ If this function is requested for a handle associated with a character
<br>
&nbsp; &nbsp;device, a success flag is returned, but there is no other effect.
<br>
<br>
Example:
<br>
<br>
&nbsp;Assume that the file MYFILE.DAT has been previously opened and that the
<br>
&nbsp;handle for that file is stored in the variable fhandle. Call the Commit
<br>
&nbsp;File function to ensure that any data in MS-DOS's internal buffers
<br>
&nbsp;associated with the handle is written out to disk and that the directory
<br>
&nbsp;and file allocation table are up to date.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'MYFILE.DAT',0 &nbsp;; ASCIIZ filename
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,68h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,fhandle &nbsp; &nbsp; &nbsp;; file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if commit failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 69H (105)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 6AH (106)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H
<br>
Function 6BH (107)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 21H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[4.0]
<br>
Function 6CH (108)
<br>
Extended open file
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Given an ASCIIZ pathname, opens, creates or replaces a file in the
<br>
&nbsp;designated or default directory on the designated or default disk drive.
<br>
&nbsp;Returns a handle that can be used by the program for subsequent access to
<br>
&nbsp;the file.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 6CH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= open mode
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─2 &nbsp; &nbsp; &nbsp; access type
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;000 = read-only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;001 = write-only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;010 = read/write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4─6 &nbsp; &nbsp; &nbsp; sharing mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;000 = compatibility
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;001 = deny read/write (deny all)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;010 = deny write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;011 = deny read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;100 = deny none
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; inheritance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = child process inherits handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = child does not inherit handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8─12 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp;critical error handling
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = execute Int 24H
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = return error to process
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 &nbsp; &nbsp; &nbsp; &nbsp;write-through
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = writes may be buffered and deferred
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = physical write at request time
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;15 &nbsp; &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= file attribute (bits may be combined; ignored if open)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; read-only
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; hidden
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; system
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; volume label
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; archive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= open flag
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bits &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─3 &nbsp; &nbsp; &nbsp; action if file exists
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0000 = fail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0001 = open file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0010 = replace file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4─7 &nbsp; &nbsp; &nbsp; action if file doesn't exist
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0000 = fail
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0001 = create file
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of ASCIIZ pathname
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= action taken
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = file existed and was opened
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 = file did not exist and was created
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 = file existed and was replaced
<br>
<br>
&nbsp;If function failed
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The function fails if:
<br>
<br>
&nbsp; &nbsp;∙ any element of the pathname does not exist.
<br>
<br>
&nbsp; &nbsp;∙ the file is being created in the root directory and the root directory
<br>
&nbsp; &nbsp; &nbsp;is full.
<br>
<br>
&nbsp; &nbsp;∙ the file is being created and a file with the same name and the
<br>
&nbsp; &nbsp; &nbsp;read-only attribute already exists in the specified directory.
<br>
<br>
&nbsp; &nbsp;∙ the program is running on a network and the user running the program
<br>
&nbsp; &nbsp; &nbsp;has insufficient access rights.
<br>
<br>
&nbsp;■ A file is usually given a normal (0) attribute when it is created. The
<br>
&nbsp; &nbsp;file's attribute can subsequently be modified with Int 21H Function
<br>
&nbsp; &nbsp;43H.
<br>
<br>
&nbsp;■ This function combines the capabilities of Int 21H Functions 3CH, 3DH,
<br>
&nbsp; &nbsp;and 5BH. It was added to MS-DOS for compatibility with the DosOpen
<br>
&nbsp; &nbsp;function of OS/2.
<br>
<br>
Example:
<br>
<br>
&nbsp;Create the file MYFILE.DAT, if it does not already exist, in directory
<br>
&nbsp;\MYDIR on drive C, and save the handle for subsequent access to the file.
<br>
<br>
&nbsp;fname &nbsp; db &nbsp; &nbsp; &nbsp;'C:\MYDIR\MYFILE.DAT',0
<br>
<br>
&nbsp;fhandle dw &nbsp; &nbsp; &nbsp;?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ax,6c00h &nbsp; &nbsp; &nbsp; &nbsp;; function number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,4042h &nbsp; &nbsp; &nbsp; &nbsp;; read/write, deny none,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; write-through mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor &nbsp; &nbsp; cx,cx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; normal attribute
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,0010h &nbsp; &nbsp; &nbsp; &nbsp;; create if doesn't exist,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; fail if exists
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,seg fname &nbsp; &nbsp;; address of pathname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,si
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; si,offset fname
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; transfer to MS-DOS
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if open failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; fhandle,ax &nbsp; &nbsp; &nbsp;; save file handle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 22H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Terminate handler address
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The machine interrupt vector for Int 22H (memory locations 0000:0088H
<br>
&nbsp;through 0000:008BH) contains the address of the routine that receives
<br>
&nbsp;control when the currently executing program terminates via Int 20H, Int
<br>
&nbsp;27H, or Int 21H Functions 00H, 31H, or 4CH. The address in this vector
<br>
&nbsp;is also copied into offsets 0AH through 0DH of the program segment prefix
<br>
&nbsp;(PSP) when a program is loaded but before it begins executing, and is
<br>
&nbsp;restored from the PSP (in case it was modified by the application) as part
<br>
&nbsp;of MS-DOS's termination handling.
<br>
<br>
&nbsp;This interrupt should never be issued directly.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 23H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Ctrl-C handler address
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The machine interrupt vector for Int 23H (memory locations 0000:008CH
<br>
&nbsp;though 0000:008FH) contains the address of the routine which receives
<br>
&nbsp;control when a Ctrl-C is detected during any character I/O function and,
<br>
&nbsp;if the Break flag is ON, during most other MS-DOS function calls. The
<br>
&nbsp;address in this vector is also copied into locations 0EH through 11H of
<br>
&nbsp;the program segment prefix (PSP) when a program is loaded but before it
<br>
&nbsp;begins executing, and is restored from the PSP (in case it was modified by
<br>
&nbsp;the application) as part of MS-DOS's termination handling.
<br>
<br>
&nbsp;This interrupt should never be issued directly.
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The initialization code for an application can use Int 21H Function
<br>
&nbsp; &nbsp;25H to reset the Interrupt 23H vector to point to its own routine for
<br>
&nbsp; &nbsp;Ctrl-C handling. In this way, the program can avoid being terminated
<br>
&nbsp; &nbsp;unexpectedly as the result of the user's entry of a Ctrl-C or
<br>
&nbsp; &nbsp;Ctrl-Break.
<br>
<br>
&nbsp;■ When a Ctrl-C is detected and the program's Int 23H handler receives
<br>
&nbsp; &nbsp;control, all registers are set to their values at the point of the
<br>
&nbsp; &nbsp;original function call. The handler can then do any of the following:
<br>
<br>
&nbsp; &nbsp;∙ Set a local flag for later inspection by the application, or take any
<br>
&nbsp; &nbsp; &nbsp;other appropriate action, and perform an IRET. All registers must be
<br>
&nbsp; &nbsp; &nbsp;preserved. The MS-DOS function in progress will be restarted from
<br>
&nbsp; &nbsp; &nbsp;scratch and will proceed to completion, control finally returning to
<br>
&nbsp; &nbsp; &nbsp;the application in the normal manner.
<br>
<br>
&nbsp; &nbsp;∙ Take appropriate action and then perform a RET FAR to give control
<br>
&nbsp; &nbsp; &nbsp;back to MS-DOS. The state of the carry flag is used by MS-DOS to
<br>
&nbsp; &nbsp; &nbsp;determine what action to take. If the carry flag is set, the
<br>
&nbsp; &nbsp; &nbsp;application will be terminated; if the carry flag is clear, the
<br>
&nbsp; &nbsp; &nbsp;application will continue in the normal manner.
<br>
<br>
&nbsp; &nbsp;∙ Retain control by transferring to an error-handling routine within the
<br>
&nbsp; &nbsp; &nbsp;application and then resume execution or take other appropriate
<br>
&nbsp; &nbsp; &nbsp;action, never performing a RET FAR or IRET to end the
<br>
&nbsp; &nbsp; &nbsp;interrupt-handling sequence. This option will cause no harm to the
<br>
&nbsp; &nbsp; &nbsp;system.
<br>
<br>
&nbsp;■ Any MS-DOS function call may be used within the body of an Int 23H
<br>
&nbsp; &nbsp;handler.
<br>
<br>
Example:
<br>
<br>
&nbsp;See Chapter 5.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 24H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Critical-error handler address
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The machine interrupt vector for Int 24H (memory locations 0000:0090H
<br>
&nbsp;through 0000:0093H) contains the address of the routine that receives
<br>
&nbsp;control when a critical error (usually a hardware error) is detected. This
<br>
&nbsp;address is also copied into locations 12H through 15H of the program
<br>
&nbsp;segment prefix (PSP) when a program is loaded but before it begins
<br>
&nbsp;executing, and is restored from the PSP (in case it was modified by the
<br>
&nbsp;application) as part of MS-DOS's termination handling.
<br>
<br>
&nbsp;This interrupt should never be issued directly.
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ On entry to the critical-error interrupt handler, bit 7 of register AH
<br>
&nbsp; &nbsp;is clear (0) if the error was a disk I/O error; otherwise, it is set
<br>
&nbsp; &nbsp;(1). BP:SI contains the address of a device-driver header from which
<br>
&nbsp; &nbsp;additional information can be obtained. Interrupts are disabled. The
<br>
&nbsp; &nbsp;registers will be set up for a retry operation, and an error code will
<br>
&nbsp; &nbsp;be in the lower half of the DI register, with the upper half undefined.
<br>
<br>
&nbsp; &nbsp;The lower byte of DI contains:
<br>
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;write-protect error
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unknown unit
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;drive not ready
<br>
&nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unknown command
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data error (CRC)
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bad request structure length
<br>
&nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;seek error
<br>
&nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unknown media type
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sector not found
<br>
&nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printer out of paper
<br>
&nbsp; &nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;write fault
<br>
&nbsp; &nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;read fault
<br>
&nbsp; &nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;general failure
<br>
&nbsp; &nbsp;0DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reserved
<br>
&nbsp; &nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reserved
<br>
&nbsp; &nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invalid disk change (MS-DOS version 3 only)
<br>
<br>
&nbsp; &nbsp;Note that these are the same error codes returned by the device driver
<br>
&nbsp; &nbsp;in the request header. Also, upon entry, the stack is set up as shown in
<br>
&nbsp; &nbsp;Figure 8-8, page 149.
<br>
<br>
&nbsp;■ When a disk I/O error occurs, MS-DOS automatically retries the operation
<br>
&nbsp; &nbsp;before issuing a critical-error Int 24H. The number of retries varies
<br>
&nbsp; &nbsp;in different versions of MS-DOS, but is typically in the range three to
<br>
&nbsp; &nbsp;five.
<br>
<br>
&nbsp;■ Int 24H handlers must preserve the SS, SP, DS, ES, BX, CX, and DX
<br>
&nbsp; &nbsp;registers. Only Int 21H Functions 01H─0CH and 59H can be used by an
<br>
&nbsp; &nbsp;Int 24H handler; other function calls will destroy the MS-DOS stack and
<br>
&nbsp; &nbsp;its ability to retry or ignore an error.
<br>
<br>
&nbsp;■ When the Int 24H handler issues an IRET, it should return an action code
<br>
&nbsp; &nbsp;in AL that will be interpreted by DOS as follows:
<br>
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ignore the error
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;retry the operation
<br>
&nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;terminate the program
<br>
&nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.0+] fail the function call in progress
<br>
<br>
&nbsp;■ If the Int 24H handler returns control directly to the application
<br>
&nbsp; &nbsp;program rather than to MS-DOS, it must restore the program's registers,
<br>
&nbsp; &nbsp;removing all but the last three words from the stack, and issue an IRET.
<br>
&nbsp; &nbsp;Control returns to the instruction immediately following the function
<br>
&nbsp; &nbsp;call that caused the error. This option leaves MS-DOS in an unstable
<br>
&nbsp; &nbsp;state until a call to an Int 21H function higher than Function 0CH is
<br>
&nbsp; &nbsp;made.
<br>
<br>
Example:
<br>
<br>
&nbsp;See Chapter 8.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 25H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Absolute disk read
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Provides a direct linkage to the MS-DOS BIOS module to read data from a
<br>
&nbsp;logical disk sector into memory.
<br>
<br>
Call with:
<br>
<br>
&nbsp;For access to partitions &lt;= 32 MB
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive number (0 = A, 1 = B, etc)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors to read
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= starting sector number
<br>
&nbsp;DS:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
&nbsp;For access to partitions &gt; 32 MB (MS-DOS 4.0 and later)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive number (0 = A, 1 = B, etc)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= -1
<br>
&nbsp;DS:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of parameter block (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code (see Notes)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ All registers except the segment registers may be destroyed.
<br>
<br>
&nbsp;■ When this function returns, the CPU flags originally pushed on the stack
<br>
&nbsp; &nbsp;by the INT 25H instruction are still on the stack. The stack must be
<br>
&nbsp; &nbsp;cleared by a POPF or ADD SP,2 to prevent uncontrolled stack growth and
<br>
&nbsp; &nbsp;to make accessible any other values that were pushed on the stack before
<br>
&nbsp; &nbsp;the call to INT 25H.
<br>
<br>
&nbsp;■ Logical sector numbers are obtained by numbering each disk sector
<br>
&nbsp; &nbsp;sequentially from cylinder 0, head 0, sector 1, and continuing until the
<br>
&nbsp; &nbsp;last sector on the disk is counted. The head number is incremented
<br>
&nbsp; &nbsp;before the track number. Logically adjacent sectors may not be
<br>
&nbsp; &nbsp;physically adjacent, due to interleaving that occurs at the
<br>
&nbsp; &nbsp;device-adapter level for some disk types.
<br>
<br>
&nbsp;■ The error code is interpreted as follows: The lower byte (AL) is the
<br>
&nbsp; &nbsp;same error code that is returned in the lower byte of DI when an Int 24H
<br>
&nbsp; &nbsp;is issued. The upper byte (AH) contains:
<br>
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if bad command
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if bad address mark
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if requested sector not found
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if direct memory access (DMA) failure
<br>
&nbsp; &nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if data error (bad CRC)
<br>
&nbsp; &nbsp;20H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if controller failed
<br>
&nbsp; &nbsp;40H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if seek operation failed
<br>
&nbsp; &nbsp;80H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if attachment failed to respond
<br>
<br>
&nbsp;■ [4.0+] When accessing partitions larger than 32 MB under MS-DOS version
<br>
&nbsp; &nbsp;4, this function uses a parameter block with the following format:
<br>
<br>
&nbsp; &nbsp;Bytes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Description
<br>
&nbsp; &nbsp;00H─03H &nbsp; &nbsp; &nbsp; &nbsp;32-bit sector number
<br>
&nbsp; &nbsp;04H─05H &nbsp; &nbsp; &nbsp; &nbsp;number of sectors to read
<br>
&nbsp; &nbsp;06H─07H &nbsp; &nbsp; &nbsp; &nbsp;offset of buffer
<br>
&nbsp; &nbsp;08H─09H &nbsp; &nbsp; &nbsp; &nbsp;segment of buffer
<br>
<br>
Example:
<br>
<br>
&nbsp;Read logical sector 1 of drive A into the memory area named buff. (On most
<br>
&nbsp;MS-DOS floppy disks, this sector contains the beginning of the file
<br>
&nbsp;allocation table.)
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;512 dup (?) &nbsp; &nbsp; ; receives data from disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive A
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; number of sectors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; beginning sector number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,seg buff &nbsp; &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 25h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; request disk read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if read failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; sp,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; clear stack
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 26H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Absolute disk write
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Provides a direct linkage to the MS-DOS BIOS module to write data from
<br>
&nbsp;memory to a logical disk sector.
<br>
<br>
Call with:
<br>
<br>
&nbsp;For access to partitions &lt;= 32 MB
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive number (0 = A, 1 = B, etc)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors to write
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= starting sector number
<br>
&nbsp;DS:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
&nbsp;For access to partitions &gt; 32 MB (MS-DOS 4.0 and later)
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive number (0 = A, 1 = B, etc)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= -1
<br>
&nbsp;DS:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of parameter block (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code (see Notes)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ All registers except the segment registers may be destroyed.
<br>
<br>
&nbsp;■ When this function returns, the CPU flags originally pushed onto the
<br>
&nbsp; &nbsp;stack by the INT 26H instruction are still on the stack. The stack must
<br>
&nbsp; &nbsp;be cleared by a POPF or ADD SP,2 to prevent uncontrolled stack growth
<br>
&nbsp; &nbsp;and to make accessible any other values that were pushed on the stack
<br>
&nbsp; &nbsp;before the call to INT 26H.
<br>
<br>
&nbsp;■ Logical sector numbers are obtained by numbering each disk sector
<br>
&nbsp; &nbsp;sequentially from cylinder 0, head 0, sector 1, and continuing until the
<br>
&nbsp; &nbsp;last sector on the disk is counted. The head number is incremented
<br>
&nbsp; &nbsp;before the track number. Logically adjacent sectors may not be
<br>
&nbsp; &nbsp;physically adjacent, due to interleaving that occurs at the
<br>
&nbsp; &nbsp;device-adapter level for some disk types.
<br>
<br>
&nbsp;■ The error code is interpreted as follows: The lower byte (AL) is the
<br>
&nbsp; &nbsp;same error code that is returned in the lower byte of DI when an Int
<br>
&nbsp; &nbsp;24H is issued. The upper byte (AH) contains:
<br>
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if bad command
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if bad address mark
<br>
&nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if write-protect fault
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if requested sector not found
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if direct memory access (DMA) failure
<br>
&nbsp; &nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if data error (bad CRC)
<br>
&nbsp; &nbsp;20H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if controller failed
<br>
&nbsp; &nbsp;40H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if seek operation failed
<br>
&nbsp; &nbsp;80H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if attachment failed to respond
<br>
<br>
&nbsp;■ [4.0+] When accessing partitions larger than 32 MB under MS-DOS version
<br>
&nbsp; &nbsp;4, this function uses a parameter block with the following format:
<br>
<br>
&nbsp; &nbsp;Bytes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Description
<br>
&nbsp; &nbsp;00H─03H &nbsp; &nbsp; &nbsp; &nbsp;32-bit sector number
<br>
&nbsp; &nbsp;04H─05H &nbsp; &nbsp; &nbsp; &nbsp;number of sectors to read
<br>
&nbsp; &nbsp;06H─07H &nbsp; &nbsp; &nbsp; &nbsp;offset of buffer
<br>
&nbsp; &nbsp;08H─09H &nbsp; &nbsp; &nbsp; &nbsp;segment of buffer
<br>
<br>
Example:
<br>
<br>
&nbsp;Write the contents of the memory area named buff into logical sector 3 of
<br>
&nbsp;drive C.
<br>
<br>
&nbsp;Warning: Verbatim use of the following code could damage the file system
<br>
&nbsp;on your fixed disk. There is, unfortunately, no way to provide a really
<br>
&nbsp;safe example of this function.
<br>
<br>
&nbsp;buff &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;512 dup (?) &nbsp; &nbsp; ; contains data for write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; drive C
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; cx,1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; number of sectors
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; beginning sector number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,seg buff &nbsp; &nbsp; ; buffer address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ds,bx
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,offset buff
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 26h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; request disk write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; jump if write failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; sp,2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; clear stack
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 27H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[1.0]
<br>
Terminate and stay resident
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Terminates execution of the currently executing program, but reserves part
<br>
&nbsp;or all of its memory so that it will not be overlaid by the next transient
<br>
&nbsp;program to be loaded. MS-DOS then takes the following actions:
<br>
<br>
&nbsp;■ File buffers are flushed and any open handles for files or devices owned
<br>
&nbsp; &nbsp;by the process are closed.
<br>
<br>
&nbsp;■ The termination handler vector (Int 22H) is restored from PSP:000AH.
<br>
<br>
&nbsp;■ The Ctrl-C handler vector (Int 23H) is restored from PSP:000EH.
<br>
<br>
&nbsp;■ [2.0+] The critical-error handler vector (Int 24H) is restored from
<br>
&nbsp; &nbsp;PSP:0012H.
<br>
<br>
&nbsp;■ Control is transferred to the termination handler.
<br>
<br>
&nbsp;If the program is returning to COMMAND.COM, control transfers to the
<br>
&nbsp;resident portion and the transient portion is reloaded if necessary. If a
<br>
&nbsp;batch file is in progress, the next line of the file is fetched and
<br>
&nbsp;interpreted; otherwise a prompt is issued for the next user command.
<br>
<br>
Call with:
<br>
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= offset of the last byte plus one (relative to the program
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;segment prefix)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of program to be protected
<br>
&nbsp;CS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment of program segment prefix
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function call is typically used to allow user-written utilities,
<br>
&nbsp; &nbsp;drivers, or interrupt handlers to be loaded as ordinary .COM or .EXE
<br>
&nbsp; &nbsp;programs, then remain resident. Subsequent entrance to the code is via a
<br>
&nbsp; &nbsp;hardware or software interrupt.
<br>
<br>
&nbsp;■ This function attempts to set the initial memory allocation block to the
<br>
&nbsp; &nbsp;length in bytes specified in register DX. If other memory blocks have
<br>
&nbsp; &nbsp;been requested by the application via Int 21H Function 48H, they will
<br>
&nbsp; &nbsp;not be released by this function.
<br>
<br>
&nbsp;■ Other methods of performing a final exit are:
<br>
<br>
&nbsp; &nbsp;∙ Int 20H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 00H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 31H
<br>
<br>
&nbsp; &nbsp;∙ Int 21H Function 4CH
<br>
<br>
&nbsp;■ This function should not be called by .EXE programs that are loaded at
<br>
&nbsp; &nbsp;the high end of the transient program area (i.e., linked with the /HIGH
<br>
&nbsp; &nbsp;switch), because doing so reserves the memory normally used by the
<br>
&nbsp; &nbsp;transient part of COMMAND.COM. If COMMAND.COM cannot be reloaded, the
<br>
&nbsp; &nbsp;system will fail.
<br>
<br>
&nbsp;■ This function does not work correctly when DX contains values in the
<br>
&nbsp; &nbsp;range 0FFF1H─0FFFFH. In this case, MS-DOS discards the high bit of the
<br>
&nbsp; &nbsp;value in DX, resulting in the reservation of 32 KB less memory than was
<br>
&nbsp; &nbsp;requested by the program.
<br>
<br>
&nbsp;■ [2.0+] Int 21H Function 31H should be used in preference to this
<br>
&nbsp; &nbsp;function, because it supports return codes, allows larger amounts of
<br>
&nbsp; &nbsp;memory to be reserved, and does not require CS to contain the segment of
<br>
&nbsp; &nbsp;the program segment prefix.
<br>
<br>
&nbsp;■ [3.0+] If the program is running on a network, it should remove all
<br>
&nbsp; &nbsp;locks it has placed on file regions before terminating.
<br>
<br>
Example:
<br>
<br>
&nbsp;Terminate and stay resident, reserving enough memory to contain the entire
<br>
&nbsp;program.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; dx,offset pend &nbsp;; DX = bytes to reserve
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 27h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; terminate, stay resident
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.
<br>
&nbsp;pend &nbsp; &nbsp;equ &nbsp; &nbsp; $ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; offset, end of program
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 28H
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 29H
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 2AH
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 2BH
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 2CH
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 2DH
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 2EH
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 2FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.0]
<br>
Multiplex interrupt
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Provides a general-purpose avenue of communication with another process or
<br>
&nbsp;with MS-DOS extensions, such as the print spooler, ASSIGN, SHARE, and
<br>
&nbsp;APPEND. The multiplex number in register AH specifies the process or
<br>
&nbsp;extension being communicated with. The range 00H─BFH is reserved for
<br>
&nbsp;MS-DOS; applications may use the range C0H─FFH.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 2FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.0]
<br>
Function 01H
<br>
Print spooler
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Submits a file to the print spooler, removes a file from the print
<br>
&nbsp;spooler's queue of pending files, or obtains the status of the printer.
<br>
&nbsp;The print spooler, which is contained in the file PRINT.COM, was first
<br>
&nbsp;added to MS-DOS in version 2.0, but the application program interface to
<br>
&nbsp;the spooler was not documented until MS-DOS version 3.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = Get Installed State
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = Submit File to be Printed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = Remove File from Print Queue
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H = Cancel All Files in Queue
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H = Hold Print Jobs for Status Read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H = Release Hold
<br>
&nbsp;DS:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of packet (Subfunction 01H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;segment:offset of ASCIIZ pathname (Subfunction 02H)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if called with AL = 00H
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= print spooler state
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if not installed, ok to install
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if not installed, not ok to install
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; if installed
<br>
<br>
&nbsp;or, if called with AL = 04H
<br>
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error count
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of print queue file list
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The packet passed to Subfunction 01H consists of five bytes. The first
<br>
&nbsp; &nbsp;byte contains the level, which should be 00H for current versions of
<br>
&nbsp; &nbsp;MS-DOS. The following four bytes contain the segment:offset of an ASCIIZ
<br>
&nbsp; &nbsp;pathname, which may not include wildcard characters. If the specified
<br>
&nbsp; &nbsp;file exists, it is added to the print queue.
<br>
<br>
&nbsp;■ The * and ? wildcard characters may be included in a pathname passed to
<br>
&nbsp; &nbsp;Subfunction 02H, making it possible to delete multiple files from the
<br>
&nbsp; &nbsp;print queue with one call.
<br>
<br>
&nbsp;■ The address returned by Subfunction 04H points to a list of 64-byte
<br>
&nbsp; &nbsp;entries, each containing an ASCIIZ pathname. The first pathname in the
<br>
&nbsp; &nbsp;list is the file currently being printed. The last entry in the list is
<br>
&nbsp; &nbsp;a null string (a single 00H byte).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 2FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.2]
<br>
Function 02H
<br>
ASSIGN
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a code indicating whether the resident portion of the ASSIGN
<br>
&nbsp;utility has been loaded.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = Get Installed State
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= ASSIGN installed status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if not installed, ok to install
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if not installed, not ok to install
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; if installed
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 2FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.2]
<br>
Function 10H (16)
<br>
SHARE
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a code indicating whether the SHARE.EXE file-sharing module has
<br>
&nbsp;been loaded.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = Get Installed State
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= SHARE installed status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if not installed, ok to install
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if not installed, not ok to install
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; if installed
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 2FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[3.3]
<br>
Function B7H (183)
<br>
APPEND
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Allows an application to test whether APPEND has been installed. If APPEND
<br>
&nbsp;is resident, returns the APPEND version, state, and the path used to
<br>
&nbsp;search for data files.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= B7H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = Get Installed State
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = Get Append Version (4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H = Get Append Path Pointer (4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;06H = Get Append Function State (4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;07H = Set Append Function State (4.0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11H = Set Return Found Name State (4.0, see Note)
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= APPEND state (if AL = 07H)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; APPEND enabled
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1─12 &nbsp; &nbsp; &nbsp;Reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp;/PATH switch active
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 &nbsp; &nbsp; &nbsp; &nbsp;/E switch active
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;15 &nbsp; &nbsp; &nbsp; &nbsp;/X switch active
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if called with AL = 00H
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= APPEND installed status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if not installed, ok to install
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if not installed, not ok to install
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; if installed
<br>
<br>
&nbsp;or, if called with AL = 02H (MS-DOS 4.0)
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFFFH if MS-DOS 4.0 APPEND
<br>
<br>
&nbsp;or, if called with AL = 04H (MS-DOS 4.0)
<br>
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of active APPEND path
<br>
<br>
&nbsp;or, if called with AL = 06H (MS-DOS 4.0)
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= APPEND state (see above)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ If the Return Found Name State is set with Subfunction 11H, the fully
<br>
&nbsp; &nbsp;qualified filename is returned to the next application to call Int 21H
<br>
&nbsp; &nbsp;Function 3DH, 43H, or 6CH. The name is placed at the same address as the
<br>
&nbsp; &nbsp;ASCIIZ parameter string for the Int 21H function, so the application
<br>
&nbsp; &nbsp;must be sure to provide a buffer of adequate size. The Return Found Name
<br>
&nbsp; &nbsp;State is reset after APPEND processes one Int 21H function call.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
SECTION 3 &nbsp;IBM ROM BIOS AND MOUSE FUNCTIONS REFERENCE
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
Notes to the Reader
<br>
<br>
&nbsp;In the headers for ROM BIOS video driver (Int 10H) function calls, the
<br>
&nbsp;following icons are used:
<br>
<br>
&nbsp;[MDA] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Monochrome Display Adapter
<br>
&nbsp;[CGA] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Color/Graphics Adapter
<br>
&nbsp;[PCjr] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PCjr system board video controller
<br>
&nbsp;[EGA] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Enhanced Graphics Adapter
<br>
&nbsp;[MCGA] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Multi-Color Graphics Array (PS/2 Models 25 &amp; 30)
<br>
&nbsp;[VGA] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Video Graphics Array (PS/2 Models 50 and above)
<br>
<br>
&nbsp;In the remainder of this section, the following icons are used:
<br>
<br>
&nbsp;[PC] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Original IBM PC, PC/XT, and PCjr, unless
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherwise noted.
<br>
&nbsp;[AT] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PC/AT and PC/XT-286, unless otherwise noted.
<br>
&nbsp;[PS/2] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; All PS/2 models (including Models 25 and 30),
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unless otherwise noted.
<br>
<br>
&nbsp;ROM BIOS functions that are unique to the PC Convertible have been
<br>
&nbsp;omitted.
<br>
<br>
&nbsp;Some functions are supported only in very late revisions of a particular
<br>
&nbsp;machine's ROM BIOS (such as Int 1AH Functions 00H and 01H on the PC/XT).
<br>
&nbsp;In general, such functions are not given an icon for that machine since a
<br>
&nbsp;program could not safely assume that they were available based on the
<br>
&nbsp;machine ID byte(s).
<br>
<br>
<br>
Summary of ROM BIOS and Mouse Function Calls
<br>
<br>
<br>
&nbsp;Int &nbsp; &nbsp;Function &nbsp; &nbsp; Subfunction &nbsp; Name
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Video Driver
<br>
&nbsp;10H &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Video Mode
<br>
&nbsp;10H &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Cursor Type
<br>
&nbsp;10H &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Cursor Position
<br>
&nbsp;10H &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Cursor Position
<br>
&nbsp;10H &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Light Pen Position
<br>
&nbsp;10H &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Display Page
<br>
&nbsp;10H &nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Initialize or Scroll Window Up
<br>
&nbsp;10H &nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Initialize or Scroll Window Down
<br>
&nbsp;10H &nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read Character and Attribute at Cursor
<br>
&nbsp;10H &nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write Character and Attribute at Cursor
<br>
&nbsp;10H &nbsp; &nbsp;0AH (10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write Character at Cursor
<br>
&nbsp;10H &nbsp; &nbsp;0BH (11) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Palette, Background, or Border
<br>
&nbsp;10H &nbsp; &nbsp;0CH (12) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write Graphics Pixel
<br>
&nbsp;10H &nbsp; &nbsp;0DH (13) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Read Graphics Pixel
<br>
&nbsp;10H &nbsp; &nbsp;0EH (14) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write Character in Teletype Mode
<br>
&nbsp;10H &nbsp; &nbsp;0FH (15) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Video Mode
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Palette Register
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Border Color
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Palette and Border
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Toggle Blink/Intensity Bit
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Palette Register
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Border Color
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Palette and Border
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 10H (16) &nbsp; &nbsp; Set Color Register
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 12H (18) &nbsp; &nbsp; Set Block of Color Registers
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 13H (19) &nbsp; &nbsp; Set Color Page State
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 15H (21) &nbsp; &nbsp; Get Color Register
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 17H (23) &nbsp; &nbsp; Get Block of Color Registers
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 1AH (26) &nbsp; &nbsp; Get Color Page State
<br>
&nbsp;10H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; 1BH (27) &nbsp; &nbsp; Set Gray-Scale Values
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Load User Font
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Load ROM 8-by-14 Font
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Load ROM 8-by-8 Font
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Block Specifier
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Load ROM 8-by-16 Font
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 10H (16) &nbsp; &nbsp; Load User Font, Reprogram Controller
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 11H (17) &nbsp; &nbsp; Load ROM 8-by-14 Font, Reprogram
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Controller
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 12H (18) &nbsp; &nbsp; Load ROM 8-by-8 Font, Reprogram
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Controller
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 14H (20) &nbsp; &nbsp; Load ROM 8-by-16 Font, Reprogram
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Controller
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 20H (32) &nbsp; &nbsp; Set Int 1FH Pointer
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 21H (33) &nbsp; &nbsp; Set Int 43H for User's Font
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 22H (34) &nbsp; &nbsp; Set Int 43H for ROM 8-by-14 Font
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 23H (35) &nbsp; &nbsp; Set Int 43H for ROM 8-by-8 Font
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 24H (36) &nbsp; &nbsp; Set Int 43H for Rom 8-by-16 Font
<br>
&nbsp;10H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; 30H (48) &nbsp; &nbsp; Get Font Information
<br>
&nbsp;10H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; 10H (16) &nbsp; &nbsp; Get Configuration Information
<br>
&nbsp;10H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; 20H (32) &nbsp; &nbsp; Select Alternate PrintScreen
<br>
&nbsp;10H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; 30H (48) &nbsp; &nbsp; Set Scan Lines
<br>
&nbsp;10H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; 31H (49) &nbsp; &nbsp; Enable/Disable Palette Loading
<br>
&nbsp;10H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; 32H (50) &nbsp; &nbsp; Enable/Disable Video
<br>
&nbsp;10H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; 33H (51) &nbsp; &nbsp; Enable/Disable Gray-Scale Summing
<br>
&nbsp;10H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; 34H (52) &nbsp; &nbsp; Enable/Disable Cursor Emulation
<br>
&nbsp;10H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; 35H (53) &nbsp; &nbsp; Switch Active Display
<br>
&nbsp;10H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; 36H (54) &nbsp; &nbsp; Enable/Disable Screen Refresh
<br>
&nbsp;10H &nbsp; &nbsp;13H (19) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write String in Teletype Mode
<br>
&nbsp;10H &nbsp; &nbsp;1AH (26) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get or Set Display Combination Code
<br>
&nbsp;10H &nbsp; &nbsp;1BH (27) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Functionality/State Information
<br>
&nbsp;10H &nbsp; &nbsp;1CH (28) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Save or Restore Video State
<br>
&nbsp;11H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Equipment Configuration
<br>
&nbsp;12H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Conventional Memory Size
<br>
&nbsp;13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Disk Driver
<br>
&nbsp;13H &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reset Disk System
<br>
&nbsp;13H &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Disk System Status
<br>
&nbsp;13H &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read Sector
<br>
&nbsp;13H &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write Sector
<br>
&nbsp;13H &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Verify Sector
<br>
&nbsp;13H &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Format Track
<br>
&nbsp;13H &nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Format Bad Track
<br>
&nbsp;13H &nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Format Drive
<br>
&nbsp;13H &nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Drive Parameters
<br>
&nbsp;13H &nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Initialize Fixed Disk Characteristics
<br>
&nbsp;13H &nbsp; &nbsp;0AH (10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Read Sector Long
<br>
&nbsp;13H &nbsp; &nbsp;0BH (11) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write Sector Long
<br>
&nbsp;13H &nbsp; &nbsp;0CH (12) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Seek
<br>
&nbsp;13H &nbsp; &nbsp;0DH (13) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reset Fixed Disk System
<br>
&nbsp;13H &nbsp; &nbsp;0EH (14) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Read Sector Buffer
<br>
&nbsp;13H &nbsp; &nbsp;0FH (15) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write Sector Buffer
<br>
&nbsp;13H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Drive Status
<br>
&nbsp;13H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Recalibrate Drive
<br>
&nbsp;13H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Controller RAM Diagnostic
<br>
&nbsp;13H &nbsp; &nbsp;13H (19) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Controller Drive Diagnostic
<br>
&nbsp;13H &nbsp; &nbsp;14H (20) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Controller Internal Diagnostic
<br>
&nbsp;13H &nbsp; &nbsp;15H (21) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Disk Type
<br>
&nbsp;13H &nbsp; &nbsp;16H (22) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Disk Change Status
<br>
&nbsp;13H &nbsp; &nbsp;17H (23) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Disk Type
<br>
&nbsp;13H &nbsp; &nbsp;18H (24) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Media Type for Format
<br>
&nbsp;13H &nbsp; &nbsp;19H (25) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Park Heads
<br>
&nbsp;13H &nbsp; &nbsp;1AH (26) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Format ESDI Drive
<br>
&nbsp;14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Serial Communications Port Driver
<br>
&nbsp;14H &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Initialize Communications Port
<br>
&nbsp;14H &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write Character to Communications Port
<br>
&nbsp;14H &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read Character from Communications Port
<br>
&nbsp;14H &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Communications Port Status
<br>
&nbsp;14H &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Extended Initialize Communications Port
<br>
&nbsp;14H &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Extended Communications Port Control
<br>
&nbsp;15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; I/O Subsystem Extensions
<br>
&nbsp;15H &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Turn On Cassette Motor
<br>
&nbsp;15H &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Turn Off Cassette Motor
<br>
&nbsp;15H &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read Cassette
<br>
&nbsp;15H &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write Cassette
<br>
&nbsp;15H &nbsp; &nbsp;0FH (15) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Format ESDI Drive Periodic Interrupt
<br>
&nbsp;15H &nbsp; &nbsp;21H (33) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Read POST Error Log
<br>
&nbsp;15H &nbsp; &nbsp;21H (33) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write POST Error Log
<br>
&nbsp;15H &nbsp; &nbsp;4FH (79) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Keyboard Intercept
<br>
&nbsp;15H &nbsp; &nbsp;80H (128) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Device Open
<br>
&nbsp;15H &nbsp; &nbsp;81H (129) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Device Close
<br>
&nbsp;15H &nbsp; &nbsp;82H (130) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Process Termination
<br>
&nbsp;15H &nbsp; &nbsp;83H (131) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Event Wait
<br>
&nbsp;15H &nbsp; &nbsp;84H (132) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read Joystick
<br>
&nbsp;15H &nbsp; &nbsp;85H (133) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SysReq Key
<br>
&nbsp;15H &nbsp; &nbsp;86H (134) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Delay
<br>
&nbsp;15H &nbsp; &nbsp;87H (135) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Move Extended Memory Block
<br>
&nbsp;15H &nbsp; &nbsp;88H (136) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Extended Memory Size
<br>
&nbsp;15H &nbsp; &nbsp;89H (137) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Enter Protected Mode
<br>
&nbsp;15H &nbsp; &nbsp;90H (144) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Device Wait
<br>
&nbsp;15H &nbsp; &nbsp;91H (145) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Device Post
<br>
&nbsp;15H &nbsp; &nbsp;C0H (192) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get System Environment
<br>
&nbsp;15H &nbsp; &nbsp;C1H (193) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Address of Extended BIOS Data Area
<br>
&nbsp;15H &nbsp; &nbsp;C2H (194) &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Enable/Disable Pointing Device
<br>
&nbsp;15H &nbsp; &nbsp;C2H (194) &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reset Pointing Device
<br>
&nbsp;15H &nbsp; &nbsp;C2H (194) &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Sample Rate
<br>
&nbsp;15H &nbsp; &nbsp;C2H (194) &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Resolution
<br>
&nbsp;15H &nbsp; &nbsp;C2H (194) &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Pointing Device Type
<br>
&nbsp;15H &nbsp; &nbsp;C2H (194) &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Initialize Pointing Device Interface
<br>
&nbsp;15H &nbsp; &nbsp;C2H (194) &nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Scaling or Get Status
<br>
&nbsp;15H &nbsp; &nbsp;C2H (194) &nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Pointing Device Handler Address
<br>
&nbsp;15H &nbsp; &nbsp;C3H (195) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Watchdog Time-Out
<br>
&nbsp;15H &nbsp; &nbsp;C4H (196) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Programmable Option Select
<br>
&nbsp;16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Keyboard Driver
<br>
&nbsp;16H &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Read Character from Keyboard
<br>
&nbsp;16H &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Keyboard Status
<br>
&nbsp;16H &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Keyboard Flags
<br>
&nbsp;16H &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Repeat Rate
<br>
&nbsp;16H &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Keyclick
<br>
&nbsp;16H &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Push Character and Scan Code
<br>
&nbsp;16H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Read Character from Enhanced Keyboard
<br>
&nbsp;16H &nbsp; &nbsp;11H (17) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Enhanced Keyboard Status
<br>
&nbsp;16H &nbsp; &nbsp;12H (18) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Enhanced Keyboard Flags
<br>
&nbsp;17H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Parallel Port Printer Driver
<br>
&nbsp;17H &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write Character to Printer
<br>
&nbsp;17H &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Initialize Printer Port
<br>
&nbsp;17H &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Printer Status
<br>
&nbsp;18H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROM BASIC
<br>
&nbsp;19H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reboot System
<br>
&nbsp;1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Real-time (CMOS) Clock Driver
<br>
&nbsp;1AH &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Tick Count
<br>
&nbsp;1AH &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Tick Count
<br>
&nbsp;1AH &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Time
<br>
&nbsp;1AH &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Time
<br>
&nbsp;1AH &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Date
<br>
&nbsp;1AH &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Date
<br>
&nbsp;1AH &nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Alarm
<br>
&nbsp;1AH &nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reset Alarm
<br>
&nbsp;1AH &nbsp; &nbsp;0AH (10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Day Count
<br>
&nbsp;1AH &nbsp; &nbsp;0BH (11) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Day Count
<br>
&nbsp;1AH &nbsp; &nbsp;80H (128) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Sound Source
<br>
&nbsp;33H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Microsoft Mouse Driver
<br>
&nbsp;33H &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reset Mouse and Get Status
<br>
&nbsp;33H &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Show Mouse Pointer
<br>
&nbsp;33H &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hide Mouse Pointer
<br>
&nbsp;33H &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Mouse Position and Button Status
<br>
&nbsp;33H &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Mouse Pointer Position
<br>
&nbsp;33H &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Button Press Information
<br>
&nbsp;33H &nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get Button Release Information
<br>
&nbsp;33H &nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Horizontal Limits for Pointer
<br>
&nbsp;33H &nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Vertical Limits for Pointer
<br>
&nbsp;33H &nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set Graphics Pointer Shape
<br>
&nbsp;33H &nbsp; &nbsp;0AH (10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Text Pointer Type
<br>
&nbsp;33H &nbsp; &nbsp;0BH (11) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Read Mouse Motion Counters
<br>
&nbsp;33H &nbsp; &nbsp;0CH (12) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set User-defined Mouse Event Handler
<br>
&nbsp;33H &nbsp; &nbsp;0DH (13) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Turn On Light Pen Emulation
<br>
&nbsp;33H &nbsp; &nbsp;0EH (14) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Turn Off Light Pen Emulation
<br>
&nbsp;33H &nbsp; &nbsp;0FH (15) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Mickeys to Pixels Ratio
<br>
&nbsp;33H &nbsp; &nbsp;10H (16) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Mouse Pointer Exclusion Area
<br>
&nbsp;33H &nbsp; &nbsp;13H (19) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Double Speed Threshold
<br>
&nbsp;33H &nbsp; &nbsp;14H (20) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Swap User-defined Mouse Event Handlers
<br>
&nbsp;33H &nbsp; &nbsp;15H (21) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Mouse Save State Buffer Size
<br>
&nbsp;33H &nbsp; &nbsp;16H (22) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Save Mouse Driver State
<br>
&nbsp;33H &nbsp; &nbsp;17H (23) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Restore Mouse Driver State
<br>
&nbsp;33H &nbsp; &nbsp;18H (24) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Alternate Mouse Event Handler
<br>
&nbsp;33H &nbsp; &nbsp;19H (25) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Address of Alternate Mouse Event
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Handler
<br>
&nbsp;33H &nbsp; &nbsp;1AH (26) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Mouse Sensitivity
<br>
&nbsp;33H &nbsp; &nbsp;1BH (27) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Mouse Sensitivity
<br>
&nbsp;33H &nbsp; &nbsp;1CH (28) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Mouse Interrupt Rate
<br>
&nbsp;33H &nbsp; &nbsp;1DH (29) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select Pointer Page
<br>
&nbsp;33H &nbsp; &nbsp;1EH (30) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Pointer Page
<br>
&nbsp;33H &nbsp; &nbsp;1FH (31) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Disable Mouse Driver
<br>
&nbsp;33H &nbsp; &nbsp;20H (32) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Enable Mouse Driver
<br>
&nbsp;33H &nbsp; &nbsp;21H (33) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reset Mouse Driver
<br>
&nbsp;33H &nbsp; &nbsp;22H (34) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Language for Mouse Driver Messages
<br>
&nbsp;33H &nbsp; &nbsp;23H (35) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Language Number
<br>
&nbsp;33H &nbsp; &nbsp;24H (36) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Mouse Information
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 00H
<br>
Set video mode
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects the current video display mode. Also selects the active video
<br>
&nbsp;controller, if more than one video controller is present.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= video mode (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The video modes applicable to the various IBM machine models and video
<br>
&nbsp; &nbsp;adapters are as follows:
<br>
<br>
<br>
&nbsp;Mode &nbsp;Resolution &nbsp;Colors &nbsp; Text/ &nbsp; &nbsp; &nbsp; MDA &nbsp; CGA &nbsp; PCjr EGA &nbsp; MCGA &nbsp;VGA
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; graphics
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;00H &nbsp; 40-by-25 &nbsp; &nbsp; 16 &nbsp; &nbsp; &nbsp;text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp; *
<br>
&nbsp; &nbsp; &nbsp; &nbsp;color burst
<br>
&nbsp; &nbsp; &nbsp; &nbsp;off
<br>
&nbsp;01H &nbsp; 40-by-25 &nbsp; &nbsp; 16 &nbsp; &nbsp; &nbsp;text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp; *
<br>
&nbsp;02H &nbsp; 80-by-25 &nbsp; &nbsp; 16 &nbsp; &nbsp; &nbsp;text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp; *
<br>
&nbsp; &nbsp; &nbsp; &nbsp;color burst
<br>
&nbsp; &nbsp; &nbsp; &nbsp;off
<br>
&nbsp;03H &nbsp; 80-by-25 &nbsp; &nbsp; 16 &nbsp; &nbsp; &nbsp;text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp; *
<br>
&nbsp;04H &nbsp; 320-by-200 &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp; *
<br>
&nbsp;05H &nbsp; 320-by-200 &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp; *
<br>
&nbsp; &nbsp; &nbsp; &nbsp;color burst
<br>
&nbsp; &nbsp; &nbsp; &nbsp;off
<br>
&nbsp;06H &nbsp; 640-by-200 &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp;* &nbsp; &nbsp; * &nbsp; &nbsp; *
<br>
&nbsp;07H &nbsp; 80-by-25 &nbsp; &nbsp; &nbsp;2
<br>
Monochrome monitor only.
<br>
&nbsp; &nbsp; text &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *
<br>
&nbsp;08H &nbsp; 160-by-200 &nbsp; 16 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*
<br>
&nbsp;09H &nbsp; 320-by-200 &nbsp; 16 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*
<br>
&nbsp;0AH &nbsp; 640-by-200 &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*
<br>
&nbsp;0BH &nbsp; reserved
<br>
&nbsp;0CH &nbsp; reserved
<br>
&nbsp;0DH &nbsp; 320-by-200 &nbsp; 16 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *
<br>
&nbsp;0EH &nbsp; 640-by-200 &nbsp; 16 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *
<br>
&nbsp;0FH &nbsp; 640-by-350 &nbsp; &nbsp;2
<br>
Monochrome monitor only.
<br>
&nbsp; &nbsp; graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *
<br>
&nbsp;10H &nbsp; 640-by-350 &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *
<br>
EGA with 64 KB of RAM.
<br>
<br>
&nbsp;10H &nbsp; 640-by-350 &nbsp; 16 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *
<br>
EGA with 128 KB or more of RAM.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*
<br>
&nbsp;11H &nbsp; 640-by-480 &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp; *
<br>
&nbsp;12H &nbsp; 640-by-480 &nbsp; 16 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *
<br>
&nbsp;13H &nbsp; 320-by-200 &nbsp;256 &nbsp; &nbsp; &nbsp;graphics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp; *
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;■ The presence or absence of color burst is only significant when a
<br>
&nbsp; &nbsp;composite monitor is being used. For RGB monitors, there is no
<br>
&nbsp; &nbsp;functional difference between modes 00H and 01H or modes 02H and 03H. On
<br>
&nbsp; &nbsp;the CGA, two palettes are available in mode 04H and one in mode 05H.
<br>
<br>
&nbsp;■ On the PC/AT, PCjr, and PS/2, if bit 7 of AL is set, the display buffer
<br>
&nbsp; &nbsp;is not cleared when a new mode is selected. On the PC or PC/XT, this
<br>
&nbsp; &nbsp;capability is available only when an EGA or VGA (which have their own
<br>
&nbsp; &nbsp;ROM BIOS) is installed.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 01H
<br>
Set cursor type
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects the starting and ending lines for the blinking hardware cursor in
<br>
&nbsp;text display modes.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 01H
<br>
&nbsp;CH bits 0─4 &nbsp; &nbsp; &nbsp; &nbsp;= starting line for cursor
<br>
&nbsp;CL bits 0─4 &nbsp; &nbsp; &nbsp; &nbsp;= ending line for cursor
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ In text display modes, the video hardware causes the cursor to blink,
<br>
&nbsp; &nbsp;and the blink cannot be disabled. In graphics modes, the hardware cursor
<br>
&nbsp; &nbsp;is not available.
<br>
<br>
&nbsp;■ The default values set by the ROM BIOS are:
<br>
<br>
&nbsp; &nbsp;Display &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Start &nbsp; &nbsp; End
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;monochrome mode 07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp;12
<br>
&nbsp; &nbsp;text modes 00H─03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; 7
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;■ On the EGA, MCGA, and VGA in text modes 00H─03H, the ROM BIOS accepts
<br>
&nbsp; &nbsp;cursor start and end values as though the character cell were 8 by 8 and
<br>
&nbsp; &nbsp;remaps the values as appropriate for the true character cell dimensions.
<br>
&nbsp; &nbsp;This mapping is called cursor emulation.
<br>
<br>
&nbsp;■ You can turn off the cursor in several ways. On the MDA, CGA, and VGA,
<br>
&nbsp; &nbsp;setting register CH = 20H causes the cursor to disappear. Techniques
<br>
&nbsp; &nbsp;that involve setting illegal starting and ending lines for the current
<br>
&nbsp; &nbsp;display mode are unreliable. An alternative is to position the cursor to
<br>
&nbsp; &nbsp;a nondisplayable address, such as (x,y)=(0,25).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 02H
<br>
Set cursor position
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Positions the cursor on the display, using text coordinates.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= row (y coordinate)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= column (x coordinate)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ A separate cursor is maintained for each display page, and each can be
<br>
&nbsp; &nbsp;set independently with this function regardless of the currently active
<br>
&nbsp; &nbsp;page. The number of available display pages depends on the video adapter
<br>
&nbsp; &nbsp;and current display mode. See Int 10H Function 05H.
<br>
<br>
&nbsp;■ Text coordinates (x,y)=(0,0) are the upper left corner of the screen.
<br>
<br>
&nbsp;■ The maximum value for each text coordinate depends on the video adapter
<br>
&nbsp; &nbsp;and current display mode, as follows:
<br>
<br>
&nbsp; &nbsp;Mode &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Maximum x &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum y
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 39 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 39 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 39 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 39 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 19 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 39 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp;0DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 39 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;11H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;29
<br>
&nbsp; &nbsp;12H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 79 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;29
<br>
&nbsp; &nbsp;13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 39 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 03H
<br>
Get cursor position
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the current position of the cursor on the display, in text
<br>
&nbsp;coordinates.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
<br>
Returns:
<br>
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= starting line for cursor
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= ending line for cursor
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= row (y coordinate)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= column (x coordinate)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ A separate cursor is maintained for each display page, and each can be
<br>
&nbsp; &nbsp;inspected independently with this function regardless of the currently
<br>
&nbsp; &nbsp;active page. The number of available display pages depends on the video
<br>
&nbsp; &nbsp;adapter and current display mode. See Int 10H Function 05H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [CGA] [PCjr] [EGA]
<br>
Function 04H
<br>
Get light pen position
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the current status and position of the light pen.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H &nbsp; &nbsp; &nbsp; if light pen not down/not triggered
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if light pen down/triggered
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= pixel column (graphics x coordinate)
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= pixel row (graphics y coordinate, modes 04H─06H)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= pixel row (graphics y coordinate, modes 0DH─13H)
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character row (text y coordinate)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character column (text x coordinate)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The range of text and graphics coordinates returned by this function
<br>
&nbsp; &nbsp;depends on the current display mode.
<br>
<br>
&nbsp;■ On the CGA, the graphics coordinates returned by this function are not
<br>
&nbsp; &nbsp;continuous. The y coordinate is always a multiple of two; the x
<br>
&nbsp; &nbsp;coordinate is either a multiple of four (for 320-by-200 graphics modes)
<br>
&nbsp; &nbsp;or a multiple of eight (for 640-by-200 graphics modes).
<br>
<br>
&nbsp;■ Careful selection of background and foreground colors is necessary to
<br>
&nbsp; &nbsp;obtain maximum sensitivity from the light pen across the full screen
<br>
&nbsp; &nbsp;width.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 05H
<br>
Set display page
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects the active display page for the video display.
<br>
<br>
Call with:
<br>
<br>
&nbsp;For CGA, EGA, MCGA, VGA
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─7 &nbsp; &nbsp; &nbsp; for modes 00H and 01H (CGA, EGA, MCGA, VGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─3 &nbsp; &nbsp; &nbsp; for modes 02H and 03H (CGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─7 &nbsp; &nbsp; &nbsp; for modes 02H and 03H (EGA, MCGA, VGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─7 &nbsp; &nbsp; &nbsp; for mode 07H (EGA, VGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─7 &nbsp; &nbsp; &nbsp; for mode 0DH (EGA, VGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─3 &nbsp; &nbsp; &nbsp; for mode 0EH (EGA, VGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─1 &nbsp; &nbsp; &nbsp; for mode 0FH (EGA, VGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─1 &nbsp; &nbsp; &nbsp; for mode 10H (EGA, VGA)
<br>
<br>
&nbsp;For PCjr only
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H = read CRT/CPU page registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;81H = set CPU page register
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;82H = set CRT page register
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;83H = set both CPU and CRT page registers
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= CRT page (Subfunctions 82H and 83H)
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= CPU page (Subfunctions 81H and 83H)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If CGA, EGA, MCGA, or VGA adapter
<br>
<br>
&nbsp;Nothing
<br>
<br>
&nbsp;If PCjr and if function called with AL = 80H─83H
<br>
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= CRT page register
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= CPU page register
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Video mode and adapter combinations not listed above support one display
<br>
&nbsp; &nbsp;page (for example, a Monochrome Adapter in mode 7).
<br>
<br>
&nbsp;■ Switching between pages does not affect their contents. In addition,
<br>
&nbsp; &nbsp;text can be written to any video page with Int 10H Functions 02H, 09H,
<br>
&nbsp; &nbsp;and 0AH, regardless of the page currently being displayed.
<br>
<br>
&nbsp;■ On the PCjr, the CPU page determines the part of the physical memory
<br>
&nbsp; &nbsp;region 00000H─1FFFFH that will be hardware mapped onto 16 KB of memory
<br>
&nbsp; &nbsp;beginning at segment B800H. The CRT page determines the starting address
<br>
&nbsp; &nbsp;of the physical memory used by the video controller to refresh the
<br>
&nbsp; &nbsp;display. Smooth animation effects can be achieved by manipulation of
<br>
&nbsp; &nbsp;these registers. Programs that write directly to the B800H segment can
<br>
&nbsp; &nbsp;reach only the first 16 KB of the video refresh buffer. Programs
<br>
&nbsp; &nbsp;requiring direct access to the entire 32 KB buffer in modes 09H and 0AH
<br>
&nbsp; &nbsp;can obtain the current CRT page from the ROM BIOS variable PAGDAT at
<br>
&nbsp; &nbsp;0040:008AH.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 06H
<br>
Initialize or scroll window up
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes a specified window of the display to ASCII blank characters
<br>
&nbsp;with a given attribute or scrolls up the contents of a window by a
<br>
&nbsp;specified number of lines.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 06H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of lines to scroll (if zero, entire window is
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;blanked)
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute to be used for blanked area
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= y coordinate, upper left corner of window
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= x coordinate, upper left corner of window
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= y coordinate, lower right corner of window
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= x coordinate, lower right corner of window
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ In video modes that support multiple pages, this function affects only
<br>
&nbsp; &nbsp;the page currently being displayed.
<br>
<br>
&nbsp;■ If AL contains a value other than 00H, the area within the specified
<br>
&nbsp; &nbsp;window is scrolled up by the requested number of lines. Text that is
<br>
&nbsp; &nbsp;scrolled beyond the top of the window is lost. The new lines that appear
<br>
&nbsp; &nbsp;at the bottom of the window are filled with ASCII blanks carrying the
<br>
&nbsp; &nbsp;attribute specified by register BH.
<br>
<br>
&nbsp;■ To scroll down the contents of a window, see Int 10H Function 07H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 07H
<br>
Initialize or scroll window down
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes a specified window of the display to ASCII blank characters
<br>
&nbsp;with a given attribute, or scrolls down the contents of a window by a
<br>
&nbsp;specified number of lines.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 07H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of lines to scroll (if zero, entire window is
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;blanked)
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute to be used for blanked area
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= y coordinate, upper left corner of window
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= x coordinate, upper left corner of window
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= y coordinate, lower right corner of window
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= x coordinate, lower right corner of window
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ In video modes that support multiple pages, this function affects only
<br>
&nbsp; &nbsp;the page currently being displayed.
<br>
<br>
&nbsp;■ If AL contains a value other than 00H, the area within the specified
<br>
&nbsp; &nbsp;window is scrolled down by the requested number of lines. Text that is
<br>
&nbsp; &nbsp;scrolled beyond the bottom of the window is lost. The new lines that
<br>
&nbsp; &nbsp;appear at the top of the window are filled with ASCII blanks carrying
<br>
&nbsp; &nbsp;the attribute specified by register BH.
<br>
<br>
&nbsp;■ To scroll up the contents of a window, see Int 10H Function 06H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 08H
<br>
Read character and attribute at cursor
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the ASCII character and its attribute at the current cursor
<br>
&nbsp;position for the specified display page.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 08H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character
<br>
<br>
Note:
<br>
<br>
&nbsp;■ In video modes that support multiple pages, characters and their
<br>
&nbsp; &nbsp;attributes may be read from any page, regardless of the page currently
<br>
&nbsp; &nbsp;being displayed.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 09H
<br>
Write character and attribute at cursor
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Writes an ASCII character and its attribute to the display at the current
<br>
&nbsp;cursor position.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 09H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute (text modes) or color (graphics modes)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= count of characters to write (replication factor)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ In graphics modes, the replication factor in CX produces a valid result
<br>
&nbsp; &nbsp;only for the current row. If more characters are written than there are
<br>
&nbsp; &nbsp;remaining columns in the current row, the result is unpredictable.
<br>
<br>
&nbsp;■ All values of AL result in some sort of display; control characters,
<br>
&nbsp; &nbsp;including bell, backspace, carriage return, and line feed, are not
<br>
&nbsp; &nbsp;recognized as special characters and do not affect the cursor position.
<br>
<br>
&nbsp;■ After a character is written, the cursor must be moved explicitly with
<br>
&nbsp; &nbsp;Int 10H Function 02H to the next position.
<br>
<br>
&nbsp;■ To write a character without changing the attribute at the current
<br>
&nbsp; &nbsp;cursor position, use Int 10H Function 0AH.
<br>
<br>
&nbsp;■ If this function is used to write characters in graphics mode and bit 7
<br>
&nbsp; &nbsp;of BL is set (1), the character will be exclusive-OR'd (XOR) with the
<br>
&nbsp; &nbsp;current display contents. This feature can be used to write characters
<br>
&nbsp; &nbsp;and then &quot;erase&quot; them.
<br>
<br>
&nbsp;■ For the CGA and PCjr in graphics modes 04H─06H, the bit patterns for
<br>
&nbsp; &nbsp;character codes 80H─FFH are obtained from a table whose address is
<br>
&nbsp; &nbsp;stored in the vector for Int 1FH. On the PCjr, the address of the table
<br>
&nbsp; &nbsp;for character codes 00H─7FH is stored in the vector for Int 44H.
<br>
&nbsp; &nbsp;Alternative character sets may be installed by loading them into memory
<br>
&nbsp; &nbsp;and updating this vector.
<br>
<br>
&nbsp;■ For the EGA, MCGA, and VGA in graphics modes, the address of the
<br>
&nbsp; &nbsp;character definition table is stored in the vector for Int 43H. See Int
<br>
&nbsp; &nbsp;10H Function 11H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 0AH (10)
<br>
Write character at cursor
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Writes an ASCII character to the display at the current cursor position.
<br>
&nbsp;The character receives the attribute of the previous character displayed
<br>
&nbsp;at the same position.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0AH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= color (graphics modes, PCjr only)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= count of characters to write (replication factor)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ In graphics modes, the replication factor in CX produces a valid result
<br>
&nbsp; &nbsp;only for the current row. If more characters are written than there are
<br>
&nbsp; &nbsp;remaining columns in the current row, the result is unpredictable.
<br>
<br>
&nbsp;■ All values of AL result in some sort of display; control characters,
<br>
&nbsp; &nbsp;including bell, backspace, carriage return, and line feed, are not
<br>
&nbsp; &nbsp;recognized as special characters and do not affect the cursor position.
<br>
<br>
&nbsp;■ After a character is written, the cursor must be moved explicitly with
<br>
&nbsp; &nbsp;Int 10H Function 02H to the next position.
<br>
<br>
&nbsp;■ To write a character and attribute at the current cursor position, use
<br>
&nbsp; &nbsp;Int 10H Function 09H.
<br>
<br>
&nbsp;■ If this function is used to write characters in graphics mode and bit 7
<br>
&nbsp; &nbsp;of BL is set (1), the character will be exclusive-OR'd (XOR) with the
<br>
&nbsp; &nbsp;current display contents. This feature can be used to write characters
<br>
&nbsp; &nbsp;and then &quot;erase&quot; them.
<br>
<br>
&nbsp;■ For the CGA and PCjr in graphics modes 04H─06H, the bit patterns for
<br>
&nbsp; &nbsp;character codes 80H─FFH are obtained from a table whose address is
<br>
&nbsp; &nbsp;stored in the vector for Int 1FH. On the PCjr, the address of the table
<br>
&nbsp; &nbsp;for character codes 00H─7FH is stored in the vector for Int 44H.
<br>
&nbsp; &nbsp;Alternative character sets may be installed by loading them into memory
<br>
&nbsp; &nbsp;and updating this vector.
<br>
<br>
&nbsp;■ For the EGA, MCGA, and VGA in graphics modes, the address of the
<br>
&nbsp; &nbsp;character definition table is stored in the vector for Int 43H. See Int
<br>
&nbsp; &nbsp;10H Function 11H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 0BH (11)
<br>
Set palette, background, or border
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects a palette, background, or border color.
<br>
<br>
Call with:
<br>
<br>
&nbsp;To set the background color and border color for graphics modes or the
<br>
&nbsp;border color for text modes
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0BH
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= color
<br>
<br>
&nbsp;To select the palette (320-by-200 4-color graphics modes)
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0BH
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= palette (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ In text modes, this function selects only the border color. The
<br>
&nbsp; &nbsp;background color of each individual character is controlled by the upper
<br>
&nbsp; &nbsp;4 bits of that character's attribute byte.
<br>
<br>
&nbsp;■ On the CGA and EGA, this function is valid for palette selection only in
<br>
&nbsp; &nbsp;320-by-200 4-color graphics modes.
<br>
<br>
&nbsp;■ In 320-by-200 4-color graphics modes, if register BH = 01H, the
<br>
&nbsp; &nbsp;following palettes may be selected:
<br>
<br>
&nbsp; &nbsp;Palette &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pixel value &nbsp; &nbsp; &nbsp; Color
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; same as background
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; green
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; red
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; brown or yellow
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; same as background
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cyan
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magenta
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; white
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;■ On the CGA in 640-by-200 2-color graphics mode, the background color
<br>
&nbsp; &nbsp;selected with this function actually controls the display color for
<br>
&nbsp; &nbsp;nonzero pixels; zero pixels are always displayed as black.
<br>
<br>
&nbsp;■ On the PCjr in 640-by-200 2-color graphics mode, if BH = 00H and bit 0
<br>
&nbsp; &nbsp;of register BL is cleared, pixel value 1 is displayed as white; if bit 0
<br>
&nbsp; &nbsp;is set, pixel value 1 is displayed as black.
<br>
<br>
&nbsp;■ See also Int 10H Function 10H, which is used for palette programming on
<br>
&nbsp; &nbsp;the PCjr, EGA, MCGA, and VGA.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 0CH (12)
<br>
Write graphics pixel
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Draws a point on the display at the specified graphics coordinates.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0CH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= pixel value
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= column (graphics x coordinate)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= row (graphics y coordinate)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The range of valid pixel values and (x,y) coordinates depends on the
<br>
&nbsp; &nbsp;current video mode.
<br>
<br>
&nbsp;■ If bit 7 of AL is set, the new pixel value will be exclusive-OR'd (XOR)
<br>
&nbsp; &nbsp;with the current contents of the pixel.
<br>
<br>
&nbsp;■ Register BH is ignored for display modes that support only one page.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 0DH (13)
<br>
Read graphics pixel
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the current value of the pixel on the display at the specified
<br>
&nbsp;graphics coordinates.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0DH
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= column (graphics x coordinate)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= row (graphics y coordinate)
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= pixel value
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The range of valid (x,y) coordinates and possible pixel values depends
<br>
&nbsp; &nbsp;on the current video mode.
<br>
<br>
&nbsp;■ Register BH is ignored for display modes that support only one page.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 0EH (14)
<br>
Write character in teletype mode
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Writes an ASCII character to the display at the current cursor position,
<br>
&nbsp;using the specified color (if in graphics modes), and then increments the
<br>
&nbsp;cursor position appropriately.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0EH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= foreground color (graphics modes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The special ASCII codes for bell (07H), backspace (08H), carriage return
<br>
&nbsp; &nbsp;(0DH), and line feed (0AH) are recognized, and the appropriate action is
<br>
&nbsp; &nbsp;taken. All other characters are written to the display (even if they are
<br>
&nbsp; &nbsp;control characters), and the cursor is moved to the next position.
<br>
<br>
&nbsp;■ In video modes that support multiple pages, characters can be written to
<br>
&nbsp; &nbsp;any page, regardless of the page currently being displayed.
<br>
<br>
&nbsp;■ Line wrapping and scrolling are provided. If the cursor is at the end of
<br>
&nbsp; &nbsp;a line, it is moved to the beginning of the next line. If the cursor
<br>
&nbsp; &nbsp;reaches the end of the last line on the screen, the screen is scrolled
<br>
&nbsp; &nbsp;up by one line and the cursor is placed at the beginning of a new blank
<br>
&nbsp; &nbsp;line. The attribute for the entire new line is taken from the last
<br>
&nbsp; &nbsp;character that was written on the preceding line.
<br>
<br>
&nbsp;■ The default MS-DOS console driver (CON) uses this function to write text
<br>
&nbsp; &nbsp;to the screen. You cannot use this function to specify the attribute of
<br>
&nbsp; &nbsp;a character. One method of writing a character to the screen with a
<br>
&nbsp; &nbsp;specific attribute is to first write an ASCII blank (20H) with the
<br>
&nbsp; &nbsp;desired attribute at the current cursor location using Int 10H Function
<br>
&nbsp; &nbsp;09H and then write the actual character with Int 10H Function 0EH.
<br>
&nbsp; &nbsp;This technique, although somewhat clumsy, does not require the program
<br>
&nbsp; &nbsp;to explicitly handle line wrapping and scrolling.
<br>
<br>
&nbsp;■ See also Int 10H Function 13H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 0FH (15)
<br>
Get video mode
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the current display mode of the active video controller.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0FH
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of character columns on screen
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= display mode (see Int 10H Function 00H)
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= active display page
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function can be called to obtain the screen width before clearing
<br>
&nbsp; &nbsp;the screen with Int 10H Functions 06H or 07H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[PCjr] [EGA] [MCGA] [VGA]
<br>
Function 10H (16) Subfunction 00H
<br>
Set palette register
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the correspondence of a palette register to a displayable color.
<br>
<br>
Call with:
<br>
<br>
&nbsp;On the PCjr, EGA, or VGA
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= color value
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= palette register (00─0FH)
<br>
<br>
&nbsp;On the MCGA
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0712H
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ On the MCGA, this function can only be called with BX = 0712H and
<br>
&nbsp; &nbsp;selects a color register set with eight consistent colors.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PCjr] [EGA] [VGA]
<br>
Function 10H (16) Subfunction 01H
<br>
Set border color
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Controls the color of the screen border (overscan).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= color value
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PCjr] [EGA] [VGA]
<br>
Function 10H (16) Subfunction 02H
<br>
Set palette and border
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets all palette registers and the border color (overscan) in one
<br>
&nbsp;operation.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of color list
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The color list is 17 bytes long. The first 16 bytes are the color values
<br>
&nbsp; &nbsp;to be loaded into palette registers 0─15, and the last byte is stored in
<br>
&nbsp; &nbsp;the border color register.
<br>
<br>
&nbsp;■ In 16-color graphics modes, the following default palette is set up:
<br>
<br>
&nbsp; &nbsp;Pixel value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Color
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blue
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; green
<br>
&nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cyan
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; red
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magenta
<br>
&nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; brown
<br>
&nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; white
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gray
<br>
&nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; light blue
<br>
&nbsp; &nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; light green
<br>
&nbsp; &nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; light cyan
<br>
&nbsp; &nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; light red
<br>
&nbsp; &nbsp;0DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; light magenta
<br>
&nbsp; &nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yellow
<br>
&nbsp; &nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intense white
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[PCjr] [EGA] [MCGA] [VGA]
<br>
Function 10H (16) Subfunction 03H
<br>
Toggle blink/intensity bit
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Determines whether the most significant bit of a character attribute will
<br>
&nbsp;select blinking or intensified display.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= blink/intensity toggle
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = enable intensity
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = enable blinking
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[VGA]
<br>
Function 10H (16) Subfunction 07H
<br>
Get palette register
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the color associated with the specified palette register.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 07H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= palette register
<br>
<br>
Returns:
<br>
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= color
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[VGA]
<br>
Function 10H (16) Subfunction 08H
<br>
Get border color
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the current border color (overscan).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 08H
<br>
<br>
Returns:
<br>
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= color
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[VGA]
<br>
Function 10H (16) Subfunction 09H
<br>
Get palette and border
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Gets the contents of all palette registers and the border color (overscan)
<br>
&nbsp;in one operation.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 09H
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of 17-byte buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
&nbsp;and buffer contains palette values in bytes 00H─0FH and border color in
<br>
&nbsp;byte 10H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 10H (16) Subfunction 10H (16)
<br>
Set color register
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Programs an individual color register with a red-green-blue (RGB)
<br>
&nbsp;combination.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= color register
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= green value
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= blue value
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= red value
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ If gray-scale summing is enabled, the weighted gray-scale value is
<br>
&nbsp; &nbsp;calculated as described under Int 10H Function 10H Subfunction 1BH and
<br>
&nbsp; &nbsp;is stored into all three components of the color register. See also Int
<br>
&nbsp; &nbsp;10H Function 12H Subfunction 33H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 10H (16) Subfunction 12H (18)
<br>
Set block of color registers
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Programs a group of consecutive color registers in one operation.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= first color register
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of color registers
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of color table
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The table consists of a series of 3-byte entries, one entry per color
<br>
&nbsp; &nbsp;register to be programmed. The bytes of an individual entry specify the
<br>
&nbsp; &nbsp;red, green, and blue values (in that order) for the associated color
<br>
&nbsp; &nbsp;register.
<br>
<br>
&nbsp;■ If gray-scale summing is enabled, the weighted gray-scale value for each
<br>
&nbsp; &nbsp;register is calculated as described under Int 10H Function 10H
<br>
&nbsp; &nbsp;Subfunction 1BH and is stored into all three components of the color
<br>
&nbsp; &nbsp;register. See also Int 10H Function 12H Subfunction 33H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[VGA]
<br>
Function 10H (16) Subfunction 13H (19)
<br>
Set color page state
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects the paging mode for the color registers, or selects an individual
<br>
&nbsp;page of color registers.
<br>
<br>
Call with:
<br>
<br>
&nbsp;To select the paging mode
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 13H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= paging mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; for 4 pages of 64 registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; for 16 pages of 16 registers
<br>
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;To select a color register page
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 13H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is not valid in mode 13H (320-by-200 256-color graphics).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 10H (16) Subfunction 15H (21)
<br>
Get color register
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the contents of a color register as its red, green, and blue
<br>
&nbsp;components.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 15H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= color register
<br>
<br>
Returns:
<br>
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= green value
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= blue value
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= red value
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 10H (16) Subfunction 17H (23)
<br>
Get block of color registers
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Allows the red, green, and blue components associated with each of a set
<br>
&nbsp;of color registers to be read in one operation.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 17H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= first color register
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of color registers
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer to receive color list
<br>
<br>
Returns:
<br>
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer and buffer contains color list
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The color list returned in the caller's buffer consists of a series of
<br>
&nbsp; &nbsp;3-byte entries corresponding to the color registers. Each 3-byte entry
<br>
&nbsp; &nbsp;contains the register's red, green, and blue components in that order.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[VGA]
<br>
Function 10H (16) Subfunction 1AH (26)
<br>
Get color page state
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the color register paging mode and current color page.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1AH
<br>
<br>
Returns:
<br>
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= color page
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= paging mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if 4 pages of 64 registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if 16 pages of 16 registers
<br>
<br>
Note:
<br>
<br>
&nbsp;■ See Int 10H Function 10H Subfunction 13H, which allows selection of the
<br>
&nbsp; &nbsp;paging mode or current color page.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 10H (16) Subfunction 1BH (27)
<br>
Set gray-scale values
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Transforms the red, green, and blue values of one or more color registers
<br>
&nbsp;into the gray-scale equivalents.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1BH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= first color register
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of color registers
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ For each color register, the weighted sum of its red, green, and blue
<br>
&nbsp; &nbsp;values is calculated (30% red + 59% green + 11% blue) and written back
<br>
&nbsp; &nbsp;into all three components of the color register. The original red,
<br>
&nbsp; &nbsp;green, and blue values are lost.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [EGA] [MCGA] [VGA]
<br>
Function 11H (17) Subfunctions 00H and 10H (16)
<br>
Load user font
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Loads the user's font (character definition) table into the specified
<br>
&nbsp;block of character generator RAM.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H or 10H (see Notes)
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= points (bytes per character)
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= block
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of characters defined by table
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= first character code in table
<br>
&nbsp;ES:BP &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of font table
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function provides font selection in text (alphanumeric) display
<br>
&nbsp; &nbsp;modes. For font selection in graphics (all-points-addressable) modes,
<br>
&nbsp; &nbsp;see Int 10H Function 11H Subfunctions 20H─24H.
<br>
<br>
&nbsp;■ If AL = 10H, page 0 must be active. The points (bytes per character),
<br>
&nbsp; &nbsp;rows, and length of the refresh buffer are recalculated. The controller
<br>
&nbsp; &nbsp;is reprogrammed with the maximum scan line (points - 1), cursor start
<br>
&nbsp; &nbsp;(points - 2), cursor end (points - 1), vertical display end
<br>
&nbsp; &nbsp;((rows*points) - 1), and underline location (points - 1, mode 7 only).
<br>
<br>
&nbsp; &nbsp;If Subfunction 10H is called at any time other than immediately after a
<br>
&nbsp; &nbsp;mode set, the results are unpredictable.
<br>
<br>
&nbsp;■ On the MCGA, a Subfunction 00H call should be followed by a Subfunction
<br>
&nbsp; &nbsp;03H call so that the ROM BIOS will load the font into the character
<br>
&nbsp; &nbsp;generator's internal font pages.
<br>
<br>
&nbsp;■ Subfunction 10H is reserved on the MCGA. If it is called, Subfunction
<br>
&nbsp; &nbsp;00H is executed.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EGA] [VGA]
<br>
Function 11H (17) Subfunctions 01H and 11H (17)
<br>
Load ROM 8-by-14 font
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Loads the ROM BIOS default 8-by-14 font table into the specified block of
<br>
&nbsp;character generator RAM.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H or 11H (see Notes)
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= block
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function provides font selection in text (alphanumeric) display
<br>
&nbsp; &nbsp;modes. For font selection in graphics (all-points-addressable) modes,
<br>
&nbsp; &nbsp;see Int 10H Function 11H Subfunctions 20H─24H.
<br>
<br>
&nbsp;■ If AL = 11H, page 0 must be active. The points (bytes per character),
<br>
&nbsp; &nbsp;rows, and length of the refresh buffer are recalculated. The controller
<br>
&nbsp; &nbsp;is reprogrammed with the maximum scan line (points - 1), cursor start
<br>
&nbsp; &nbsp;(points - 2), cursor end (points - 1), vertical display end
<br>
&nbsp; &nbsp;((rows*points) - 1), and underline location (points - 1, mode 7 only).
<br>
<br>
&nbsp; &nbsp;If Subfunction 11H is called at any time other than immediately after a
<br>
&nbsp; &nbsp;mode set, the results are unpredictable.
<br>
<br>
&nbsp;■ Subfunctions 01H and 11H are reserved on the MCGA. If either is called,
<br>
&nbsp; &nbsp;Subfunction 04H is executed.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [EGA] [MCGA] [VGA]
<br>
Function 11H (17) Subfunctions 02H and 12H (18)
<br>
Load ROM 8-by-8 font
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Loads the ROM BIOS default 8-by-8 font table into the specified block of
<br>
&nbsp;character generator RAM.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H or 12H (see Notes)
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= block
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function provides font selection in text (alphanumeric) display
<br>
&nbsp; &nbsp;modes. For font selection in graphics (all-points-addressable) modes,
<br>
&nbsp; &nbsp;see Int 10H Function 11H Subfunctions 20H─24H.
<br>
<br>
&nbsp;■ If AL = 12H, page 0 must be active. The points (bytes per character),
<br>
&nbsp; &nbsp;rows, and length of the refresh buffer are recalculated. The controller
<br>
&nbsp; &nbsp;is reprogrammed with the maximum scan line (points - 1), cursor start
<br>
&nbsp; &nbsp;(points - 2), cursor end (points - 1), vertical display end
<br>
&nbsp; &nbsp;((rows*points) - 1), and underline location (points - 1, mode 7 only).
<br>
<br>
&nbsp; &nbsp;If Subfunction 12H is called at any time other than immediately after a
<br>
&nbsp; &nbsp;mode set, the results are unpredictable.
<br>
<br>
&nbsp;■ On the MCGA, a Subfunction 02H call should be followed by a Subfunction
<br>
&nbsp; &nbsp;03H call, so that the ROM BIOS will load the font into the character
<br>
&nbsp; &nbsp;generator's internal font pages.
<br>
<br>
&nbsp;■ Subfunction 12H is reserved on the MCGA. If it is called, Subfunction
<br>
&nbsp; &nbsp;02H is executed.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [EGA] [MCGA] [VGA]
<br>
Function 11H (17) Subfunction 03H
<br>
Set block specifier
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Determines the character blocks selected by bit 3 of character attribute
<br>
&nbsp;bytes in alphanumeric (text) display modes.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character generator block select code (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ On the EGA and MCGA, the bits of BL are used as follows:
<br>
<br>
&nbsp; &nbsp;Bits &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;0─1 &nbsp; &nbsp; &nbsp; character block selected by attribute bytes with bit 3 = 0
<br>
&nbsp; &nbsp;2─3 &nbsp; &nbsp; &nbsp; character block selected by attribute bytes with bit 3 = 1
<br>
&nbsp; &nbsp;4─7 &nbsp; &nbsp; &nbsp; not used (should be 0)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;■ On the VGA, the bits of BL are used as follows:
<br>
<br>
&nbsp; &nbsp;Bits &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;0,1,4 &nbsp; &nbsp; character block selected by attribute bytes with bit 3 = 0
<br>
&nbsp; &nbsp;2,3,5 &nbsp; &nbsp; character block selected by attribute bytes with bit 3 = 1
<br>
&nbsp; &nbsp;6─7 &nbsp; &nbsp; &nbsp; not used (should be 0)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;■ When using a 256-character set, both fields of BL should select the same
<br>
&nbsp; &nbsp;character block. In such cases, character attribute bit 3 controls the
<br>
&nbsp; &nbsp;foreground intensity. When using 512-character sets, the fields of BL
<br>
&nbsp; &nbsp;designate the blocks holding each half of the character set, and bit 3
<br>
&nbsp; &nbsp;of the character attribute selects the upper or lower half of the
<br>
&nbsp; &nbsp;character set.
<br>
<br>
&nbsp;■ When using a 512-character set, a call to Int 10H Function 10H
<br>
&nbsp; &nbsp;Subfunction 00H with BX = 0712H is recommended to set the color planes
<br>
&nbsp; &nbsp;to eight consistent colors.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 11H (17) Subfunctions 04H and 14H (20)
<br>
Load ROM 8-by-16 font
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Loads the ROM BIOS default 8-by-16 font table into the specified block of
<br>
&nbsp;character generator RAM.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H or 14H (see Notes)
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= block
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function provides font selection in text (alphanumeric) display
<br>
&nbsp; &nbsp;modes. For font selection in graphics (all-points-addressable) modes,
<br>
&nbsp; &nbsp;see Int 10H Function 11H Subfunctions 20H─24H.
<br>
<br>
&nbsp;■ If AL = 14H, page 0 must be active. The points (bytes per character),
<br>
&nbsp; &nbsp;rows, and length of the refresh buffer are recalculated. The controller
<br>
&nbsp; &nbsp;is reprogrammed with the maximum scan line (points - 1), cursor start
<br>
&nbsp; &nbsp;(points - 2), cursor end (points - 1), vertical display end (rows*points
<br>
&nbsp; &nbsp;- 1 for 350- and 400-line modes, or rows *points *2 - 1 for 200-line
<br>
&nbsp; &nbsp;modes), and underline location (points - 1, mode 7 only).
<br>
<br>
&nbsp; &nbsp;If Subfunction 14H is called at any time other than immediately after a
<br>
&nbsp; &nbsp;mode set, the results are unpredictable.
<br>
<br>
&nbsp;■ On the MCGA, a Subfunction 04H call should be followed by a Subfunction
<br>
&nbsp; &nbsp;03H call so that the ROM BIOS will load the font into the character
<br>
&nbsp; &nbsp;generator's internal font pages.
<br>
<br>
&nbsp;■ Subfunction 14H is reserved on the MCGA. If it is called, Subfunction
<br>
&nbsp; &nbsp;04H is executed.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [EGA] [MCGA] [VGA]
<br>
Function 11H (17) Subfunction 20H (32)
<br>
Set Int 1FH font pointer
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the Int 1FH pointer to the user's font table. This table is used for
<br>
&nbsp;character codes 80H─FFH in graphics modes 04H─06H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 20H
<br>
&nbsp;ES:BP &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of font table
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function provides font selection in graphics
<br>
&nbsp; &nbsp;(all-points-addressable) display modes. For font selection in text
<br>
&nbsp; &nbsp;(alphanumeric) modes, see Int 10H Function 11H Subfunctions 00H─14H.
<br>
<br>
&nbsp;■ If this subfunction is called at any time other than immediately after a
<br>
&nbsp; &nbsp;mode set, the results are unpredictable.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [EGA] [MCGA] [VGA]
<br>
Function 11H (17) Subfunction 21H (33)
<br>
Set Int 43H for user's font
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the vector for Int 43H to point to the user's font table and updates
<br>
&nbsp;the video ROM BIOS data area. The video controller is not reprogrammed.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 21H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character rows specifier
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if user specified (see register DL)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 14 (0EH) rows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 25 (19H) rows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 43 (2BH) rows
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= points (bytes per character)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character rows per screen (if BL = 00H)
<br>
&nbsp;ES:BP &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of user font table
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function provides font selection in graphics
<br>
&nbsp; &nbsp;(all-points-addressable) display modes. For font selection in text
<br>
&nbsp; &nbsp;(alphanumeric) modes, see Int 10H Function 11H Subfunctions 00H─14H.
<br>
<br>
&nbsp;■ If this subfunction is called at any time other than immediately after a
<br>
&nbsp; &nbsp;mode set, the results are unpredictable.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [EGA] [MCGA] [VGA]
<br>
Function 11H (17) Subfunction 22H (34)
<br>
Set Int 43H for ROM 8-by-14 font
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the vector for Int 43H to point to the ROM BIOS default 8-by-14 font
<br>
&nbsp;and updates the video ROM BIOS data area. The video controller is not
<br>
&nbsp;reprogrammed.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 22H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character rows specifier
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if user specified (see register DL)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 14 (0EH) rows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 25 (19H) rows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 43 (2BH) rows
<br>
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character rows per screen (if BL = 00H)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function provides font selection in graphics
<br>
&nbsp; &nbsp;(all-points-addressable) display modes. For font selection in text
<br>
&nbsp; &nbsp;(alphanumeric) modes, see Int 10H Function 11H Subfunctions 00H─14H.
<br>
<br>
&nbsp;■ If this subfunction is called at any time other than immediately after a
<br>
&nbsp; &nbsp;mode set, the results are unpredictable.
<br>
<br>
&nbsp;■ When this subfunction is called on the MCGA, Subfunction 24H is
<br>
&nbsp; &nbsp;substituted.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [EGA] [MCGA] [VGA]
<br>
Function 11H (17) Subfunction 23H (35)
<br>
Set Int 43H for ROM 8-by-8 font
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the vector for Int 43H to point to the ROM BIOS default 8-by-8 font
<br>
&nbsp;and updates the video ROM BIOS data area. The video controller is not
<br>
&nbsp;reprogrammed.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 23H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character rows specifier
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if user specified (see register DL)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 14 (0EH) rows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 25 (19H) rows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 43 (2BH) rows
<br>
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character rows per screen (if BL = 00H)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function provides font selection in graphics
<br>
&nbsp; &nbsp;(all-points-addressable) display modes. For font selection in text
<br>
&nbsp; &nbsp;(alphanumeric) modes, see Int 10H Function 11H Subfunctions 00H─14H.
<br>
<br>
&nbsp;■ If this subfunction is called at any time other than immediately after a
<br>
&nbsp; &nbsp;mode set, the results are unpredictable.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 11H (17) Subfunction 24H (36)
<br>
Set Int 43H for ROM 8-by-16 font
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the vector for Int 43H to point to the ROM BIOS default 8-by-16 font
<br>
&nbsp;and updates the video ROM BIOS data area. The video controller is not
<br>
&nbsp;reprogrammed.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 24H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= row specifier
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if user specified (see register DL)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 14 (0EH) rows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 25 (19H) rows
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 43 (2BH) rows
<br>
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character rows per screen (if BL = 00H)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function provides font selection in graphics
<br>
&nbsp; &nbsp;(all-points-addressable) display modes. For font selection in text
<br>
&nbsp; &nbsp;(alphanumeric) modes, see Int 10H Function 11H Subfunctions 00H─14H.
<br>
<br>
&nbsp;■ If this subfunction is called at any time other than immediately after a
<br>
&nbsp; &nbsp;mode set, the results are unpredictable.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [EGA] [MCGA] [VGA]
<br>
Function 11H (17) Subfunction 30H (48)
<br>
Get font information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a pointer to the character definition table for a font and the
<br>
&nbsp;points (bytes per character) and rows for that font.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 30H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= font code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = current Int 1FH contents
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = current Int 43H contents
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = ROM 8-by-14 font (EGA, VGA only)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H = ROM 8-by-8 font (characters 00H─7FH)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H = ROM 8-by-8 font (characters 80H─FFH)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H = ROM alternate 9-by-14 font (EGA, VGA only)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;06H = ROM 8-by-16 font (MCGA, VGA only)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;07H = ROM alternate 9-by-16 font (VGA only)
<br>
<br>
Returns:
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= points (bytes per character)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= rows (character rows on screen - 1)
<br>
&nbsp;ES:BP &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of font table
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EGA] [VGA]
<br>
Function 12H (18) Subfunction 10H (16)
<br>
Get configuration information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains configuration information for the active video subsystem.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
<br>
Returns:
<br>
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= display type
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; if color display
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; if monochrome display
<br>
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= memory installed on EGA board
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if 64 KB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if 128 KB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if 192 KB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if 256 KB
<br>
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= feature bits (see Notes)
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= switch setting (see Notes)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The feature bits are set from Input Status register 0 in response to an
<br>
&nbsp; &nbsp;output on the specified Feature Control register bits:
<br>
<br>
&nbsp; &nbsp;Feature &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Feature control &nbsp; &nbsp; &nbsp; &nbsp; Input status
<br>
&nbsp; &nbsp;bit(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;output bit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bit
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6
<br>
&nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5
<br>
&nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6
<br>
&nbsp; &nbsp;4─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not used
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;■ The bits in the switch settings byte indicate the state of the EGA's
<br>
&nbsp; &nbsp;configuration DIP switch (1 = off, 0 = on).
<br>
<br>
&nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; configuration switch 1
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; configuration switch 2
<br>
&nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; configuration switch 3
<br>
&nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; configuration switch 4
<br>
&nbsp; &nbsp;4─7 &nbsp; &nbsp; &nbsp; not used
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EGA] [VGA]
<br>
Function 12H (18) Subfunction 20H (32)
<br>
Select alternate printscreen
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects an alternate print-screen routine for the EGA and VGA that works
<br>
&nbsp;properly if the screen length is not 25 lines. The ROM BIOS default
<br>
&nbsp;print-screen routine always prints 25 lines.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 20H
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[VGA]
<br>
Function 12H (18) Subfunction 30H (48)
<br>
Set scan lines
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects the number of scan lines for alphanumeric modes. The selected
<br>
&nbsp;value takes effect the next time Int 10H Function 00H is called to select
<br>
&nbsp;the display mode.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= scan line code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = 200 scan lines
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = 350 scan lines
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = 400 scan lines
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 30H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If the VGA is active
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
<br>
&nbsp;If the VGA is not active
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 12H (18) Subfunction 31H (49)
<br>
Enable/disable default palette loading
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Enables or disables loading of a default palette when a video display mode
<br>
&nbsp;is selected.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H to enable default palette loading
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H to disable default palette loading
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 31H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function supported
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 12H (18) Subfunction 32H (50)
<br>
Enable/disable video
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Enables or disables CPU access to the video adapter's I/O ports and video
<br>
&nbsp;refresh buffer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H to enable access
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H to disable access
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 32H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function supported
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 12H (18) Subfunction 33H (51)
<br>
Enable/disable gray-scale summing
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Enables or disables gray-scale summing for the currently active display.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H to enable gray-scale summing
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H to disable gray-scale summing
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 33H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function supported
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
<br>
Note:
<br>
<br>
&nbsp;■ When enabled, gray-scale summing occurs during display mode selection,
<br>
&nbsp; &nbsp;palette programming, and color register loading.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[VGA]
<br>
Function 12H (18) Subfunction 34H (52)
<br>
Enable/disable cursor emulation
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Enables or disables cursor emulation for the currently active display.
<br>
&nbsp;When cursor emulation is enabled, the ROM BIOS automatically remaps Int
<br>
&nbsp;10H Function 01H cursor starting and ending lines for the current
<br>
&nbsp;character cell dimensions.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H to enable cursor emulation
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H to disable cursor emulation
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 34H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function supported
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [MCGA] [VGA]
<br>
Function 12H (18) Subfunction 35H (53)
<br>
Switch active display
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Allows selection of one of two video adapters in the system when memory
<br>
&nbsp;usage or port addresses conflict between the two adapters.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= switching function
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; to disable initial video adapter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; to enable system board video adapter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; to disable active video adapter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; to enable inactive video adapter
<br>
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 35H
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of 128-byte buffer (if AL = 00H, 02H, or
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function supported
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
<br>
&nbsp;and, if called with AL = 00H or 02H
<br>
<br>
&nbsp;Video adapter state information saved in caller's buffer
<br>
<br>
&nbsp;or, if called with AL = 03H
<br>
<br>
&nbsp;Video adapter state restored from information in caller's buffer
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This subfunction cannot be used unless both video adapters have a
<br>
&nbsp; &nbsp;disable capability (Int 10H Function 12H Subfunction 32H).
<br>
<br>
&nbsp;■ If there is no conflict between the system board video and the adapter
<br>
&nbsp; &nbsp;board video in memory or port usage, both video controllers can be
<br>
&nbsp; &nbsp;active simultaneously and this subfunction is not required.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[VGA]
<br>
Function 12H (18) Subfunction 36H (54)
<br>
Enable/disable screen refresh
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Enables or disables the video refresh for the currently active display.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H to enable refresh
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H to disable refresh
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 36H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function supported
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
<br>
Function 13H (19)
<br>
Write string in teletype mode
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Transfers a string to the video buffer for the currently active display,
<br>
&nbsp;starting at the specified position.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 13H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= write mode
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; attribute in BL; string contains character codes
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;only; and cursor position is not updated after
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; attribute in BL;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;string contains character codes only; and cursor
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;position is updated after write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; string contains alternating character codes and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;attribute bytes; and cursor position is not
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;updated after write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; string contains alternating character codes and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;attribute bytes; and cursor position is updated
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;after write
<br>
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute, if AL = 00H or 01H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= length of character string
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= y coordinate (row)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= x coordinate (column)
<br>
&nbsp;ES:BP &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of string
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is not available on the original IBM PC or PC/XT unless an
<br>
&nbsp; &nbsp;EGA video adapter (which contains its own ROM BIOS) is installed.
<br>
<br>
&nbsp;■ This function may be thought of as an extension to Int 10H Function
<br>
&nbsp; &nbsp;0EH. The control characters bell (07H), backspace (08H), line feed
<br>
&nbsp; &nbsp;(0AH), and carriage return (0DH) are recognized and handled
<br>
&nbsp; &nbsp;appropriately.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 1AH (26)
<br>
Get or set display combination code
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a code describing the installed display adapter(s) or updates the
<br>
&nbsp;ROM BIOS's variable describing the installed adapter(s).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1AH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = get display combination code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = set display combination code
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= inactive display code (if AL = 01H)
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= active display code (if AL = 01H)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function supported
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1AH
<br>
<br>
&nbsp;and, if called with AL = 00H
<br>
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= inactive display code
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= active display code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The display codes are interpreted as follows:
<br>
<br>
&nbsp; &nbsp;Code(s) &nbsp; Video subsystem type
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; no display
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; MDA with 5151 monitor
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; CGA with 5153 or 5154 monitor
<br>
&nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; EGA with 5153 or 5154 monitor
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; EGA with 5151 monitor
<br>
&nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; PGA with 5175 monitor
<br>
&nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; VGA with analog monochrome monitor
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; VGA with analog color monitor
<br>
&nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp;0AH &nbsp; &nbsp; &nbsp; MCGA with digital color monitor
<br>
&nbsp; &nbsp;0BH &nbsp; &nbsp; &nbsp; MCGA with analog monochrome monitor
<br>
&nbsp; &nbsp;0CH &nbsp; &nbsp; &nbsp; MCGA with analog color monitor
<br>
&nbsp; &nbsp;0DH─FEH &nbsp; reserved
<br>
&nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; unknown
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 1BH (27)
<br>
Get functionality/state information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains information about the current display mode as well as a pointer to
<br>
&nbsp;a table describing the characteristics and capabilities of the video
<br>
&nbsp;adapter and monitor.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1BH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= implementation type (always 00H)
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of 64-byte buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function supported
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1BH
<br>
<br>
&nbsp;and information placed in caller's buffer (see Notes)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The caller's buffer is filled in with information that depends on the
<br>
&nbsp; &nbsp;current video display mode:
<br>
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; Contents
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H─03H &nbsp; pointer to functionality information (see next Note)
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; current video mode
<br>
&nbsp; &nbsp;05H─06H &nbsp; number of character columns
<br>
&nbsp; &nbsp;07H─08H &nbsp; length of video refresh buffer (bytes)
<br>
&nbsp; &nbsp;09H─0AH &nbsp; starting address in buffer of upper left corner of display
<br>
&nbsp; &nbsp;0BH─1AH &nbsp; cursor position for video pages 0─7 as eight 2-byte entries;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;first byte of each pair is y coordinate, second byte is x
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;coordinate
<br>
&nbsp; &nbsp;1BH &nbsp; &nbsp; &nbsp; cursor starting line
<br>
&nbsp; &nbsp;1CH &nbsp; &nbsp; &nbsp; cursor ending line
<br>
&nbsp; &nbsp;1DH &nbsp; &nbsp; &nbsp; active display page
<br>
&nbsp; &nbsp;1EH─1FH &nbsp; adapter base port address (3BXH monochrome, 3DXH color)
<br>
&nbsp; &nbsp;20H &nbsp; &nbsp; &nbsp; current setting of register 3B8H or 3D8H
<br>
&nbsp; &nbsp;21H &nbsp; &nbsp; &nbsp; current setting of register 3B9H or 3D9H
<br>
&nbsp; &nbsp;22H &nbsp; &nbsp; &nbsp; number of character rows
<br>
&nbsp; &nbsp;23H─24H &nbsp; character height in scan lines
<br>
&nbsp; &nbsp;25H &nbsp; &nbsp; &nbsp; active display code (see Int 10H Function 1AH)
<br>
&nbsp; &nbsp;26H &nbsp; &nbsp; &nbsp; inactive display code (see Int 10H Function 1AH)
<br>
&nbsp; &nbsp;27H─28H &nbsp; number of displayable colors (0 for monochrome)
<br>
&nbsp; &nbsp;29H &nbsp; &nbsp; &nbsp; number of display pages
<br>
&nbsp; &nbsp;2AH &nbsp; &nbsp; &nbsp; number of scan lines
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 200 scan lines
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 350 scan lines
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 400 scan lines
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 480 scan lines
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H─FFH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= reserved
<br>
&nbsp; &nbsp;2BH &nbsp; &nbsp; &nbsp; primary character block (see Int 10H Function 11H Subfunction
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H)
<br>
&nbsp; &nbsp;2CH &nbsp; &nbsp; &nbsp; secondary character block
<br>
&nbsp; &nbsp;2DH &nbsp; &nbsp; &nbsp; miscellaneous state information
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp; Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if all modes on all displays active
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (always 0 on MCGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if gray-scale summing active
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if monochrome display attached
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode set default palette loading
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; disabled
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if cursor emulation active (always 0 on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= state of I/B toggle (0 = intensity, 1 =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blink)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= reserved
<br>
<br>
&nbsp; &nbsp;2EH─30H &nbsp; reserved
<br>
&nbsp; &nbsp;31H &nbsp; &nbsp; &nbsp; video memory available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 64 KB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 128 KB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 192 KB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 256 KB
<br>
&nbsp; &nbsp;32H &nbsp; &nbsp; &nbsp; save pointer state information
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp; Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if 512-character set active
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if dynamic save area active
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if alpha font override active
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if graphics font override active
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if palette override active
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if display combination code (DCC)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extension active
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= reserved
<br>
<br>
&nbsp; &nbsp;33H─3FH &nbsp; reserved
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
&nbsp;■ Bytes 0─3 of the caller's buffer contain a DWORD pointer (offset in
<br>
&nbsp; &nbsp;lower word, segment in upper word) to the following information about
<br>
&nbsp; &nbsp;the display adapter and monitor:
<br>
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; Contents
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; video modes supported
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 00H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 01H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 02H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 03H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 04H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 05H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 06H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 07H supported
<br>
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; video modes supported
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 08H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 09H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 0AH supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 0BH supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 0CH supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 0DH supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 0EH supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 0FH supported
<br>
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; video modes supported
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp; Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 10H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 11H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 12H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode 13H supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= reserved
<br>
<br>
&nbsp; &nbsp;03H─06H &nbsp; reserved
<br>
&nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; scan lines available in text modes
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp; Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if 200 scan lines
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if 350 scan lines
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if 400 scan lines
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= reserved
<br>
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; character blocks available in text modes (see Int 10H Function
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11H)
<br>
&nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; maximum number of active character blocks in text modes
<br>
&nbsp; &nbsp;0AH &nbsp; &nbsp; &nbsp; miscellaneous BIOS capabilities
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if all modes active on all displays
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (always 0 for MCGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if gray-scale summing available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if character font loading available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if mode set default palette loading
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if cursor emulation available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if EGA (64-color) palette available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if color register loading available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if color register paging mode select
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; available
<br>
<br>
&nbsp; &nbsp;0BH &nbsp; &nbsp; &nbsp; miscellaneous BIOS capabilities
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp; Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if light pen available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if save/restore video state available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (always 0 on MCGA)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if background intensity/blinking
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; control available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if get/set display combination code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= reserved
<br>
<br>
&nbsp; &nbsp;0CH─0DH &nbsp; reserved
<br>
&nbsp; &nbsp;0EH &nbsp; &nbsp; &nbsp; save area capabilities
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp; Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if supports 512-character sets
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if dynamic save area available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if alpha font override available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if graphics font override available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if palette override available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if display combination code extension
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= reserved
<br>
<br>
&nbsp; &nbsp;0FH &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 1CH (28)
<br>
Save or restore video state
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Saves or restores the digital-to-analog converter (DAC) state and color
<br>
&nbsp;registers, ROM BIOS video driver data area, or video hardware state.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1CH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; to get state buffer size
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; to save state
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; to restore state
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= requested states
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; save/restore video hardware state
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; save/restore video BIOS data area
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; save/restore video DAC state and color registers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3─15 &nbsp; &nbsp; &nbsp;reserved
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function supported
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1CH
<br>
<br>
&nbsp;and, if called with AL = 00H
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= buffer block count (64 bytes per block)
<br>
<br>
&nbsp;or, if called with AL = 01H
<br>
<br>
&nbsp;State information placed in caller's buffer
<br>
<br>
&nbsp;or, if called with AL = 02H
<br>
<br>
&nbsp;Requested state restored according to contents of caller's buffer
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Subfunction 00H is used to determine the size of buffer that will be
<br>
&nbsp; &nbsp;necessary to contain the specified state information. The caller must
<br>
&nbsp; &nbsp;supply the buffer.
<br>
<br>
&nbsp;■ The current video state is altered during a save state operation (AL =
<br>
&nbsp; &nbsp;01H). If the requesting program needs to continue in the same video
<br>
&nbsp; &nbsp;state, it can follow the save state request with an immediate call to
<br>
&nbsp; &nbsp;restore the video state.
<br>
<br>
&nbsp;■ This function is supported on the VGA only.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 11H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Get equipment configuration
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the equipment list code word from the ROM BIOS.
<br>
<br>
Call with:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Returns:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= equipment list code word
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 1 if floppy disk drive(s) installed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 1 if math coprocessor installed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 1 if pointing device installed (PS/2)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2─3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; system board ram size (PC, see Note)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 16 KB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 32 KB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 48 KB
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 64 KB
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4─5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initial video mode
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;40-by-25 color text
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80-by-25 color text
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80-by-25 monochrome
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; number of floppy disk drives (if bit 0 =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 3
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;9─11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number of RS-232 ports installed
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if game adapter installed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if internal modem installed (PC and XT
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;only)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1 if serial printer attached (PCjr)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14─15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; number of printers installed
<br>
<br>
Note:
<br>
<br>
&nbsp;■ Bits 2─3 of the returned value are used only in the ROM BIOS for the
<br>
&nbsp; &nbsp;original IBM PC with the 64 KB system board and on the PCjr.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 12H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Get conventional memory size
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the amount of conventional memory available for use by MS-DOS and
<br>
&nbsp;application programs.
<br>
<br>
Call with:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Returns:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= memory size (in KB)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ On some early PC models, the amount of memory returned by this function
<br>
&nbsp; &nbsp;is controlled by the settings of the dip switches on the system board
<br>
&nbsp; &nbsp;and may not reflect all the memory that is physically present.
<br>
<br>
&nbsp;■ On the PC/AT, the value returned is the amount of functional memory
<br>
&nbsp; &nbsp;found during the power-on self-test, regardless of the memory size
<br>
&nbsp; &nbsp;configuration information stored in CMOS RAM.
<br>
<br>
&nbsp;■ The value returned does not reflect any extended memory (above the 1 MB
<br>
&nbsp; &nbsp;boundary) that may be installed on 80286 or 80386 machines such as the
<br>
&nbsp; &nbsp;PC/AT or PS/2 (Models 50 and above).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 00H
<br>
Reset disk system
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Resets the disk controller, recalibrates its attached drives (the
<br>
&nbsp;read/write arm is moved to cylinder 0), and prepares for disk I/O.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function should be called after a failed floppy disk Read, Write,
<br>
&nbsp; &nbsp;Verify, or Format request before retrying the operation.
<br>
<br>
&nbsp;■ If called with DL &gt;= 80H (i.e., selecting a fixed disk drive), the
<br>
&nbsp; &nbsp;floppy disk controller and then the fixed disk controller are reset. See
<br>
&nbsp; &nbsp;also Int 13H Function 0DH, which allows the fixed disk controller to be
<br>
&nbsp; &nbsp;reset without affecting the floppy disk controller.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 01H
<br>
Get disk system status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the status of the most recent disk operation.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status of previous disk operation
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; no error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; invalid command
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; address mark not found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; disk write-protected (F)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; sector not found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; reset failed (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; floppy disk removed (F)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; bad parameter table (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; DMA overrun (F)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; DMA crossed 64 KB boundary
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0AH &nbsp; &nbsp; &nbsp; bad sector flag (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0BH &nbsp; &nbsp; &nbsp; bad track flag (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0CH &nbsp; &nbsp; &nbsp; media type not found (F)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0DH &nbsp; &nbsp; &nbsp; invalid number of sectors on format (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0EH &nbsp; &nbsp; &nbsp; control data address mark detected (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0FH &nbsp; &nbsp; &nbsp; DMA arbitration level out of range (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10H &nbsp; &nbsp; &nbsp; uncorrectable CRC
<br>
Cyclic Redundancy Check code
<br>
or ECC
<br>
Error Checking and Correcting code
<br>
data error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11H &nbsp; &nbsp; &nbsp; ECC corrected data error (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;20H &nbsp; &nbsp; &nbsp; controller failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;40H &nbsp; &nbsp; &nbsp; seek failed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H &nbsp; &nbsp; &nbsp; disk timed-out (failed to respond)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AAH &nbsp; &nbsp; &nbsp; drive not ready (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BBH &nbsp; &nbsp; &nbsp; undefined error (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CCH &nbsp; &nbsp; &nbsp; write fault (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;E0H &nbsp; &nbsp; &nbsp; status register error (H)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFH &nbsp; &nbsp; &nbsp; sense operation failed (H)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;H = fixed disk only, F = floppy disk only
<br>
<br>
Note:
<br>
<br>
&nbsp;■ On fixed disks, error code 11H (ECC data error) indicates that a
<br>
&nbsp; &nbsp;recoverable error was detected during a preceding Read Sector (Int 13H
<br>
&nbsp; &nbsp;Function 02H) function.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 02H
<br>
Read sector
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads one or more sectors from disk into memory.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= cylinder
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sector
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= head
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors transferred
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ On fixed disks, the upper 2 bits of the 10-bit cylinder number are
<br>
&nbsp; &nbsp;placed in the upper 2 bits of register CL.
<br>
<br>
&nbsp;■ On fixed disks, error code 11H indicates that a read error occurred that
<br>
&nbsp; &nbsp;was corrected by the ECC algorithm; in this event, register AL contains
<br>
&nbsp; &nbsp;the burst length. The data returned is probably good, although there is
<br>
&nbsp; &nbsp;a small chance that the data was not corrected properly. If a
<br>
&nbsp; &nbsp;multi-sector transfer was requested, the operation was terminated after
<br>
&nbsp; &nbsp;the sector containing the read error.
<br>
<br>
&nbsp;■ On floppy disk drives, an error may result from the drive motor being
<br>
&nbsp; &nbsp;off at the time of the request. The ROM BIOS does not automatically wait
<br>
&nbsp; &nbsp;for the drive to come up to speed before attempting the read operation.
<br>
&nbsp; &nbsp;The requesting program should reset the floppy disk system (Int 13H
<br>
&nbsp; &nbsp;Function 00H) and retry the operation three times before assuming that
<br>
&nbsp; &nbsp;the error results from some other cause.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 03H
<br>
Write sector
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Writes one or more sectors from memory to disk.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= cylinder
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sector
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= head
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors transferred
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ On fixed disks, the upper 2 bits of the 10-bit cylinder number are
<br>
&nbsp; &nbsp;placed in the upper 2 bits of register CL.
<br>
<br>
&nbsp;■ On floppy disk drives, an error may result from the drive motor being
<br>
&nbsp; &nbsp;off at the time of the request. The ROM BIOS does not automatically wait
<br>
&nbsp; &nbsp;for the drive to come up to speed before attempting the write operation.
<br>
&nbsp; &nbsp;The requesting program should reset the floppy disk system (Int 13H
<br>
&nbsp; &nbsp;Function 00H) and retry the operation three times before assuming that
<br>
&nbsp; &nbsp;the error results from some other cause.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 04H
<br>
Verify sector
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Verifies the address fields of one or more sectors. No data is transferred
<br>
&nbsp;to or from memory by this operation.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= cylinder
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sector
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= head
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors verified
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ On PCs, PC/XTs, and PC/ATs with ROM BIOS dated earlier than 11/15/85,
<br>
&nbsp; &nbsp;ES:BX should point to a valid buffer.
<br>
<br>
&nbsp;■ On fixed disks, the upper 2 bits of the 10-bit cylinder number are
<br>
&nbsp; &nbsp;placed in the upper 2 bits of register CL.
<br>
<br>
&nbsp;■ This function can be used to test whether a readable media is in a
<br>
&nbsp; &nbsp;floppy disk drive. An error may result from the drive motor being off at
<br>
&nbsp; &nbsp;the time of the request, because the ROM BIOS does not automatically
<br>
&nbsp; &nbsp;wait for the drive to come up to speed before attempting the verify
<br>
&nbsp; &nbsp;operation. The requesting program should reset the floppy disk system
<br>
&nbsp; &nbsp;(Int 13H Function 00H) and retry the operation three times before
<br>
&nbsp; &nbsp;assuming that a readable floppy disk is not present.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 05H
<br>
Format track
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes disk sector and track address fields on the specified track.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= interleave (PC/XT fixed disks)
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= cylinder
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= head
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of address field list (except PC/XT fixed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;disk, see Note)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ On floppy disks, the address field list consists of a series of 4-byte
<br>
&nbsp; &nbsp;entries, one entry per sector, in the following format:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; &nbsp; Contents
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cylinder
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head
<br>
&nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sector
<br>
&nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sector-size code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; if 128 bytes per sector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; if 256 bytes per sector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; if 512 bytes per sector (standard)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; if 1024 bytes per sector
<br>
<br>
&nbsp;■ On floppy disks, the number of sectors per track is taken from the BIOS
<br>
&nbsp; &nbsp;floppy disk parameter table whose address is stored in the vector for
<br>
&nbsp; &nbsp;Int 1EH.
<br>
<br>
&nbsp;■ When this function is used for floppy disks on the PC/AT or PS/2, it
<br>
&nbsp; &nbsp;should be preceded by a call to Int 13H Function 17H to select the type
<br>
&nbsp; &nbsp;of medium to be formatted.
<br>
<br>
&nbsp;■ On fixed disks, the upper 2 bits of the 10-bit cylinder number are
<br>
&nbsp; &nbsp;placed in the upper 2 bits of register CL.
<br>
<br>
&nbsp;■ On PC/XT-286, PC/AT, and PS/2 fixed disks, ES:BX points to a 512-byte
<br>
&nbsp; &nbsp;buffer containing byte pairs for each physical disk sector, as follows:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; &nbsp; Contents
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 00H for good sector
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H for bad sector
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sector number
<br>
<br>
&nbsp; &nbsp;For example, to format a track with 17 sectors and an interleave of two,
<br>
&nbsp; &nbsp;ES:BX would point to the following 34-byte array at the beginning of a
<br>
&nbsp; &nbsp;512-byte buffer:
<br>
<br>
&nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;00h,01h,00h,0ah,00h,02h,00h,0bh,00h,03h,00h,0ch
<br>
&nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;00h,04h,00h,0dh,00h,05h,00h,0eh,00h,06h,00h,0fh
<br>
&nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;00h,07h,00h,10h,00h,08h,00h,11h,00h,09h
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 06H
<br>
Format bad track
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes a track, writing disk address fields and data sectors and
<br>
&nbsp;setting bad sector flags.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 06H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= interleave
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= cylinder
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= head
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is defined for PC/XT fixed disk drives only.
<br>
<br>
&nbsp;■ For additional information, see Notes for Int 13H Function 05H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 07H
<br>
Format drive
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Formats the entire drive, writing disk address fields and data sectors,
<br>
&nbsp;starting at the specified cylinder.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 07H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= interleave
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= cylinder
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is defined for PC/XT fixed disk drives only.
<br>
<br>
&nbsp;■ For additional information, see Notes for Int 13H Function 05H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 08H
<br>
Get drive parameters
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns various parameters for the specified drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 08H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive type (PC/AT and PS/2 floppy disks)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if 360 KB, 40 track, 5.25&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if 1.2 MB, 80 track, 5.25&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if 720 KB, 80 track, 3.5&quot;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; if 1.44 MB, 80 track, 3.5&quot;
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= low 8 bits of maximum cylinder number
<br>
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= bits 6─7 &nbsp;high-order 2 bits of maximum cylinder number
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bits 0─5 &nbsp;maximum sector number
<br>
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= maximum head number
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of drives
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of disk drive parameter table
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ On the PC and PC/XT, this function is supported on fixed disks only.
<br>
<br>
&nbsp;■ The value returned in register DL reflects the true number of physical
<br>
&nbsp; &nbsp;drives attached to the adapter for the requested drive.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 09H
<br>
Initialize fixed disk characteristics
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes the fixed disk controller for subsequent I/O operations, using
<br>
&nbsp;the values found in the ROM BIOS disk parameter block(s).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 09H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
&nbsp;and, on the PC/XT
<br>
&nbsp;Vector for Int 41H must point to disk parameter block
<br>
<br>
&nbsp;or, on the PC/AT and PS/2
<br>
&nbsp;Vector for Int 41H must point to disk parameter block for drive 0
<br>
&nbsp;Vector for Int 46H must point to disk parameter block for drive 1
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is supported on fixed disks only.
<br>
<br>
&nbsp;■ For PC and PC/XT fixed disks, the parameter block format is as follows:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Contents
<br>
&nbsp; &nbsp;00H─01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maximum number of cylinders
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maximum number of heads
<br>
&nbsp; &nbsp;03H─04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; starting reduced write current cylinder
<br>
&nbsp; &nbsp;05H─06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; starting write precompensation cylinder
<br>
&nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maximum ECC burst length
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drive options
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drive option
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3─5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reserved (0)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; disable ECC retries
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; disable disk-access retries
<br>
<br>
&nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standard time-out value
<br>
&nbsp; &nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time-out value for format drive
<br>
&nbsp; &nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time-out value for check drive
<br>
&nbsp; &nbsp;0CH─0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reserved
<br>
<br>
&nbsp;■ For PC/AT and PS/2 fixed disks, the parameter block format is as
<br>
&nbsp; &nbsp;follows:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Contents
<br>
&nbsp; &nbsp;00H─01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maximum number of cylinders
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maximum number of heads
<br>
&nbsp; &nbsp;03H─04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp;05H─06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; starting write precompensation cylinder
<br>
&nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maximum ECC burst length
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drive options
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0─2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; more than 8 heads
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; manufacturer's defect map present at
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;maximum
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cylinder + 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6─7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonzero (10, 01, or 11) if retries
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;disabled
<br>
<br>
&nbsp; &nbsp;09H─0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp;0CH─0DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; landing zone cylinder
<br>
&nbsp; &nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sectors per track
<br>
&nbsp; &nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reserved
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 0AH (10)
<br>
Read sector long
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads a sector or sectors from disk into memory, along with a 4-byte ECC
<br>
&nbsp;code for each sector.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0AH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= cylinder
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sector (see Notes)
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= head
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors transferred
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is supported on fixed disks only.
<br>
<br>
&nbsp;■ The upper 2 bits of the 10-bit cylinder number are placed in the upper 2
<br>
&nbsp; &nbsp;bits of register CL.
<br>
<br>
&nbsp;■ Unlike the normal Read Sector function (Int 13H Function 02H), ECC
<br>
&nbsp; &nbsp;errors are not automatically corrected. Multisector transfers are
<br>
&nbsp; &nbsp;terminated after any sector with a read error.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 0BH (11)
<br>
Write sector long
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Writes a sector or sectors from memory to disk. Each sector's worth of
<br>
&nbsp;data must be followed by its 4-byte ECC code.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= cylinder
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sector (see Notes)
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= head
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of sectors transferred
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is supported on fixed disks only.
<br>
<br>
&nbsp;■ The upper 2 bits of the 10-bit cylinder number are placed in the upper 2
<br>
&nbsp; &nbsp;bits of register CL.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 0CH (12)
<br>
Seek
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Positions the disk read/write heads to the specified cylinder, but does
<br>
&nbsp;not transfer any data.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0CH
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= lower 8 bits of cylinder
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= upper 2 bits of cylinder in bits 6─7
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= head
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is supported on fixed disks only.
<br>
<br>
&nbsp;■ The upper 2 bits of the 10-bit cylinder number are placed in the upper 2
<br>
&nbsp; &nbsp;bits of register CL.
<br>
<br>
&nbsp;■ The Read Sector, Read Sector Long, Write Sector, and Write Sector Long
<br>
&nbsp; &nbsp;functions include an implied seek operation and need not be preceded by
<br>
&nbsp; &nbsp;an explicit call to this function.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 0DH (13)
<br>
Reset fixed disk system
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Resets the fixed disk controller, recalibrates attached drives (moves the
<br>
&nbsp;read/write arm to cylinder 0), and prepares for subsequent disk I/O.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0DH
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is supported on fixed disks only. It differs from Int 13H
<br>
&nbsp; &nbsp;Function 00H in that the floppy disk controller is not reset.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 0EH (14)
<br>
Read sector buffer
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Transfers the contents of the fixed disk adapter's internal sector buffer
<br>
&nbsp;to system memory. No data is read from the physical disk drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0EH
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is supported by the PC/XT's fixed disk adapter only. It is
<br>
&nbsp; &nbsp;not defined for fixed disk adapters on the PC/AT or PS/2.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 0FH (15)
<br>
Write sector buffer
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Transfers data from system memory to the fixed disk adapter's internal
<br>
&nbsp;sector buffer. No data is written to the physical disk drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0FH
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is supported by the PC/XT's fixed disk adapter only. It is
<br>
&nbsp; &nbsp;not defined for fixed disk adapters on the PC/AT or PS/2.
<br>
<br>
&nbsp;■ This function should be called to initialize the contents of the sector
<br>
&nbsp; &nbsp;buffer before formatting the drive with Int 13H Function 05H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 10H (16)
<br>
Get drive status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Tests whether the specified fixed disk drive is operational and returns
<br>
&nbsp;the drive's status.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is supported on fixed disks only.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 11H (17)
<br>
Recalibrate drive
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Causes the fixed disk adapter to recalibrate itself for the specified
<br>
&nbsp;drive, positioning the read/write arm to cylinder 0, and returns the
<br>
&nbsp;drive's status.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is supported on fixed disks only.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 12H (18)
<br>
Controller RAM diagnostic
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Causes the fixed disk adapter to carry out a built-in diagnostic test on
<br>
&nbsp;its internal sector buffer, indicating whether the test was passed by the
<br>
&nbsp;returned status.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is supported on PC/XT fixed disks only.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 13H (19)
<br>
Controller drive diagnostic
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Causes the fixed disk adapter to run internal diagnostic tests of the
<br>
&nbsp;attached drive, indicating whether the test was passed by the returned
<br>
&nbsp;status.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 13H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is supported on PC/XT fixed disks only.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 14H (20)
<br>
Controller internal diagnostic
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Causes the fixed disk adapter to carry out a built-in diagnostic
<br>
&nbsp;self-test, indicating whether the test was passed by the returned status.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 14H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is supported on fixed disks only.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 15H (21)
<br>
Get disk type
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a code indicating the type of floppy or fixed disk referenced by
<br>
&nbsp;the specified drive code.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 15H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive type code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if no drive present
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if floppy disk drive without change-line support
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if floppy disk drive with change-line support
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if fixed disk
<br>
<br>
&nbsp;and, if fixed disk (AH = 03H)
<br>
<br>
&nbsp;CX:DX &nbsp; &nbsp; &nbsp; &nbsp; = number of 512-byte sectors
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is not supported on the PC or PC/XT.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 16H (22)
<br>
Get disk change status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the status of the change line, indicating whether the disk in the
<br>
&nbsp;drive may have been replaced since the last disk access.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 16H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If change line inactive (disk has not been changed)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If change line active (disk may have been changed)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 06H
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If this function returns with the carry flag set, the disk has not
<br>
&nbsp; &nbsp;necessarily been changed; the change line can be activated by simply
<br>
&nbsp; &nbsp;unlocking and locking the disk drive door without removing the floppy
<br>
&nbsp; &nbsp;disk.
<br>
<br>
&nbsp;■ This function is not supported for floppy disks on the PC or PC/XT.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 17H (23)
<br>
Set disk type
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects a floppy disk type for the specified drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 17H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= floppy disk type code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; not used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; 320/360 KB floppy disk in 360 KB drive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; 320/360 KB floppy disk in 1.2 MB drive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; 1.2 MB floppy disk in 1.2 MB drive
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; 720 KB floppy disk in 720 KB drive
<br>
&nbsp;SL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is not supported for floppy disks on the PC or PC/XT.
<br>
<br>
&nbsp;■ If the change line is active for the specified drive, it is reset. The
<br>
&nbsp; &nbsp;ROM BIOS then sets the data rate for the specified drive and media type.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 18H (24)
<br>
Set media type for format
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects media characteristics for the specified drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 18H
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of cylinders
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sectors per track
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; floppy disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of disk parameter table for media type
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ A floppy disk must be present in the drive.
<br>
<br>
&nbsp;■ This function should be called prior to formatting a disk with Int 13H
<br>
&nbsp; &nbsp;Function 05H so that the ROM BIOS can set the correct data rate for the
<br>
&nbsp; &nbsp;media.
<br>
<br>
&nbsp;■ If the change line is active for the specified drive, it is reset.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 19H (25)
<br>
Park heads
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Moves the read/write arm to a track that is not used for data storage, so
<br>
&nbsp;that data will not be damaged when the drive is turned off.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 19H
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is defined for PS/2 fixed disks only.
<br>
<br>

<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 1AH (26)
<br>
Format ESDI drive
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes disk sector and track address fields on a drive attached to
<br>
&nbsp;the ESDI Fixed Disk Drive Adapter/A.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 1AH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= relative block address (RBA) defect table count
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; if no RBA table
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&gt;0 &nbsp; &nbsp; &nbsp; &nbsp;if RBA table used
<br>
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= format modifier bits
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; ignore primary defect map
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; ignore secondary defect map
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; update secondary defect map (see Notes)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; perform extended surface analysis
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; generate periodic interrupt (see Notes)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5─7 &nbsp; &nbsp; &nbsp; reserved (must be 0)
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= drive
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─FFH &nbsp; fixed disk
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of RBA table
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 13H Function 01H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This operation is sometimes called a &quot;low level format&quot; and prepares the
<br>
&nbsp; &nbsp;disk for physical read/write operations at the sector level. The drive
<br>
&nbsp; &nbsp;must be subsequently partitioned with the FDISK command and then given a
<br>
&nbsp; &nbsp;&quot;high level format&quot; with the FORMAT command to install a file system.
<br>
<br>
&nbsp;■ If bit 4 of register CL is set, Int 15H is called with AH = 0FH and AL
<br>
&nbsp; &nbsp;= phase code after each cylinder is formatted or analyzed. The phase
<br>
&nbsp; &nbsp;code is defined as:
<br>
<br>
&nbsp; &nbsp;0 = reserved
<br>
&nbsp; &nbsp;1 = surface analysis
<br>
&nbsp; &nbsp;2 = formatting
<br>
<br>
&nbsp; &nbsp;See also Int 15H Function 0FH.
<br>
<br>
&nbsp;■ If bit 2 of register CL is set, the drive's secondary defect map is
<br>
&nbsp; &nbsp;updated to reflect errors found during surface analysis. If both bit 2
<br>
&nbsp; &nbsp;and bit 1 are set, the secondary defect map is replaced.
<br>
<br>
&nbsp;■ For an extended surface analysis, the disk should first be formatted by
<br>
&nbsp; &nbsp;calling this function with bit 3 cleared, then analyzed by calling this
<br>
&nbsp; &nbsp;function with bit 3 set.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 00H
<br>
Initialize communications port
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes a serial communications port to a desired baud rate, parity,
<br>
&nbsp;word length, and number of stop bits.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= initialization parameter (see Notes)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= communications port number (0 = COM1, 1 = COM2, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= port status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; receive data ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; overrun error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; parity error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; framing error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; break detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; transmit holding register empty
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; transmit shift register empty
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; timed-out
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= modem status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; change in clear-to-send status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; change in data-set-ready status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; trailing edge ring indicator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; change in receive line signal detect
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; clear-to-send
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; data-set-ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; ring indicator
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; receive line signal detect
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The initialization parameter byte is defined as follows:
<br>
<br>
&nbsp; &nbsp;7 6 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 0
<br>
&nbsp; &nbsp;Baud rate &nbsp; &nbsp; &nbsp; &nbsp; Parity &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Stop bits &nbsp; &nbsp; &nbsp; &nbsp; Word length
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;000 = 110 &nbsp; &nbsp; &nbsp; &nbsp; X0 = none &nbsp; &nbsp; &nbsp; &nbsp; 0 = 1 bit &nbsp; &nbsp; &nbsp; &nbsp; 10 = 7 bits
<br>
&nbsp; &nbsp;001 = 150 &nbsp; &nbsp; &nbsp; &nbsp; 01 = odd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = 2 bits &nbsp; &nbsp; &nbsp; &nbsp;11 = 8 bits
<br>
&nbsp; &nbsp;010 = 300 &nbsp; &nbsp; &nbsp; &nbsp; 11 = even
<br>
&nbsp; &nbsp;011 = 600
<br>
&nbsp; &nbsp;100 = 1200
<br>
&nbsp; &nbsp;101 = 2400
<br>
&nbsp; &nbsp;110 = 4800
<br>
&nbsp; &nbsp;111 = 9600
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;■ To initialize the serial port for data rates greater than 9600 baud on
<br>
&nbsp; &nbsp;PS/2 machines, see Int 14H Functions 04H and 05H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 01H
<br>
Write character to communications port
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Writes a character to the specified serial communications port, returning
<br>
&nbsp;the current status of the port.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= communications port number (0 = COM1, 1 = COM2, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH bit 7 &nbsp; &nbsp; &nbsp;= 0
<br>
&nbsp;AH bits &nbsp; &nbsp; &nbsp; = port status
<br>
&nbsp;0─6
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; receive data ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; overrun error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; parity error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; framing error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; break detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; transmit holding register empty
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; transmit shift register empty
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character (unchanged)
<br>
<br>
&nbsp;If function unsuccessful (timed-out)
<br>
<br>
&nbsp;AH bit 7 &nbsp; &nbsp; &nbsp;= 1
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character (unchanged)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 02H
<br>
Read character from communications port
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads a character from the specified serial communications port, also
<br>
&nbsp;returning the port's status.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= communications port number (0 = COM1, 1 = COM2, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH bit 7 &nbsp; &nbsp; &nbsp;= 0
<br>
&nbsp;AH bits 0─6 &nbsp; = status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; overrun error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; parity error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; framing error detected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; break detected
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character
<br>
<br>
&nbsp;If function unsuccessful (timed-out)
<br>
<br>
&nbsp;AH bit 7 &nbsp; &nbsp; &nbsp;= 1
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 03H
<br>
Get communications port status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the status of the specified serial communications port.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= communications port number (0 = COM1, 1 = COM2, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= port status (see Int 14H Function 00H)
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= modem status (see Int 14H Function 00H)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 04H
<br>
Extended initialize communications port
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes a serial communications port to a desired baud rate, parity,
<br>
&nbsp;word length, and number of stop bits. Provides a superset of Int 14H
<br>
&nbsp;Function 00H capabilities for PS/2 machines.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= break flag
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; no break
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; break
<br>
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= parity
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; none
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; odd
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; even
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; stick parity odd
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; stick parity even
<br>
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= stop bits
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; 1 stop bit
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; 2 stop bits if word length = 6─8 bits
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; 1.5 stop bits if word length = 5 bits
<br>
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= word length
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; 5 bits
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; 6 bits
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; 7 bits
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; 8 bits
<br>
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= baud rate
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; 110 baud
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; 150 baud
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; 300 baud
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; 600 baud
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; 1200 baud
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; 2400 baud
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; 4800 baud
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; 9600 baud
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; 19,200 baud
<br>
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= communications port number (0 = COM1, 1 = COM2, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= port status (see Int 14H Function 00H)
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= modem status (see Int 14H Function 00H)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 05H
<br>
Extended communications port control
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads or sets the modem control register (MCR) for the specified serial
<br>
&nbsp;communications port.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; to read modem control register
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; to write modem control register
<br>
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= modem control register contents (if AL = 01H)
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; data-terminal ready
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; request-to-send
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; Out1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; Out2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; loop (for testing)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5─7 &nbsp; &nbsp; &nbsp; reserved
<br>
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= communications port number (0 = COM1, 1 = COM2, etc.)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If called with AL = 00H
<br>
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= modem control register contents (see above)
<br>
<br>
&nbsp;If called with AL = 01H
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= port status (see Int 14H Function 00H)
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= modem status (see Int 14H Function 00H)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 00H
<br>
Turn on cassette motor
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Turns on the motor of the cassette tape drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;86H &nbsp; &nbsp; &nbsp; if cassette not present
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is available only on the PC and the PCjr. It is not
<br>
&nbsp; &nbsp;supported on the PC/XT and all subsequent models.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 01H
<br>
Turn off cassette motor
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Turns off the motor of the cassette tape drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;86H &nbsp; &nbsp; &nbsp; if cassette not present
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is available only on the PC and the PCjr. It is not
<br>
&nbsp; &nbsp;supported on the PC/XT and all subsequent models.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 02H
<br>
Read cassette
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads one or more 256-byte blocks of data from the cassette tape drive to
<br>
&nbsp;memory.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of bytes to read
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of bytes actually read
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset + 1 of last byte read
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if CRC error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if bit signals scrambled
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; if no data found
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H &nbsp; &nbsp; &nbsp; if invalid command
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;86H &nbsp; &nbsp; &nbsp; if cassette not present
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is available only on the PC and on the PCjr. It is not
<br>
&nbsp; &nbsp;supported on the PC/XT and all subsequent models.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 03H
<br>
Write cassette
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Writes one or more 256-byte blocks of data from memory to the cassette
<br>
&nbsp;tape drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of bytes to write
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset + 1 of last byte written
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H &nbsp; &nbsp; &nbsp; if invalid command
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;86H &nbsp; &nbsp; &nbsp; if cassette not present
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is available only on the PC and on the PCjr. It is not
<br>
&nbsp; &nbsp;supported on the PC/XT and all subsequent models.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 0FH (15)
<br>
Format ESDI drive periodic interrupt
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Invoked by the ROM BIOS on the ESDI Fixed Disk Drive Adapter/A during a
<br>
&nbsp;format or surface analysis operation after each cylinder is completed.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0FH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= phase code
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = surface analysis
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 = formatting
<br>
<br>
Returns:
<br>
<br>
&nbsp;If formatting or analysis should continue
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If formatting or analysis should be terminated
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function call can be captured by a program so that it will be
<br>
&nbsp; &nbsp;notified as each cylinder is formatted or analyzed. The program can
<br>
&nbsp; &nbsp;count interrupts for each phase to determine the current cylinder
<br>
&nbsp; &nbsp;number.
<br>
<br>
&nbsp;■ The default ROM BIOS handler for this function returns with the carry
<br>
&nbsp; &nbsp;flag set.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 21H (33) Subfunction 00H
<br>
Read POST error log
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns error information that was accumulated during the most recent
<br>
&nbsp;power-on self-test (POST).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 21H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of POST error codes stored
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of POST error log
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H = &nbsp; &nbsp; invalid command
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;86H = &nbsp; &nbsp; function not supported
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The error log consists of single-word entries. The first byte of an
<br>
&nbsp; &nbsp;entry is the device error code, and the second is the device identifier.
<br>
<br>
&nbsp;■ This function is not available on the PS/2 Models 25 and 30.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 21H (33) Subfunction 01H
<br>
Write POST error log
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Adds an entry to the power-on self-test (POST) error log.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 21H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device identifier
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device error code
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = &nbsp; &nbsp; error list full
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H = &nbsp; &nbsp; invalid command
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;86H = &nbsp; &nbsp; function not supported
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is not available on the PS/2 Models 25 and 30.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 4FH (79)
<br>
Keyboard intercept
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Invoked for each keystroke by the ROM BIOS's Int 09H keyboard interrupt
<br>
&nbsp;handler.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4FH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= scan code
<br>
<br>
Returns:
<br>
<br>
&nbsp;If scan code consumed
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If scan code not consumed
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= unchanged or new scan code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ An operating system or a resident utility can capture this function to
<br>
&nbsp; &nbsp;filter the raw keyboard data stream. The new handler can substitute a
<br>
&nbsp; &nbsp;new scan code, return the same scan code, or return the carry flag clear
<br>
&nbsp; &nbsp;causing the keystroke to be discarded. The default ROM BIOS routine
<br>
&nbsp; &nbsp;simply returns the scan code unchanged.
<br>
<br>
&nbsp;■ A program can call Int 15H Function C0H to determine whether the host
<br>
&nbsp; &nbsp;machine's ROM BIOS supports this keyboard intercept.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 80H (128)
<br>
Device open
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Acquires ownership of a logical device for a process.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 80H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device ID
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= process ID
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function call, along with Int 15H Functions 81H and 82H, defines
<br>
&nbsp; &nbsp;a simple protocol that can be used to arbitrate usage of devices by
<br>
&nbsp; &nbsp;multiple processes. A multitasking program manager would be expected to
<br>
&nbsp; &nbsp;capture Int 15H and provide the appropriate service. The default BIOS
<br>
&nbsp; &nbsp;routine for this function simply returns with the carry flag clear and
<br>
&nbsp; &nbsp;AH = 00H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 81H (129)
<br>
Device close
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Releases ownership of a logical device for a process.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 81H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device ID
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= process ID
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
Note:
<br>
<br>
&nbsp;■ A multitasking program manager would be expected to capture Int 15H and
<br>
&nbsp; &nbsp;provide the appropriate service. The default BIOS routine for this
<br>
&nbsp; &nbsp;function simply returns with the carry flag clear and AH = 00H. See also
<br>
&nbsp; &nbsp;Int 15H Functions 80H and 82H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 82H (130)
<br>
Process termination
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Releases ownership of all logical devices for a process that is about to
<br>
&nbsp;terminate.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 82H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= process ID
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
Note:
<br>
<br>
&nbsp;■ A multitasking program manager would be expected to capture Int 15H and
<br>
&nbsp; &nbsp;provide the appropriate service. The default BIOS routine for this
<br>
&nbsp; &nbsp;function simply returns with the carry flag clear and AH = 00H. See also
<br>
&nbsp; &nbsp;Int 15H Functions 80H and 81H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 83H (131)
<br>
Event wait
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Requests setting of a semaphore after a specified interval or cancels a
<br>
&nbsp;previous request.
<br>
<br>
Call with:
<br>
<br>
&nbsp;If requesting event wait
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 83H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;CX:DX &nbsp; &nbsp; &nbsp; &nbsp; = microseconds
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of semaphore byte
<br>
<br>
&nbsp;If canceling event wait
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 83H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If called with AL = 00H, and function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If called with AL = 00H, and function unsuccessful (Event Wait already
<br>
&nbsp;active)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
&nbsp;If called with AL = 01H
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The function call returns immediately. If the function is successful,
<br>
&nbsp; &nbsp;bit 7 of the semaphore byte is set when the specified interval has
<br>
&nbsp; &nbsp;elapsed. The calling program is responsible for clearing the semaphore
<br>
&nbsp; &nbsp;before requesting this function.
<br>
<br>
&nbsp;■ The actual duration of an event wait is always an integral multiple of
<br>
&nbsp; &nbsp;976 microseconds. The CMOS date/clock chip interrupts are used to
<br>
&nbsp; &nbsp;implement this function.
<br>
<br>
&nbsp;■ Use of this function allows programmed, hardware-independent delays at a
<br>
&nbsp; &nbsp;finer resolution than can be obtained through use of the MS-DOS Get Time
<br>
&nbsp; &nbsp;function (Int 21H Function 2CH, which returns time in hundredths of a
<br>
&nbsp; &nbsp;second).
<br>
<br>
&nbsp;■ See also Int 15H Function 86H, which suspends the calling program for
<br>
&nbsp; &nbsp;the specified interval in milliseconds.
<br>
<br>
&nbsp;■ This function is not supported on the PS/2 Models 25 and 30.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 84H (132)
<br>
Read joystick
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the joystick switch settings and potentiometer values.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 84H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; to read switch settings
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; to read resistive inputs
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if called with DX = 00H
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= switch settings (bits 4─7)
<br>
<br>
&nbsp;or, if called with DX = 01H
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= A(x) value
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= A(y) value
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= B(x) value
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= B(y) value
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ An error condition is returned if DX does not contain a valid
<br>
&nbsp; &nbsp;subfunction number.
<br>
<br>
&nbsp;■ If no game adapter is installed, AL is returned as 00H for Subfunction
<br>
&nbsp; &nbsp;00H (i.e., all switches open); AX, BX, CX, and DX are returned
<br>
&nbsp; &nbsp;containing 00H for Subfunction 01H.
<br>
<br>
&nbsp;■ Using a 250 KOhm joystick, the potentiometer values usually lie within
<br>
&nbsp; &nbsp;the srange 0─416 (0000─01A0H).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 85H (133)
<br>
SysReq key
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Invoked by the ROM BIOS keyboard driver when the SysReq key is detected.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 85H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= key status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if key make (depression)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if key break (release)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The ROM BIOS handler for this function call is a dummy routine that
<br>
&nbsp; &nbsp;always returns a success status unless called with an invalid
<br>
&nbsp; &nbsp;subfunction number in AL. A multitasking program manager would be
<br>
&nbsp; &nbsp;expected to capture Int 15H so that it can be notified when the user
<br>
&nbsp; &nbsp;strikes the SysReq key.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 86H (134)
<br>
Delay
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Suspends the calling program for a specified interval in microseconds.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 86H
<br>
&nbsp;CX:DX &nbsp; &nbsp; &nbsp; &nbsp; = microseconds to wait
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (wait was performed)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful (wait was not performed)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The actual duration of the wait is always an integral multiple of 976
<br>
&nbsp; &nbsp;microseconds.
<br>
<br>
&nbsp;■ Use of this function allows programmed, hardware-independent delays at a
<br>
&nbsp; &nbsp;finer resolution than can be obtained through use of the MS-DOS Get Time
<br>
&nbsp; &nbsp;function (Int 21H Function 2CH, which returns time in hundredths of a
<br>
&nbsp; &nbsp;second).
<br>
<br>
&nbsp;■ See also Int 15H Function 83H, which triggers a semaphore after a
<br>
&nbsp; &nbsp;specified interval but does not suspend the calling program.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 87H (135)
<br>
Move extended memory block
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Transfers data between conventional memory and extended memory.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 87H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of words to move
<br>
&nbsp;ES:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of Global Descriptor Table (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if RAM parity error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if exception interrupt error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if gate address line 20 failed
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Conventional memory lies at addresses below the 640 KB boundary, and is
<br>
&nbsp; &nbsp;used for the execution of MS-DOS and its application programs. Extended
<br>
&nbsp; &nbsp;memory lies at addresses above 1 MB, and can only be accessed by an
<br>
&nbsp; &nbsp;80286 or 80386 CPU running in protected mode. As much as 15 MB of
<br>
&nbsp; &nbsp;extended memory can be installed in an IBM PC/AT or compatible.
<br>
<br>
&nbsp;■ The Global Descriptor Table (GDT) used by this function must be set up
<br>
&nbsp; &nbsp;as follows:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; &nbsp; Contents
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H─0FH &nbsp; &nbsp; reserved (should be 0)
<br>
&nbsp; &nbsp;10H─11H &nbsp; &nbsp; segment length in bytes (2*CX - 1 or greater)
<br>
&nbsp; &nbsp;12H─14H &nbsp; &nbsp; 24-bit source address
<br>
&nbsp; &nbsp;15H &nbsp; &nbsp; &nbsp; &nbsp; access rights byte (always 93H)
<br>
&nbsp; &nbsp;16H─17H &nbsp; &nbsp; reserved (should be 0)
<br>
&nbsp; &nbsp;18H─19H &nbsp; &nbsp; segment length in bytes (2*CX - 1 or greater)
<br>
&nbsp; &nbsp;1AH─1CH &nbsp; &nbsp; 24-bit destination address
<br>
&nbsp; &nbsp;1DH &nbsp; &nbsp; &nbsp; &nbsp; access rights byte (always 93H)
<br>
&nbsp; &nbsp;1EH─2FH &nbsp; &nbsp; reserved (should be 0)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;The table is composed of six 8-byte descriptors to be used by the CPU in
<br>
&nbsp; &nbsp;protected mode. The four descriptors in offsets 00H─0FH and 20H─2FH are
<br>
&nbsp; &nbsp;filled in by the ROM BIOS before the CPU mode switch.
<br>
<br>
&nbsp;■ The addresses used in the descriptor table are linear (physical) 24-bit
<br>
&nbsp; &nbsp;addresses in the range 000000H─FFFFFFH──not segments and offsets──with
<br>
&nbsp; &nbsp;the least significant byte at the lowest address and the most
<br>
&nbsp; &nbsp;significant byte at the highest address.
<br>
<br>
&nbsp;■ The block move is performed with interrupts disabled; thus, use of this
<br>
&nbsp; &nbsp;function may interfere with the operation of communications programs,
<br>
&nbsp; &nbsp;network drivers, or other software that relies on prompt servicing of
<br>
&nbsp; &nbsp;hardware interrupts.
<br>
<br>
&nbsp;■ Programs and drivers that access extended memory with this function
<br>
&nbsp; &nbsp;cannot be executed in the Compatibility Environment of OS/2.
<br>
<br>
&nbsp;■ This function is not supported on the PS/2 Models 25 and 30.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 88H (136)
<br>
Get extended memory size
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the amount of extended memory installed in the system.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 88H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= amount of extended memory (in KB)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Extended memory is memory at addresses above 1 MB, which can only be
<br>
&nbsp; &nbsp;accessed by an 80286 or 80386 CPU running in protected mode. Because
<br>
&nbsp; &nbsp;MS-DOS is a real-mode operating system, extended memory can be used for
<br>
&nbsp; &nbsp;storage of volatile data but cannot be used for execution of programs.
<br>
<br>
&nbsp;■ Programs and drivers that use this function cannot be executed in the
<br>
&nbsp; &nbsp;Compatibility Environment of OS/2.
<br>
<br>
&nbsp;■ This function is not supported on the PS/2 Models 25 and 30.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 89H (137)
<br>
Enter protected mode
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Switches the CPU from real mode into protected mode.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 89H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= interrupt number for IRQ0, written to ICW2 of 8259 PIC #1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(must be evenly divisible by 8, determines IRQ0─IRQ7)
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= interrupt number for IRQ8, written to ICW2 of 8259 PIC #2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(must be evenly divisible by 8, determines IRQ8─IRQ15)
<br>
&nbsp;ES:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of Global Descriptor Table (GDT)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful (CPU is in protected mode)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;CS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= user-defined selector
<br>
&nbsp;DS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= user-defined selector
<br>
&nbsp;ES &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= user-defined selector
<br>
&nbsp;SS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= user-defined selector
<br>
<br>
&nbsp;If function unsuccessful (CPU is in real mode)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The Global Descriptor Table must contain eight descriptors set up as
<br>
&nbsp; &nbsp;follows:
<br>
<br>
&nbsp; &nbsp;Offset &nbsp; &nbsp; &nbsp;Descriptor usage
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; dummy descriptor (initialized to 0)
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; Global Descriptor Table (GDT)
<br>
&nbsp; &nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; Interrupt Descriptor Table (IDT)
<br>
&nbsp; &nbsp;18H &nbsp; &nbsp; &nbsp; &nbsp; user's data segment (DS)
<br>
&nbsp; &nbsp;20H &nbsp; &nbsp; &nbsp; &nbsp; user's extra segment (ES)
<br>
&nbsp; &nbsp;28H &nbsp; &nbsp; &nbsp; &nbsp; user's stack segment (SS)
<br>
&nbsp; &nbsp;30H &nbsp; &nbsp; &nbsp; &nbsp; user's code segment (CS)
<br>
&nbsp; &nbsp;38H &nbsp; &nbsp; &nbsp; &nbsp; BIOS code segment
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;The user must initialize the first seven descriptors; the eighth is
<br>
&nbsp; &nbsp;filled in by the ROM BIOS to provide addressability for its own
<br>
&nbsp; &nbsp;execution. The calling program may modify and use the eighth descriptor
<br>
&nbsp; &nbsp;for any purpose after return from this function call.
<br>
<br>
&nbsp;■ This function is not supported on the PS/2 Models 25 and 30.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 90H (144)
<br>
Device wait
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Invoked by the ROM BIOS fixed disk, floppy disk, printer, network, and
<br>
&nbsp;keyboard drivers prior to performing a programmed wait for I/O completion.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 90H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device type
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; serially reusable devices
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─BFH &nbsp; reentrant devices
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C0H─FFH &nbsp; wait-only calls, no corresponding Post function
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of request block for device types 80H─FFH
<br>
<br>
Returns:
<br>
<br>
&nbsp;If no wait (driver must perform its own time-out)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If wait was performed
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Predefined device types are:
<br>
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; disk (may time-out)
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; floppy disk (may time-out)
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; keyboard (no time-out)
<br>
&nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; pointing device (PS/2, may time-out)
<br>
&nbsp; &nbsp;80H &nbsp; &nbsp; &nbsp; &nbsp; network (no time-out)
<br>
&nbsp; &nbsp;FCH &nbsp; &nbsp; &nbsp; &nbsp; fixed disk reset (PS/2, may time-out)
<br>
&nbsp; &nbsp;FDH &nbsp; &nbsp; &nbsp; &nbsp; floppy disk drive motor start (may time-out)
<br>
&nbsp; &nbsp;FEH &nbsp; &nbsp; &nbsp; &nbsp; printer (may time-out)
<br>
<br>
&nbsp;■ For network adapters, ES:BX points to a network control block (NCB).
<br>
<br>
&nbsp;■ A multitasking program manager would be expected to capture Int 15H
<br>
&nbsp; &nbsp;Function 90H so that it can dispatch other tasks while I/O is in
<br>
&nbsp; &nbsp;progress. The default BIOS routine for this function simply returns with
<br>
&nbsp; &nbsp;the carry flag clear and AH = 00H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 91H (145)
<br>
Device post
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Invoked by the ROM BIOS fixed disk, floppy disk, network, and keyboard
<br>
&nbsp;drivers to signal that I/O is complete and/or the device is ready.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 91H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device type
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H─7FH &nbsp; serially reusable devices
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;80H─BFH &nbsp; reentrant devices
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of request block for device types 80H─BFH
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Predefined device types that may use Device Post are:
<br>
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; disk (may time-out)
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; floppy disk (may time-out)
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; keyboard (no time-out)
<br>
&nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; pointing device (PS/2, may time-out)
<br>
&nbsp; &nbsp;80H &nbsp; &nbsp; &nbsp; &nbsp; network (no time-out)
<br>
<br>
&nbsp;■ The ROM BIOS printer routine does not invoke this function because
<br>
&nbsp; &nbsp;printer output is not interrupt driven.
<br>
<br>
&nbsp;■ A multitasking program manager would be expected to capture Int 15H
<br>
&nbsp; &nbsp;Function 91H so that it can be notified when I/O is completed and
<br>
&nbsp; &nbsp;awaken the requesting task. The default BIOS routine for this function
<br>
&nbsp; &nbsp;simply returns with the carry flag clear and AH = 00H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function C0H (192)
<br>
Get system environment
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a pointer to a table containing various information about the
<br>
&nbsp;system configuration.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C0H
<br>
<br>
Returns:
<br>
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of configuration table (see Notes)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The format of the system configuration table is as follows:
<br>
<br>
&nbsp; &nbsp;Byte(s) &nbsp; Contents
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H─01H &nbsp; length of table in bytes
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; system model (see following Note)
<br>
&nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; system submodel (see following Note)
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; BIOS revision level
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; configuration flags
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Micro Channel implemented
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;extended BIOS data area allocated
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Wait for External Event is available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;keyboard intercept (Int 15H Function
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4FH) available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;real-time clock available
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;slave 8259 present (cascaded IRQ2)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DMA channel 3 used
<br>
&nbsp; &nbsp;06H─09H &nbsp; reserved
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;■ The system model and type bytes are assigned as follows:
<br>
<br>
&nbsp; &nbsp;Machine &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Model byte &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Submodel byte
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;PC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FFH
<br>
&nbsp; &nbsp;PC/XT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FEH
<br>
&nbsp; &nbsp;PC/XT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FBH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 00H or 01H
<br>
&nbsp; &nbsp;PCjr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FDH
<br>
&nbsp; &nbsp;PC/AT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 00H or 01H
<br>
&nbsp; &nbsp;PC/XT-286 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 02H
<br>
&nbsp; &nbsp;PC Convertible &nbsp; &nbsp; &nbsp; F9H
<br>
&nbsp; &nbsp;PS/2 Model 30 &nbsp; &nbsp; &nbsp; &nbsp;FAH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 00H
<br>
&nbsp; &nbsp;PS/2 Model 50 &nbsp; &nbsp; &nbsp; &nbsp;FCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 04H
<br>
&nbsp; &nbsp;PS/2 Model 60 &nbsp; &nbsp; &nbsp; &nbsp;FCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 05H
<br>
&nbsp; &nbsp;PS/2 Model 70 &nbsp; &nbsp; &nbsp; &nbsp;F8H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 04H or 09H
<br>
&nbsp; &nbsp;PS/2 Model 80 &nbsp; &nbsp; &nbsp; &nbsp;F8H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 00H or 01H
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C1H (193)
<br>
Get address of extended BIOS data area
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the segment address of the base of the extended BIOS data area.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C1H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;ES &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment of extended BIOS data area
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The extended BIOS data area is allocated at the high end of conventional
<br>
&nbsp; &nbsp;memory during the POST (Power-On-Self-Test) sequence. The word at
<br>
&nbsp; &nbsp;0040:0013H (memory size) is updated to reflect the reduced amount of
<br>
&nbsp; &nbsp;memory available for MS-DOS and application programs. The first byte in
<br>
&nbsp; &nbsp;the extended BIOS data area is initialized to its length in KB.
<br>
<br>
&nbsp;■ A program can determine whether the extended BIOS data area exists with
<br>
&nbsp; &nbsp;Int 15H Function C0H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C2H (194) Subfunction 00H
<br>
Enable/disable pointing device
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Enables or disables the system's mouse or other pointing device.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C2H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= enable/disable flag
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = &nbsp; &nbsp; disable
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = &nbsp; &nbsp; enable
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if invalid function call
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if invalid input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if interface error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; if resend
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; if no far call installed
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C2H (194) Subfunction 01H
<br>
Reset pointing device
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Resets the system's mouse or other pointing device, setting the sample
<br>
&nbsp;rate, resolution, and other characteristics to their default values.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C2H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device ID
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 15H Function C2H Subfunction 00H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ After a reset operation, the state of the pointing device is as follows:
<br>
<br>
&nbsp; &nbsp;∙ disabled;
<br>
<br>
&nbsp; &nbsp;∙ sample rate at 100 reports per second;
<br>
<br>
&nbsp; &nbsp;∙ resolution at 4 counts per millimeter;
<br>
<br>
&nbsp; &nbsp;∙ and scaling at 1 to 1.
<br>
<br>
&nbsp;The data package size is unchanged by this function.
<br>
<br>
&nbsp;■ The application can use the other Int 15H Function C2H subfunctions to
<br>
&nbsp; &nbsp;initialize the pointing device to other sample rates, resolution, and
<br>
&nbsp; &nbsp;scaling, and then enable the device with Int 15H Function C2H
<br>
&nbsp; &nbsp;Subfunction 00H.
<br>
<br>
&nbsp;■ See also Int 15H Function C2H Subfunction 05H, which incidentally
<br>
&nbsp; &nbsp;resets the pointing device in a similar manner.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C2H (194) Subfunction 02H
<br>
Set sample rate
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the sampling rate of the system's mouse or other pointing device.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C2H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sample rate value
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = &nbsp; &nbsp; 10 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = &nbsp; &nbsp; 20 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = &nbsp; &nbsp; 40 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H = &nbsp; &nbsp; 60 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H = &nbsp; &nbsp; 80 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;05H = &nbsp; &nbsp; 100 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;06H = &nbsp; &nbsp; 200 reports per second
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 15H Function C2H Subfunction 00H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The default sample rate is 100 reports per second after a reset
<br>
&nbsp; &nbsp;operation (Int 15H Function C2H Subfunction 01H).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C2H (194) Subfunction 03H
<br>
Set resolution
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the resolution of the system's mouse or other pointing device.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C2H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= resolution value
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = &nbsp; &nbsp; 1 count per millimeter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = &nbsp; &nbsp; 2 counts per millimeter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = &nbsp; &nbsp; 4 counts per millimeter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H = &nbsp; &nbsp; 8 counts per millimeter
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 15H Function C2H Subfunction 00H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The default resolution is 4 counts per millimeter after a reset
<br>
&nbsp; &nbsp;operation (Int 15H Function C2H Subfunction 01H).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C2H (194) Subfunction 04H
<br>
Get pointing device type
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the identification code for the system's mouse or other pointing
<br>
&nbsp;device.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C2H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= device ID
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 15H Function C2H Subfunction 00H)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C2H (194) Subfunction 05H
<br>
Initialize pointing device interface
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the data package size for the system's mouse or other pointing
<br>
&nbsp;device, and initializes the resolution, sampling rate, and scaling to
<br>
&nbsp;their default values.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C2H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= data package size in bytes (1─8)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 15H Function C2H Subfunction 00H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ After this operation, the state of the pointing device is as follows:
<br>
<br>
&nbsp; &nbsp;∙ disabled;
<br>
<br>
&nbsp; &nbsp;∙ sample rate at 100 reports per second;
<br>
<br>
&nbsp; &nbsp;∙ resolution at 4 counts per millimeter;
<br>
<br>
&nbsp; &nbsp;∙ and scaling at 1 to 1.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C2H (194) Subfunction 06H
<br>
Set scaling or get status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the current status of the system's mouse or other pointing device
<br>
&nbsp;or sets the device's scaling factor.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C2H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 06H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= extended command
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = &nbsp; &nbsp; return device status
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = &nbsp; &nbsp; set scaling at 1:1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = &nbsp; &nbsp; set scaling at 2:1
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and, if called with BH = 00H
<br>
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status byte
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = &nbsp; &nbsp; &nbsp; 1 if right button pressed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 = &nbsp; &nbsp; &nbsp; 1 if left button pressed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 = &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 = &nbsp; &nbsp; &nbsp; 0 if 1:1 scaling
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if 2:1 scaling
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 = &nbsp; &nbsp; &nbsp; 0 if device disabled
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if device enabled
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 = &nbsp; &nbsp; &nbsp; 0 if stream mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 if remote mode
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 = &nbsp; &nbsp; &nbsp; reserved
<br>
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= resolution
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H = &nbsp; &nbsp; 1 count per millimeter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H = &nbsp; &nbsp; 2 counts per millimeter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H = &nbsp; &nbsp; 4 counts per millimeter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H = &nbsp; &nbsp; 8 counts per millimeter
<br>
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sample rate
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0AH = &nbsp; &nbsp; 10 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14H = &nbsp; &nbsp; 20 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;28H = &nbsp; &nbsp; 40 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3CH = &nbsp; &nbsp; 60 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;50H = &nbsp; &nbsp; 80 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;64H = &nbsp; &nbsp; 100 reports per second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C8H = &nbsp; &nbsp; 200 reports per second
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 15H Function C2H Subfunction 00H)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C2H (194) Subfunction 07H
<br>
Set pointing device handler address
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Notifies the ROM BIOS pointing device driver of the address for a routine
<br>
&nbsp;to be called each time pointing device data is available.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C2H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 07H
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of user routine
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 15H Function C2H Subfunction 00H)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The user's handler for pointing device data is entered via a far call
<br>
&nbsp; &nbsp;with four parameters on the stack:
<br>
<br>
&nbsp; &nbsp;SS:SP+0AH &nbsp; status
<br>
&nbsp; &nbsp;SS:SP+08H &nbsp; x coordinate
<br>
&nbsp; &nbsp;SS:SP+06H &nbsp; y coordinate
<br>
&nbsp; &nbsp;SS:SP+04H &nbsp; z coordinate (always 0)
<br>
<br>
&nbsp; &nbsp;The handler must exit via a far return without removing the parameters
<br>
&nbsp; &nbsp;from the stack.
<br>
<br>
&nbsp;■ The status parameter passed to the user's handler is interpreted as
<br>
&nbsp; &nbsp;follows:
<br>
<br>
&nbsp; &nbsp;Bit(s) &nbsp; &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left button pressed
<br>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right button pressed
<br>
&nbsp; &nbsp;2─3 &nbsp; &nbsp; &nbsp; &nbsp; reserved
<br>
&nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign of x data is negative
<br>
&nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sign of y data is negative
<br>
&nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x data has overflowed
<br>
&nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y data has overflowed
<br>
&nbsp; &nbsp;8─15 &nbsp; &nbsp; &nbsp; &nbsp;reserved
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C3H (195)
<br>
Set watchdog time-out
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Enables or disables a watchdog timer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C3H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; to disable watchdog time-out
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; to enable watchdog time-out
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= watchdog timer counter (if AL = 01H)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The watchdog timer generates an NMI interrupt.
<br>
<br>
&nbsp;■ This function is not available on the PS/2 Models 25 and 30.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function C4H (196)
<br>
Programmable option select
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the base Programmable Option Select register address, enables a
<br>
&nbsp;slot for setup, or enables an adapter.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= C4H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; to return base POS adapter register address
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; to enable slot
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; to enable adapter
<br>
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= slot number (if AL = 01H)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;and, if called with AL = 00H
<br>
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= base POS adapter register address
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is available only on machines using the Micro Channel
<br>
&nbsp; &nbsp;Architecture (MCA) bus.
<br>
<br>
&nbsp;■ After a slot is enabled with Subfunction 01H, specific information can
<br>
&nbsp; &nbsp;be obtained for the adapter in that slot by performing port input
<br>
&nbsp; &nbsp;operations:
<br>
<br>
&nbsp; &nbsp;Port &nbsp; &nbsp; &nbsp; &nbsp;Function
<br>
&nbsp; &nbsp;100H &nbsp; &nbsp; &nbsp; &nbsp;MCA ID (low byte)
<br>
&nbsp; &nbsp;101H &nbsp; &nbsp; &nbsp; &nbsp;MCA ID (high byte)
<br>
&nbsp; &nbsp;102H &nbsp; &nbsp; &nbsp; &nbsp;Option Select Byte 1
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bit 0 = 1 if enabled, = 0 if disabled
<br>
&nbsp; &nbsp;103H &nbsp; &nbsp; &nbsp; &nbsp;Option Select Byte 2
<br>
&nbsp; &nbsp;104H &nbsp; &nbsp; &nbsp; &nbsp;Option Select Byte 3
<br>
&nbsp; &nbsp;105H &nbsp; &nbsp; &nbsp; &nbsp;Option Select Byte 4
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bits 6─7 = channel check indicators
<br>
&nbsp; &nbsp;106H &nbsp; &nbsp; &nbsp; &nbsp;Subaddress Extension (low byte)
<br>
&nbsp; &nbsp;107H &nbsp; &nbsp; &nbsp; &nbsp;Subaddress Extension (high byte)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 00H
<br>
Read character from keyboard
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads a character from the keyboard, also returning the keyboard scan
<br>
&nbsp;code.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= keyboard scan code
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= ASCII character
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 01H
<br>
Get keyboard status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Determines whether a character is ready for input, returning a flag and
<br>
&nbsp;also the character itself, if one is waiting.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If key waiting to be input
<br>
<br>
&nbsp;Zero flag &nbsp; &nbsp; = clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= keyboard scan code
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character
<br>
<br>
&nbsp;If no key waiting
<br>
<br>
&nbsp;Zero flag &nbsp; &nbsp; = set
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The character returned by this function when the zero flag is clear is
<br>
&nbsp; &nbsp;not removed from the type-ahead buffer. The same character and scan code
<br>
&nbsp; &nbsp;will be returned by the next call to Int 16H Function 00H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 02H
<br>
Get keyboard flags
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the ROM BIOS flags byte that describes the state of the various
<br>
&nbsp;keyboard toggles and shift keys.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= flags
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; right Shift key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; left Shift key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; Ctrl key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; Alt key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; Scroll Lock on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; Num Lock on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; Caps Lock on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; Insert on
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The keyboard flags byte is stored in the ROM BIOS data area at
<br>
&nbsp; &nbsp;0000:0417H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 03H
<br>
Set repeat rate
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the ROM BIOS key repeat (&quot;typematic&quot;) rate and delay.
<br>
<br>
Call with:
<br>
<br>
&nbsp;On the PC/AT and PS/2
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= repeat delay (see Notes)
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= repeat rate (see Notes)
<br>
<br>
&nbsp;On the PCjr
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; to restore default rate and delay
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; to increase initial delay
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; to decrease repeat rate by one-half
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; to increase delay and decrease repeat rate by
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;one-half
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; to turn off keyboard repeat
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Subfunctions 00H─04H are available on the PCjr but are not supported by
<br>
&nbsp; &nbsp;the PC or PC/XT ROM BIOS. Subfunction 05H is available on PC/ATs with
<br>
&nbsp; &nbsp;ROM BIOS's dated 11/15/85 and later, and on the PS/2.
<br>
<br>
&nbsp;■ On the PC/AT and PS/2, the value in BH controls the amount of delay
<br>
&nbsp; &nbsp;before the first repeat key is generated. The delay is always a multiple
<br>
&nbsp; &nbsp;of 250 milliseconds:
<br>
<br>
&nbsp; &nbsp;Value &nbsp; &nbsp; &nbsp; Delay (msec.)
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; 250
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; 500
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; 750
<br>
&nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; 1000
<br>
<br>
&nbsp;■ On the PC/AT and PS/2, the value for the repeat rate in characters per
<br>
&nbsp; &nbsp;second can be chosen from the following table:
<br>
<br>
&nbsp; &nbsp;Value &nbsp; &nbsp; &nbsp; Repeat rate (characters per second)
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; 30.0
<br>
&nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; &nbsp; 26.7
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; 24.0
<br>
&nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; &nbsp; 21.8
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; 20.0
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; 18.5
<br>
&nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; 17.1
<br>
&nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; 16.0
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; 15.0
<br>
&nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; 13.3
<br>
&nbsp; &nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; 12.0
<br>
&nbsp; &nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; 10.9
<br>
&nbsp; &nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp; 10.0
<br>
&nbsp; &nbsp;0DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;9.2
<br>
&nbsp; &nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8.6
<br>
&nbsp; &nbsp;0FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8.0
<br>
&nbsp; &nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7.5
<br>
&nbsp; &nbsp;11H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6.7
<br>
&nbsp; &nbsp;12H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6.0
<br>
&nbsp; &nbsp;13H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5.5
<br>
&nbsp; &nbsp;14H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5.0
<br>
&nbsp; &nbsp;15H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.6
<br>
&nbsp; &nbsp;16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.3
<br>
&nbsp; &nbsp;17H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.0
<br>
&nbsp; &nbsp;18H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.7
<br>
&nbsp; &nbsp;19H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.3
<br>
&nbsp; &nbsp;1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.0
<br>
&nbsp; &nbsp;1BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.7
<br>
&nbsp; &nbsp;1CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.5
<br>
&nbsp; &nbsp;1DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.3
<br>
&nbsp; &nbsp;1EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.1
<br>
&nbsp; &nbsp;1FH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.0
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 04H
<br>
Set keyclick
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Turns the keyboard click on or off.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; to turn off keyboard click
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; to turn on keyboard click
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is supported by the PCjr BIOS only.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 05H
<br>
Push character and scan code
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Places a character and scan code in the keyboard type-ahead buffer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= scan code
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful (type-ahead buffer is full)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function can be used by keyboard enhancers and other utilities to
<br>
&nbsp; &nbsp;interpolate keys into the data stream seen by application programs.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 10H (16)
<br>
Read character from enhanced keyboard
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads a character and scan code from the keyboard type-ahead buffer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 10H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= keyboard scan code
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= ASCII character
<br>
<br>
Note:
<br>
<br>
&nbsp;■ Use this function for the enhanced keyboard instead of Int 16H Function
<br>
&nbsp; &nbsp;00H. It allows applications to obtain the scan codes for the additional
<br>
&nbsp; &nbsp;F11, F12, and cursor control keys.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 11H (17)
<br>
Get enhanced keyboard status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Determines whether a character is ready for input, returning a flag and
<br>
&nbsp;also the character itself, if one is waiting.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 11H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If key waiting to be input
<br>
<br>
&nbsp;Zero flag &nbsp; &nbsp; = clear
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= keyboard scan code
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character
<br>
<br>
&nbsp;If no key waiting
<br>
<br>
&nbsp;Zero flag &nbsp; &nbsp; = set
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Use this function for the enhanced keyboard instead of Int 16H Function
<br>
&nbsp; &nbsp;00H. It allows applications to test for the additional F11, F12, and
<br>
&nbsp; &nbsp;cursor control keys.
<br>
<br>
&nbsp;■ The character returned by this function when the zero flag is clear is
<br>
&nbsp; &nbsp;not removed from the type-ahead buffer. The same character and scan code
<br>
&nbsp; &nbsp;will be returned by the next call to Int 16H Function 10H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 16H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 12H (18)
<br>
Get enhanced keyboard flags
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the status of various enhanced keyboard special keys and keyboard
<br>
&nbsp;driver states.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 12H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= flags
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; right Shift key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; left Shift key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; either Ctrl key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; either Alt key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; Scroll Lock toggle is on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; Num Lock toggle is on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; Caps Lock toggle is on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; Insert toggle is on
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; left Ctrl key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;9 &nbsp; &nbsp; &nbsp; &nbsp; left Alt key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp;right Ctrl key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp;right Alt key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 &nbsp; &nbsp; &nbsp; &nbsp;Scroll key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp;Num Lock key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 &nbsp; &nbsp; &nbsp; &nbsp;Caps Lock key is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;15 &nbsp; &nbsp; &nbsp; &nbsp;SysReq key is down
<br>
<br>
Note:
<br>
<br>
&nbsp;■ Use this function for the enhanced keyboard instead of Int 16H Function
<br>
&nbsp; &nbsp;02H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 17H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 00H
<br>
Write character to printer
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sends a character to the specified parallel printer interface port and
<br>
&nbsp;returns the current status of the port.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= character
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= printer number (0 = LPT1, 1 = LPT2, 2 = LPT3)
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit &nbsp; &nbsp; &nbsp; Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; printer timed-out
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; unused
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; unused
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; I/O error
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; printer selected
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; out of paper
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; printer acknowledge
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; printer not busy
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 17H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 01H
<br>
Initialize printer port
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes the specified parallel printer interface port and returns its
<br>
&nbsp;status.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= printer number (0 = LPT1, 1 = LPT2, 2 = LPT3)
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 17H Function 00H)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 17H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Function 02H
<br>
Get printer status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the current status of the specified parallel printer interface
<br>
&nbsp;port.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= printer number (0 = LPT1, 1 = LPT2, 2 = LPT3)
<br>
<br>
Returns:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= status (see Int 17H Function 00H)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 18H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
ROM BASIC
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Transfers control to ROM BASIC.
<br>
<br>
Call with:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is invoked when the system is turned on or restarted if
<br>
&nbsp; &nbsp;attempts to read a boot sector from the fixed disk or floppy disk drives
<br>
&nbsp; &nbsp;are unsuccessful.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 19H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC] [AT] [PS/2]
<br>
Reboot system
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reboots the operating system from the floppy disk or fixed disk drive.
<br>
<br>
Call with:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The bootstrap routine reads Sector 1, Track 0 into memory at location
<br>
&nbsp; &nbsp;0000:7C00H and transfers control to the same address. If attempts to
<br>
&nbsp; &nbsp;read a boot sector from the floppy disk or fixed disk are unsuccessful,
<br>
&nbsp; &nbsp;control is transferred to ROM BASIC by execution of an Int 18H.
<br>
<br>
&nbsp;■ If location 0000:0472H does not contain the value 1234H, a memory test
<br>
&nbsp; &nbsp;will be performed before reading the boot sector.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 00H
<br>
Get tick count
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the contents of the clock tick counter.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
Returns:
<br>
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= rolled-over flag
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if midnight not passed since last read
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&gt;00H &nbsp; &nbsp; if midnight was passed since last read
<br>
<br>
&nbsp;CX:DX &nbsp; &nbsp; &nbsp; &nbsp; = tick count (high 16 bits in CX)
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is supported by the PC/XT and PCjr ROM BIOS, but is not
<br>
&nbsp; &nbsp;present in the ROM BIOS for the original PC.
<br>
<br>
&nbsp;■ The returned value is the cumulative number of clock ticks since
<br>
&nbsp; &nbsp;midnight. There are 18.2 clock ticks per second. When the counter
<br>
&nbsp; &nbsp;reaches 1,573,040, it is cleared to zero, and the rolled-over flag is
<br>
&nbsp; &nbsp;set.
<br>
<br>
&nbsp;■ The rolled-over flag is cleared by this function call, so the flag will
<br>
&nbsp; &nbsp;only be returned nonzero once per day.
<br>
<br>
&nbsp;■ Int 1AH Function 01H can be used to set the clock tick counter to an
<br>
&nbsp; &nbsp;arbitrary 32-bit value.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 01H
<br>
Set tick count
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Stores a 32-bit value in the clock tick counter.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;CX:DX &nbsp; &nbsp; &nbsp; &nbsp; = tick count (high 16 bits in CX)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is supported by the PC/XT and PCjr ROM BIOS, but is not
<br>
&nbsp; &nbsp;present in the ROM BIOS for the original PC.
<br>
<br>
&nbsp;■ Int 1AH Function 00H is used to read the value of the clock tick
<br>
&nbsp; &nbsp;counter.
<br>
<br>
&nbsp;■ The rolled-over flag is cleared by this function call.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 02H
<br>
Get time
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads the current time from the CMOS time/date chip.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
<br>
Returns:
<br>
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hours in binary coded decimal (BCD)
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= minutes in BCD
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= seconds in BCD
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= daylight-saving-time code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if standard time
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if daylight saving time
<br>
<br>
&nbsp;and, if clock running
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;or, if clock stopped
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 03H
<br>
Set time
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the time in the CMOS time/date chip.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hours in binary coded decimal (BCD)
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= minutes in BCD
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= seconds in BCD
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= daylight-saving-time code
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if standard time
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if daylight saving time
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 04H
<br>
Get date
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Reads the current date from the CMOS time/date chip.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H
<br>
<br>
Returns:
<br>
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= century (19 or 20) in binary coded decimal (BCD)
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= year in BCD
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= month in BCD
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= day in BCD
<br>
<br>
&nbsp;and, if clock running
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;or, if clock stopped
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 05H
<br>
Set date
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the date in the CMOS time/date chip.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= century (19 or 20) in binary coded decimal (BCD)
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= year in BCD
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= month in BCD
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= day in BCD
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 06H
<br>
Set alarm
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets an alarm in the CMOS date/time chip.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 06H
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hours in binary coded decimal (BCD)
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= minutes in BCD
<br>
&nbsp;DH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= seconds in BCD
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful (alarm already set, or clock stopped)
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ A side effect of this function is that the clock chip's interrupt level
<br>
&nbsp; &nbsp;(IRQ8) is enabled.
<br>
<br>
&nbsp;■ Only one alarm may be active at any given time. The alarm occurs every
<br>
&nbsp; &nbsp;24 hours at the specified time until it is reset with Int 1AH Function
<br>
&nbsp; &nbsp;07H.
<br>
<br>
&nbsp;■ The program using this function must place the address of its interrupt
<br>
&nbsp; &nbsp;handler for the alarm in the vector for Int 4AH.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[AT] [PS/2]
<br>
Function 07H
<br>
Reset alarm
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Cancels any pending alarm request on the CMOS date/time chip.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 07H
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function does not disable the clock chip's interrupt level (IRQ8).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 0AH (10)
<br>
Get day count
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the contents of the system's day counter.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0AH
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= count of days since January 1, 1980
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PS/2]
<br>
Function 0BH (11)
<br>
Set day count
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Stores an arbitrary value in the system's day counter.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0BH
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= count of days since January 1, 1980
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= clear
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;Carry flag &nbsp; &nbsp;= set
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 1AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [PC]
<br>
Function 80H (128)
<br>
Set sound source
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets up the source for tones that will appear on the PCjr's &quot;Audio Out&quot; or
<br>
&nbsp;RF modulator.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 80H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sound source
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; if 8253 programmable timer, channel 2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01H &nbsp; &nbsp; &nbsp; if cassette input
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; if &quot;Audio In&quot; line on I/O channel
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;03H &nbsp; &nbsp; &nbsp; if sound generator chip
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is supported on the PCjr only.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Microsoft Mouse driver
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;The Microsoft Mouse driver makes its functions available to application
<br>
&nbsp;programs via Int 33H. These functions have become a de facto standard for
<br>
&nbsp;pointer device drivers of all varieties. Unlike the other function calls
<br>
&nbsp;described in this section, the Microsoft Mouse driver is not part of the
<br>
&nbsp;ROM BIOS but is loaded by a DEVICE= directive in the CONFIG.SYS file. All
<br>
&nbsp;mouse-function information applies to the Microsoft Mouse driver version
<br>
&nbsp;6. Earlier versions of the driver may not support all of these functions.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 00H
<br>
Reset mouse and get status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Initializes the mouse driver and returns the driver status. If the mouse
<br>
&nbsp;pointer was previously visible, it is removed from the screen, and any
<br>
&nbsp;previously installed user handlers for mouse events are disabled.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0000H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If mouse support is available
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFFFH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of mouse buttons
<br>
<br>
&nbsp;If mouse support is not available
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0000H
<br>
<br>
Note:
<br>
<br>
&nbsp;■ After a call to this function, the mouse driver is initialized to the
<br>
&nbsp; &nbsp;following state:
<br>
<br>
&nbsp; &nbsp;∙ Mouse pointer at screen center (see Int 33H Functions 03H and 04H)
<br>
<br>
&nbsp; &nbsp;∙ Display page for mouse pointer set to zero (see Int 33H Functions
<br>
&nbsp; &nbsp; &nbsp;1DH and 1EH)
<br>
<br>
&nbsp; &nbsp;∙ Mouse pointer hidden (see Int 33H Functions 01H, 02H, and 10H)
<br>
<br>
&nbsp; &nbsp;∙ Mouse pointer set to default arrow shape in graphics modes, or reverse
<br>
&nbsp; &nbsp; &nbsp;block in text modes (see Int 33H Functions 09H and 0AH)
<br>
<br>
&nbsp; &nbsp;∙ User mouse event handler disabled (see Int 33H Functions 0CH and
<br>
&nbsp; &nbsp; &nbsp;14H)
<br>
<br>
&nbsp; &nbsp;∙ Light pen emulation enabled (see Int 33H Functions 0DH and 0EH)
<br>
<br>
&nbsp; &nbsp;∙ Horizontal mickeys to pixels ratio at 8 to 8, vertical ratio at 16 to
<br>
&nbsp; &nbsp; &nbsp;8 (see Int 33H Function 0FH)
<br>
<br>
&nbsp; &nbsp;∙ Double speed threshold set to 64 mickeys/second (see Int 33H Function
<br>
&nbsp; &nbsp; &nbsp;19H)
<br>
<br>
&nbsp; &nbsp;∙ Minimum and maximum horizontal and vertical pointer position limits
<br>
&nbsp; &nbsp; &nbsp;set to include the entire screen in the current display mode (see Int
<br>
&nbsp; &nbsp; &nbsp;33H Functions 07H and 08H)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 01H
<br>
Show mouse pointer
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Displays the mouse pointer, and cancels any mouse pointer exclusion area
<br>
&nbsp;previously defined with Int 33H Function 10H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0001H
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ A counter is maintained which is decremented by calls to Int 33H
<br>
&nbsp; &nbsp;Function 02H (Hide Mouse Pointer) and incremented (if nonzero) by this
<br>
&nbsp; &nbsp;function. When the counter is zero or becomes zero, the mouse pointer is
<br>
&nbsp; &nbsp;displayed. When the mouse driver is reset with Int 33H Function 00H,
<br>
&nbsp; &nbsp;the counter is forced to -1.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 02H
<br>
Hide mouse pointer
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Removes the mouse pointer from the display. The driver continues to track
<br>
&nbsp;the mouse position.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0002H
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ A counter is maintained which is decremented by calls to this function
<br>
&nbsp; &nbsp;and incremented (if nonzero) by Int 33H Function 01H (Show Mouse
<br>
&nbsp; &nbsp;Pointer). When the counter is zero, the mouse pointer is displayed. When
<br>
&nbsp; &nbsp;the mouse driver is reset with Int 33H Function 00H, the counter is
<br>
&nbsp; &nbsp;forced to -1.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 03H
<br>
Get mouse position and button status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the current mouse button status and pointer position.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0003H
<br>
<br>
Returns:
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= mouse button status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; left button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; right button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; center button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= horizontal (X) coordinate
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= vertical (Y) coordinate
<br>
<br>
Note:
<br>
<br>
&nbsp;■ Coordinates are returned in pixels regardless of the current display
<br>
&nbsp; &nbsp;mode. Position (x,y) = (0,0) is the upper left corner of the screen.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 04H
<br>
Set mouse pointer position
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the position of the mouse pointer. The pointer is displayed at the
<br>
&nbsp;new position unless it has been hidden with Int 33H Function 02H, or the
<br>
&nbsp;new position lies within an exclusion area defined with Int 33H Function
<br>
&nbsp;10H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0004H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= horizontal (X) coordinate
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= vertical (Y) coordinate
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Coordinates are specified in pixels regardless of the current display
<br>
&nbsp; &nbsp;mode. Position (x,y) = (0,0) is the upper left corner of the screen.
<br>
<br>
&nbsp;■ The position is adjusted if necessary to lie within the horizontal and
<br>
&nbsp; &nbsp;vertical limits specified with a previous call to Int 33H Functions
<br>
&nbsp; &nbsp;07H and 08H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 05H
<br>
Get button press information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the current status of all mouse buttons, and the number of presses
<br>
&nbsp;and position of the last press for a specified mouse button since the last
<br>
&nbsp;call to this function for that button. The press counter for the button is
<br>
&nbsp;reset to zero.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0005H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= button identifier
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = &nbsp; &nbsp; &nbsp; left button
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = &nbsp; &nbsp; &nbsp; right button
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 = &nbsp; &nbsp; &nbsp; center button
<br>
<br>
Returns:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= button status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; left button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; right button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; center button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= button press counter
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= horizontal (X) coordinate of last button press
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= vertical (Y) coordinate of last button press
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 06H
<br>
Get button release information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the current status of all mouse buttons, and the number of
<br>
&nbsp;releases and position of the last release for a specified mouse button
<br>
&nbsp;since the last call to this function for that button. The release counter
<br>
&nbsp;for the button is reset to zero.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0006H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= button identifier
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = &nbsp; &nbsp; &nbsp; left button
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = &nbsp; &nbsp; &nbsp; right button
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 = &nbsp; &nbsp; &nbsp; center button
<br>
<br>
Returns:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= button status
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; left button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; right button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; center button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= button release counter
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= horizontal (X) coordinate of last button release
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= vertical (Y) coordinate of last button release
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 07H
<br>
Set horizontal limits for pointer
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Limits the mouse pointer display area by assigning minimum and maximum
<br>
&nbsp;horizontal (X) coordinates for the mouse pointer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0007H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= minimum horizontal (X) coordinate
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= maximum horizontal (X) coordinate
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the minimum value is greater than the maximum value, the two values
<br>
&nbsp; &nbsp;are swapped.
<br>
<br>
&nbsp;■ The mouse pointer will be moved if necessary so that it lies within the
<br>
&nbsp; &nbsp;specified horizontal coordinates.
<br>
<br>
&nbsp;■ See also Int 33H Function 10H, which defines an exclusion area for the
<br>
&nbsp; &nbsp;mouse pointer.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 08H
<br>
Set vertical limits for pointer
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Limits the mouse pointer display area by assigning minimum and maximum
<br>
&nbsp;vertical (Y) coordinates for the mouse pointer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0008H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= minimum vertical (Y) coordinate
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= maximum vertical (Y) coordinate
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the minimum value is greater than the maximum value, the two values
<br>
&nbsp; &nbsp;are swapped.
<br>
<br>
&nbsp;■ The mouse pointer will be moved if necessary so that it lies within the
<br>
&nbsp; &nbsp;specified vertical coordinates.
<br>
<br>
&nbsp;■ See also Int 33H Function 10H, which defines an exclusion area for the
<br>
&nbsp; &nbsp;mouse pointer.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 09H
<br>
Set graphics pointer shape
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Defines the shape, color, and hot spot of the mouse pointer in graphics
<br>
&nbsp;modes.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0009H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hot spot offset from left
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= hot spot offset from top
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of pointer image buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The pointer image buffer is 64 bytes long. The first 32 bytes contain a
<br>
&nbsp; &nbsp;bit mask which is ANDed with the screen image, and the second 32 bytes
<br>
&nbsp; &nbsp;contain a bit mask which is XORed with the screen image.
<br>
<br>
&nbsp;■ The hot spot is relative to the upper left corner of the pointer image,
<br>
&nbsp; &nbsp;and each pixel offset must be in the range -16 through 16. In display
<br>
&nbsp; &nbsp;modes 4 and 5, the horizontal offset must be an even number.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 0AH (10)
<br>
Set text pointer type
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Defines the shape and attributes of the mouse pointer in text modes.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 000AH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= pointer type
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = &nbsp; &nbsp; &nbsp; software cursor
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = &nbsp; &nbsp; &nbsp; hardware cursor
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= AND mask value (if BX = 0) or
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;starting line for cursor (if BX = 1)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= XOR mask value (if BX = 0) or
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ending line for cursor (if BX = 1)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the software text cursor is selected (BX = 0), the masks in CX and DX
<br>
&nbsp; &nbsp;are mapped as follows:
<br>
<br>
&nbsp; &nbsp;Bit(s) &nbsp; &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;0─7 &nbsp; &nbsp; &nbsp; &nbsp; character code
<br>
&nbsp; &nbsp;8─10 &nbsp; &nbsp; &nbsp; &nbsp;foreground color
<br>
&nbsp; &nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;intensity
<br>
&nbsp; &nbsp;12─14 &nbsp; &nbsp; &nbsp; background color
<br>
&nbsp; &nbsp;15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;blink
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;For example, the following values would yield a software mouse cursor
<br>
&nbsp; &nbsp;that inverts the foreground and background colors:
<br>
<br>
&nbsp; &nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 000AH
<br>
&nbsp; &nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0000H
<br>
&nbsp; &nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 77FFH
<br>
&nbsp; &nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 7700H
<br>
<br>
&nbsp;■ When the hardware text cursor is selected (BX = 1), the values in CX and
<br>
&nbsp; &nbsp;DX are the starting and ending scan lines for the blinking cursor
<br>
&nbsp; &nbsp;generated by the video adapter. The maximum scan line which may be used
<br>
&nbsp; &nbsp;depends on the type of adapter and the current display mode.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 0BH (11)
<br>
Read mouse motion counters
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the net mouse displacement since the last call to this function.
<br>
&nbsp;The returned value is in mickeys; a positive number indicates travel to
<br>
&nbsp;the right or downwards, a negative number indicates travel to the left or
<br>
&nbsp;upwards. One mickey represents approximately 1/200 of an inch of mouse
<br>
&nbsp;movement.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 000BH
<br>
<br>
Returns:
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= horizontal (X) mickey count
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= vertical (Y) mickey count
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 0CH (12)
<br>
Set user-defined mouse event handler
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the address and event mask for an application program's mouse event
<br>
&nbsp;handler. The handler is called by the mouse driver whenever the specified
<br>
&nbsp;mouse events occur.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 000CH
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= event mask
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; mouse movement
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; left button pressed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; left button released
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; right button pressed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; right button released
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; center button pressed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; center button released
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of handler
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The user-defined event handler is entered from the mouse driver by a far
<br>
&nbsp; &nbsp;call with registers set up as follows:
<br>
<br>
&nbsp; &nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mouse event flags (see event mask)
<br>
&nbsp; &nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; button state
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bit(s) &nbsp; &nbsp; Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;left button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;right button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;center button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3─15 &nbsp; &nbsp; &nbsp; reserved (0)
<br>
<br>
&nbsp; &nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; horizontal (X) pointer coordinate
<br>
&nbsp; &nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vertical (Y) pointer coordinate
<br>
&nbsp; &nbsp;SI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last raw vertical mickey count
<br>
&nbsp; &nbsp;DI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last raw horizontal mickey count
<br>
&nbsp; &nbsp;DS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mouse driver data segment
<br>
<br>
&nbsp;■ If an event does not generate a call to the user-defined handler because
<br>
&nbsp; &nbsp;its bit is not set in the event mask, it is still reported in the event
<br>
&nbsp; &nbsp;flags during calls to the handler for events which are enabled.
<br>
<br>
&nbsp;■ Calls to the handler are disabled with Int 33H Function 00H or by
<br>
&nbsp; &nbsp;calling this function with an event mask of zero.
<br>
<br>
&nbsp;■ See also Int 33H Functions 14H and 18H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 0DH (13)
<br>
Turn on light pen emulation
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Enables light pen emulation by the mouse driver for IBM BASIC. A &quot;pen
<br>
&nbsp;down&quot; condition is created by pressing the left and right mouse buttons
<br>
&nbsp;simultaneously.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 000DH
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 0EH (14)
<br>
Turn off light pen emulation
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Disables light pen emulation by the mouse driver for IBM BASIC.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 000EH
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 0FH (15)
<br>
Set mickeys to pixels ratio
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the number of mickeys per 8 pixels for horizontal and vertical mouse
<br>
&nbsp;motion. One mickey represents approximately 1/200 of an inch of mouse
<br>
&nbsp;travel.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 000FH
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= horizontal mickeys (1─32,767, default = 8)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= vertical mickeys (1─32,767, default = 16)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 10H (16)
<br>
Set mouse pointer exclusion area
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Defines an exclusion area for the mouse pointer. When the mouse pointer
<br>
&nbsp;lies within the specified area, it is not displayed.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0010H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= upper left X coordinate
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= upper left Y coordinate
<br>
&nbsp;SI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= lower right X coordinate
<br>
&nbsp;DI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= lower right Y coordinate
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The exclusion area is replaced by another call to this function or
<br>
&nbsp; &nbsp;cancelled by Int 33H Functions 00H or 01H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 13H (19)
<br>
Set double speed threshold
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the threshold speed for doubling pointer motion on the screen. The
<br>
&nbsp;default threshold speed is 64 mickeys/second.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0013H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= threshold speed in mickeys/second
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ Doubling of pointer motion can be effectively disabled by setting the
<br>
&nbsp; &nbsp;threshold to a very large value (such as 10,000).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 14H (20)
<br>
Swap user-defined mouse event handlers
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the address and event mask for an application program's mouse event
<br>
&nbsp;handler and returns the address and event mask for the previous handler.
<br>
&nbsp;The newly installed handler is called by the mouse driver whenever the
<br>
&nbsp;specified mouse events occur.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0014H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= event mask
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; mouse movement
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; left button pressed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; left button released
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; right button pressed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; right button released
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; center button pressed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; center button released
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of event handler
<br>
<br>
Returns:
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= previous event mask
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of previous handler
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The Notes for Int 33H Function 0CH describe the information passed to
<br>
&nbsp; &nbsp;the user-defined event handler. See also Int 33H Function 18H.
<br>
<br>
&nbsp;■ Calls to the event handler are disabled with Int 33H Function 00H or by
<br>
&nbsp; &nbsp;setting an event mask of zero.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 15H (21)
<br>
Get mouse save state buffer size
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Gets the size of the buffer required to store the current state of the
<br>
&nbsp;mouse driver.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0015H
<br>
<br>
Returns:
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= buffer size (bytes)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ See also Int 33H Functions 16H and 17H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 16H (22)
<br>
Save mouse driver state
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Saves the mouse driver state in a user buffer. The minimum size for the
<br>
&nbsp;buffer must be determined by a previous call to Int 33H Function 15H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0016H
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ Call this function before executing a child program with Int 21H
<br>
&nbsp; &nbsp;Function 4BH (EXEC), in case the child also uses the mouse. After the
<br>
&nbsp; &nbsp;EXEC call, restore the previous mouse driver state with Int 33H Function
<br>
&nbsp; &nbsp;17H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 17H (23)
<br>
Restore mouse driver state
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Restores the mouse driver state from a user buffer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0017H
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The mouse driver state must have been previously saved into the same
<br>
&nbsp; &nbsp;buffer with Int 33H Function 16H. The format of the data in the buffer
<br>
&nbsp; &nbsp;is undocumented and subject to change.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 18H (24)
<br>
Set alternate mouse event handler
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the address and event mask for a an application program mouse event
<br>
&nbsp;handler. As many as three handlers with distinct event masks can be
<br>
&nbsp;registered with this function. When an event occurs that matches one of
<br>
&nbsp;the masks, the corresponding handler is called by the mouse driver.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0018H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= event mask
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; mouse movement
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; left button pressed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; left button released
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; right button pressed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; right button released
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; Shift key pressed during button press or release
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; Ctrl key pressed during button press or release
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; Alt key pressed during button press or release
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of handler
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0018H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFFFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ When this function is called, at least one of the bits 5, 6, and 7 must
<br>
&nbsp; &nbsp;be set in register CX.
<br>
<br>
&nbsp;■ The user-defined event handler is entered from the mouse driver by a far
<br>
&nbsp; &nbsp;call with registers set up as follows:
<br>
<br>
&nbsp; &nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mouse event flags (see event mask)
<br>
&nbsp; &nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; button state
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bit(s) &nbsp; &nbsp; Significance (if set)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;left button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;right button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;center button is down
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3─15 &nbsp; &nbsp; &nbsp; reserved (0)
<br>
<br>
&nbsp; &nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; horizontal (X) pointer coordinate
<br>
&nbsp; &nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vertical (Y) pointer coordinate
<br>
&nbsp; &nbsp;SI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last raw vertical mickey count
<br>
&nbsp; &nbsp;DI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last raw horizontal mickey count
<br>
&nbsp; &nbsp;DS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mouse driver data segment
<br>
<br>
&nbsp;■ If an event does not generate a call to the user-defined handler because
<br>
&nbsp; &nbsp;its bit is not set in the event mask, it can still be reported in the
<br>
&nbsp; &nbsp;event flags during calls to the handler for events that are enabled.
<br>
<br>
&nbsp;■ Calls to the handler are disabled with Int 33H Function 00H.
<br>
<br>
&nbsp;■ See also Int 33H Functions 0CH and 14H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 19H (25)
<br>
Get address of alternate mouse event handler
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the address for the mouse event handler matching the specified
<br>
&nbsp;event mask.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0019H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= event mask (see Int 33H Function 18H)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= event mask
<br>
&nbsp;ES:DX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of alternate event handler
<br>
<br>
&nbsp;If function unsuccessful (no handler installed or event mask does not
<br>
&nbsp;match any installed handler)
<br>
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0000H
<br>
<br>
Note:
<br>
<br>
&nbsp;■ Int 33H Function 18H allows as many as three event handlers with
<br>
&nbsp; &nbsp;distinct event masks to be installed. This function can be called to
<br>
&nbsp; &nbsp;search for a handler that matches a specific event, so that it can be
<br>
&nbsp; &nbsp;replaced or disabled.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 1AH (26)
<br>
Set mouse sensitivity
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the number of mickeys per 8 pixels for horizontal and vertical mouse
<br>
&nbsp;motion and the threshold speed for doubling pointer motion on the screen.
<br>
&nbsp;One mickey represents approximately 1/200 of an inch of mouse travel.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 001AH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= horizontal mickeys (1─32,767, default = 8)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= vertical mickeys (1─32,767, default = 16)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= double speed threshold in mickeys/second (default = 64)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ See also Int 33H Functions 0FH and 13H, which allow the mickeys to
<br>
&nbsp; &nbsp;pixels ratio and threshold speed to be set separately, and Int 33H
<br>
&nbsp; &nbsp;Function 1BH, which returns the current sensitivity values.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 1BH (27)
<br>
Get mouse sensitivity
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the current mickeys to pixels ratios for vertical and horizontal
<br>
&nbsp;screen movement and the threshold speed for doubling of pointer motion.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 001BH
<br>
<br>
Returns:
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= horizontal mickeys (1─32,767, default = 8)
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= vertical mickeys (1─32,767, default = 16)
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= double speed threshold in mickeys/second (default = 64)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ See also Int 33H Functions 0FH, 13H, and 1AH.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 1CH (28)
<br>
Set mouse interrupt rate
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the rate at which the mouse driver polls the status of the mouse.
<br>
&nbsp;Faster rates provide better resolution in graphics mode but may degrade
<br>
&nbsp;the performance of application programs.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 001CH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= interrupt rate flags
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bit(s) &nbsp; &nbsp;Significance
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; no interrupts allowed
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; 30 interrupts/second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; 50 interrupts/second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; 100 interrupts/second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; 200 interrupts/second
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5─15 &nbsp; &nbsp; &nbsp;reserved (0)
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is applicable for the InPort Mouse only.
<br>
<br>
&nbsp;■ If more than one bit is set in register BX, the lowest order bit
<br>
&nbsp; &nbsp;prevails.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 1DH (29)
<br>
Select pointer page
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects the display page for the mouse pointer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 001DH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The valid page numbers depend on the current display mode. See Int 10H
<br>
&nbsp; &nbsp;Function 05H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 1EH (30)
<br>
Get pointer page
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the current display page for the mouse pointer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 001EH
<br>
<br>
Returns:
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= page
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 1FH (31)
<br>
Disable mouse driver
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Disables the mouse driver and returns the address of the previous Int 33H
<br>
&nbsp;handler.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 001FH
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 001FH
<br>
&nbsp;ES:BX &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of previous Int 33H handler
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFFFH
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ When this function is called, the mouse driver releases any interrupt
<br>
&nbsp; &nbsp;vectors it has captured other than Int 33H (which may include Int 10H,
<br>
&nbsp; &nbsp;Int 71H, and/or Int 74H). The application program can complete the
<br>
&nbsp; &nbsp;process of logically removing the mouse driver by restoring the original
<br>
&nbsp; &nbsp;contents of the Int 33H vector with Int 21H Function 25H, using the
<br>
&nbsp; &nbsp;address returned by this function in ES:BX.
<br>
<br>
&nbsp;■ See also Int 33H Function 20H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 20H (32)
<br>
Enable mouse driver
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Enables the mouse driver and the servicing of mouse interrupts.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0020H
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ See also Int 33H Function 1FH.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 21H (33)
<br>
Reset mouse driver
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Resets the mouse driver and returns driver status. If the mouse pointer
<br>
&nbsp;was previously visible, it is removed from the screen, and any previously
<br>
&nbsp;installed user handlers for mouse events are disabled.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0021H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If mouse support is available
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= FFFFH
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of mouse buttons
<br>
<br>
&nbsp;If mouse support is not available
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0021H
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function differs from Int 33H Function 00H in that there is no
<br>
&nbsp; &nbsp;initialization of the mouse hardware.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 22H (34)
<br>
Set language for mouse driver messages
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects the language that will be used by the mouse driver for prompts and
<br>
&nbsp;error messages.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0022H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= language number
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 = &nbsp; &nbsp; &nbsp; English
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = &nbsp; &nbsp; &nbsp; French
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 = &nbsp; &nbsp; &nbsp; Dutch
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 = &nbsp; &nbsp; &nbsp; German
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 = &nbsp; &nbsp; &nbsp; Swedish
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 = &nbsp; &nbsp; &nbsp; Finnish
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 = &nbsp; &nbsp; &nbsp; Spanish
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 = &nbsp; &nbsp; &nbsp; Portuguese
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 = &nbsp; &nbsp; &nbsp; Italian
<br>
<br>
Returns:
<br>
<br>
&nbsp;Nothing
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is only available in international versions of the
<br>
&nbsp; &nbsp;Microsoft Mouse driver.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 23H (35)
<br>
Get language number
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the number of the language that is used by the mouse driver for
<br>
&nbsp;prompts and error messages.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0023H
<br>
<br>
Returns:
<br>
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= language number (see Int 33H Function 22H)
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is only available in international versions of the
<br>
&nbsp; &nbsp;Microsoft Mouse driver.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 33H
<br>
Function 24H (36)
<br>
Get mouse information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the mouse driver version number, mouse type, and the IRQ number of
<br>
&nbsp;the interrupt used by the mouse adapter.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0024H
<br>
<br>
Returns:
<br>
<br>
&nbsp;BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= major version number (6 for version 6.10, etc.)
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= minor version number (0AH for version 6.10, etc.)
<br>
&nbsp;CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= mouse type
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 = &nbsp; &nbsp; &nbsp; bus mouse
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 = &nbsp; &nbsp; &nbsp; serial mouse
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 = &nbsp; &nbsp; &nbsp; InPort mouse
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 = &nbsp; &nbsp; &nbsp; PS/2 mouse
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 = &nbsp; &nbsp; &nbsp; HP mouse
<br>
<br>
&nbsp;CL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= IRQ number
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= PS/2
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2, 3, 4, 5, or 7 &nbsp; &nbsp; = IRQ number
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
SECTION 4 &nbsp;LOTUS/INTEL/MICROSOFT EMS FUNCTIONS REFERENCE
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
Notes to the Reader
<br>
<br>
&nbsp;The Lotus/Intel/Microsoft Expanded Memory Specification (EMS) defines a
<br>
&nbsp;hardware/software subsystem, compatible with 80x86-based microcomputers
<br>
&nbsp;running MS-DOS, that allows applications to access as much as 32 MB of
<br>
&nbsp;bank-switched random-access memory. The software component, called the
<br>
&nbsp;Expanded Memory Manager (EMM), is installed during system initialization
<br>
&nbsp;by a DEVICE= directive in the CONFIG.SYS file in the root directory on the
<br>
&nbsp;boot disk.
<br>
<br>
&nbsp;After ensuring that the EMM is present (see Chapter 11), an application
<br>
&nbsp;program communicates directly with the EMM using software interrupt 67H. A
<br>
&nbsp;particular EMM function is selected by the value in register AH and a
<br>
&nbsp;success or error status is returned in register AH (error codes are listed
<br>
&nbsp;on pages 207─209). Other parameters and results are passed or returned in
<br>
&nbsp;registers or buffers.
<br>
<br>
&nbsp;An icon in each function heading indicates the EMS version in which that
<br>
&nbsp;function was first supported. You can assume that the function is
<br>
&nbsp;available in all subsequent EMS versions unless explicitly noted
<br>
&nbsp;otherwise.
<br>
<br>
&nbsp;Version icons used in the synopsis, parameters, results, or Notes section
<br>
&nbsp;refer to specific minor or major EMS versions, unless they include a +
<br>
&nbsp;sign to indicate a version and all subsequent versions.
<br>
<br>
&nbsp;The material in this section has been verified against the Expanded Memory
<br>
&nbsp;Specification version 4.0, dated October 1987, Intel part number
<br>
&nbsp;300275-005. This document can be obtained from Intel Corporation, 5200
<br>
&nbsp;N.E. Elam Young Parkway, Hillsboro, OR 97124.
<br>
<br>
<br>
Summary of EMM Functions
<br>
<br>
<br>
&nbsp;Function &nbsp; &nbsp; Subfunction &nbsp; &nbsp; Description
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
&nbsp;40H (64) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Status
<br>
&nbsp;41H (65) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Page Frame Address
<br>
&nbsp;42H (66) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Number of Pages
<br>
&nbsp;43H (67) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Allocate Handle and Pages
<br>
&nbsp;44H (68) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Map Expanded Memory Page
<br>
&nbsp;45H (69) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Release Handle and Expanded Memory
<br>
&nbsp;46H (70) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Version
<br>
&nbsp;47H (71) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Save Page Map
<br>
&nbsp;48H (72) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Restore Page Map
<br>
&nbsp;49H (73) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved
<br>
&nbsp;4AH (74) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reserved
<br>
&nbsp;4BH (75) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Handle Count
<br>
&nbsp;4CH (76) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Handle Pages
<br>
&nbsp;4DH (77) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Pages for All Handles
<br>
&nbsp;4EH (78) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Save Page Map
<br>
&nbsp;4EH (78) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Restore Page Map
<br>
&nbsp;4EH (78) &nbsp; &nbsp; 02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Save and Restore Page Map
<br>
&nbsp;4EH (78) &nbsp; &nbsp; 03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Size of Page Map Information
<br>
&nbsp;4FH (79) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Save Partial Page Map
<br>
&nbsp;4FH (79) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Restore Partial Page Map
<br>
&nbsp;4FH (79) &nbsp; &nbsp; 02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Size of Partial Page Map Information
<br>
&nbsp;50H (80) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Map Multiple Pages by Number
<br>
&nbsp;50H (80) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Map Multiple Pages by Address
<br>
&nbsp;51H (81) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Reallocate Pages for Handle
<br>
&nbsp;52H (82) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Handle Attribute
<br>
&nbsp;52H (82) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Handle Attribute
<br>
&nbsp;52H (82) &nbsp; &nbsp; 02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Attribute Capability
<br>
&nbsp;53H (83) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Handle Name
<br>
&nbsp;53H (83) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Handle Name
<br>
&nbsp;54H (84) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get All Handle Names
<br>
&nbsp;54H (84) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Search for Handle Name
<br>
&nbsp;54H (84) &nbsp; &nbsp; 02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Total Handles
<br>
&nbsp;55H (85) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Map Pages by Number and Jump
<br>
&nbsp;55H (85) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Map Pages by Address and Jump
<br>
&nbsp;56H (86) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Map Pages by Number and Call
<br>
&nbsp;56H (86) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Map Pages by Address and Call
<br>
&nbsp;56H (86) &nbsp; &nbsp; 02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Space for Map Page and Call
<br>
&nbsp;57H (87) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Move Memory Region
<br>
&nbsp;57H (87) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exchange Memory Regions
<br>
&nbsp;58H (88) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Addresses of Mappable Pages
<br>
&nbsp;58H (88) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Number of Mappable Pages
<br>
&nbsp;59H (89) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Hardware Configuration
<br>
&nbsp;59H (89) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Number of Raw Pages
<br>
&nbsp;5AH (90) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Allocate Handle and Standard Pages
<br>
&nbsp;5AH (90) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Allocate Handle and Raw Pages
<br>
&nbsp;5BH (91) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Alternate Map Registers
<br>
&nbsp;5BH (91) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set Alternate Map Registers
<br>
&nbsp;5BH (91) &nbsp; &nbsp; 02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get Size of Alternate Map Register Save Area
<br>
&nbsp;5BH (91) &nbsp; &nbsp; 03H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Allocate Alternate Map Register Set
<br>
&nbsp;5BH (91) &nbsp; &nbsp; 04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Deallocate Alternate Map Register Set
<br>
&nbsp;5BH (91) &nbsp; &nbsp; 05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Allocate DMA Register Set
<br>
&nbsp;5BH (91) &nbsp; &nbsp; 06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Enable DMA on Alternate Map Register Set
<br>
&nbsp;5BH (91) &nbsp; &nbsp; 07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Disable DMA on Alternate Map Register Set
<br>
&nbsp;5BH (91) &nbsp; &nbsp; 08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Deallocate DMA Register Set
<br>
&nbsp;5CH (92) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Prepare Expanded Memory Manager for Warm Boot
<br>
&nbsp;5DH (93) &nbsp; &nbsp; 00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Enable EMM Operating-System Functions
<br>
&nbsp;5DH (93) &nbsp; &nbsp; 01H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Disable EMM Operating-System Functions
<br>
&nbsp;5DH (93) &nbsp; &nbsp; 02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Release Access Key
<br>
&nbsp;──────────────────────────────────────────────────────────────────────────
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 40H (64)
<br>
Get status
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a status code indicating whether the expanded memory software and
<br>
&nbsp;hardware are present and functional.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 40H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This call should be used only after an application has established that
<br>
&nbsp; &nbsp;the Expanded Memory Manager is in fact present, using one of the
<br>
&nbsp; &nbsp;techniques described in Chapter 11.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 41H (65)
<br>
Get page frame address
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the segment address of the page frame used by the Expanded Memory
<br>
&nbsp;Manager.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 41H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= segment base of page frame
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The page frame is divided into four 16 KB pages, which are used to map
<br>
&nbsp; &nbsp;logical expanded memory pages into the physical memory space of the CPU.
<br>
<br>
&nbsp;■ The application need not have already acquired an EMM handle to use this
<br>
&nbsp; &nbsp;function.
<br>
<br>
&nbsp;■ [EMS 4.0] Mapping of expanded memory pages is not necessarily limited to
<br>
&nbsp; &nbsp;the 64 KB page frame. See also Int 67H Function 58H Subfunction 00H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 42H (66)
<br>
Get number of pages
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the total number of logical expanded memory pages present in the
<br>
&nbsp;system and the number of pages that are not already allocated.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 42H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= unallocated pages
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= total pages
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The application need not have already acquired an EMM handle to use this
<br>
&nbsp; &nbsp;function.
<br>
<br>
&nbsp;■ [EMS 4.0] See also Int 67H Function 59H Subfunction 01H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 43H (67)
<br>
Allocate handle and pages
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains an EMM handle and allocates logical pages of expanded memory to be
<br>
&nbsp;controlled by that handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 43H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of pages to allocate (must be nonzero)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This is the equivalent of a file open function for the expanded memory
<br>
&nbsp; &nbsp;manager. The handle that is returned is analogous to a file handle and
<br>
&nbsp; &nbsp;owns a certain number of expanded memory pages. The handle must be used
<br>
&nbsp; &nbsp;with every subsequent request to map memory and must be released by a
<br>
&nbsp; &nbsp;close operation before the application terminates.
<br>
<br>
&nbsp;■ This function may fail because there are no handles left to allocate or
<br>
&nbsp; &nbsp;because there is an insufficient number of expanded memory pages to
<br>
&nbsp; &nbsp;satisfy the request. In the latter case, Int 67H Function 42H can be
<br>
&nbsp; &nbsp;used to determine the actual number of pages available.
<br>
<br>
&nbsp;■ [EMS 4.0] Int 67H Function 51H can be called to change the number of
<br>
&nbsp; &nbsp;pages allocated to an EMM handle.
<br>
<br>
&nbsp;■ [EMS 4.0] The pages allocated by this function are always 16 KB for
<br>
&nbsp; &nbsp;compatibility with earlier versions of EMS. See also Int 67H Function
<br>
&nbsp; &nbsp;5AH Subfunctions 00H and 01H.
<br>
<br>
&nbsp;■ [EMS 4.0] Handle 0000H is always available for use by the operating
<br>
&nbsp; &nbsp;system, and a prior call to this function is not required. The operating
<br>
&nbsp; &nbsp;system must call Int 67H Function 51H to assign the desired number of
<br>
&nbsp; &nbsp;pages to its reserved handle.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 44H (68)
<br>
Map expanded memory page
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Maps one of the logical pages of expanded memory assigned to a handle onto
<br>
&nbsp;a physical memory page that can be accessed by the CPU.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 44H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= physical page
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= logical page
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The logical page number is in the range {0...n-1}, where n is the number
<br>
&nbsp; &nbsp;of pages allocated or reallocated to the handle by a previous call to
<br>
&nbsp; &nbsp;Int 67H Function 43H, 51H, or 5AH. Logical pages allocated by Int 67H
<br>
&nbsp; &nbsp;Function 43H or Function 5AH Subfunction 00H are always 16 KB long;
<br>
&nbsp; &nbsp;logical pages allocated by Int 67H Function 5AH Subfunction 01H are
<br>
&nbsp; &nbsp;referred to as raw pages and are not necessarily 16 KB.
<br>
<br>
&nbsp;■ [EMS 3] The physical page is in the range 0─3 and lies within the EMM
<br>
&nbsp; &nbsp;page frame, whose base address is obtained from Int 67H Function 41H.
<br>
<br>
&nbsp;■ [EMS 4.0] A list of the available physical pages and their addresses may
<br>
&nbsp; &nbsp;be obtained from Int 67H Function 58H Subfunction 00H.
<br>
<br>
&nbsp;■ [EMS 4.0] If this function is called with BX = -1, the specified
<br>
&nbsp; &nbsp;physical page is unmapped (made inaccessible for reading or writing).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 45H (69)
<br>
Release handle and expanded memory
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Deallocates the expanded memory pages assigned to a handle and then
<br>
&nbsp;releases the handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 45H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If this function is not called before a program terminates, the EMS
<br>
&nbsp; &nbsp;pages it owned remain unavailable until the system is restarted.
<br>
&nbsp; &nbsp;Programs that use EMS should install their own Ctrl-C handlers and
<br>
&nbsp; &nbsp;critical-error handlers (Ints 23H and 24H) so that they cannot be
<br>
&nbsp; &nbsp;terminated unexpectedly.
<br>
<br>
&nbsp;■ [EMS 4.0] When a handle is released, its name is set to all ASCII nulls.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 46H (70)
<br>
Get version
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the EMS version supported by the expanded memory manager.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 46H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= version number
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The version number is returned in binary code decimal (BCD) format, with
<br>
&nbsp; &nbsp;the integer portion in the upper 4 bits of AL and the fractional portion
<br>
&nbsp; &nbsp;in the lower 4 bits. For example, under an EMM that supports EMS version
<br>
&nbsp; &nbsp;3.2, AL is returned as the value 32H.
<br>
<br>
&nbsp;■ Applications should always check the EMM version number to ensure that
<br>
&nbsp; &nbsp;all of the EMM functions they require are available.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 47H (71)
<br>
Save page map
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Saves the contents of the page-mapping registers on the expanded memory
<br>
&nbsp;hardware, associating those contents with a particular EMM handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 47H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is used by interrupt handlers or device drivers that must
<br>
&nbsp; &nbsp;access expanded memory. The EMM handle supplied to this function is the
<br>
&nbsp; &nbsp;handle that was assigned to the handler or driver during its own
<br>
&nbsp; &nbsp;initialization sequence, not to the program that was interrupted.
<br>
<br>
&nbsp;■ The mapping context is restored by a subsequent call to Int 67H Function
<br>
&nbsp; &nbsp;48H.
<br>
<br>
&nbsp;■ [EMS 4.0] This function saves only the mapping state for the 64 KB page
<br>
&nbsp; &nbsp;frame defined in EMS 3. Programs that are written to take advantage of
<br>
&nbsp; &nbsp;the additional capabilities of EMS 4.0 should use Int 67H Function 4EH
<br>
&nbsp; &nbsp;or 4FH in preference to this function.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 48H (72)
<br>
Restore page map
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Restores the contents of the page-mapping registers on the expanded memory
<br>
&nbsp;hardware to the values associated with the specified handle by a previous
<br>
&nbsp;call to Int 67H Function 47H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 48H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ This function is used by interrupt handlers or device drivers that must
<br>
&nbsp; &nbsp;access expanded memory. The EMM handle supplied to this function is the
<br>
&nbsp; &nbsp;handle that was assigned to the handler or driver during its own
<br>
&nbsp; &nbsp;initialization sequence, not to the program that was interrupted.
<br>
<br>
&nbsp;■ [EMS 4.0] This function restores only the mapping state for the 64 KB
<br>
&nbsp; &nbsp;page frame defined in EMS 3. Programs that are written to take advantage
<br>
&nbsp; &nbsp;of the additional capabilities of EMS 4.0 should use Int 67H Function
<br>
&nbsp; &nbsp;4EH or 4FH in preference to this function.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 49H (73)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;This function was defined in EMS version 3.0 but is not documented for
<br>
&nbsp;later EMS versions, so it should be avoided in application programs.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 4AH (74)
<br>
Reserved
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;This function was defined in EMS version 3.0 but is not documented for
<br>
&nbsp;later EMS versions, so it should be avoided in application programs.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 4BH (75)
<br>
Get handle count
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the number of active expanded memory handles.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4BH
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of active EMM handles
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If the returned number of EMM handles is zero, the expanded memory
<br>
&nbsp; &nbsp;manager is idle, and none of the expanded memory is in use.
<br>
<br>
&nbsp;■ The value returned by this function is not necessarily the same as the
<br>
&nbsp; &nbsp;number of programs using expanded memory because one program may own
<br>
&nbsp; &nbsp;multiple EMM handles.
<br>
<br>
&nbsp;■ The number of active EMM handles never exceeds 255.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 4CH (76)
<br>
Get handle pages
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the number of expanded memory pages allocated to a specific EMM
<br>
&nbsp;handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4CH
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of EMM pages
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ [EMS 3] The total number of pages allocated to a handle never exceeds
<br>
&nbsp; &nbsp;512. A handle never has zero pages allocated to it.
<br>
<br>
&nbsp;■ [EMS 4.0] The total number of pages allocated to a handle never exceeds
<br>
&nbsp; &nbsp;2048. A handle may have zero pages of expanded memory.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.0]
<br>
Function 4DH (77)
<br>
Get pages for all handles
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns an array that contains all the active handles and the number of
<br>
&nbsp;expanded memory pages associated with each handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4DH
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of active EMM handles
<br>
<br>
&nbsp;and buffer filled in as described in Notes
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The buffer is filled in with a series of DWORD (32-bit) entries, one per
<br>
&nbsp; &nbsp;active EMM handle. The first word of an entry contains the handle, and
<br>
&nbsp; &nbsp;the second word contains the number of pages allocated to that handle.
<br>
<br>
&nbsp;■ The maximum number of active handles is 256 (including the operating
<br>
&nbsp; &nbsp;system handle 0), so a buffer size of 1024 bytes is adequate in all
<br>
&nbsp; &nbsp;cases.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.2]
<br>
Function 4EH (78) Subfunction 00H
<br>
Save page map
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Saves the current page-mapping state of the expanded memory hardware in
<br>
&nbsp;the specified buffer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4EH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and buffer filled in with mapping information (see Notes)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The buffer receives the information necessary to restore the state of
<br>
&nbsp; &nbsp;the mapping registers using Int 67H Function 4EH Subfunction 01H. The
<br>
&nbsp; &nbsp;format of the information may vary.
<br>
<br>
&nbsp;■ The size of the buffer required by this function can be determined with
<br>
&nbsp; &nbsp;Int 67H Function 4EH Subfunction 03H.
<br>
<br>
&nbsp;■ Unlike Int 67H Function 47H, this function does not require a handle.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.2]
<br>
Function 4EH (78) Subfunction 01H
<br>
Restore page map
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Restores the page-mapping state of the expanded memory hardware using the
<br>
&nbsp;information in the specified buffer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4EH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The buffer contains information necessary to restore the state of the
<br>
&nbsp; &nbsp;mapping registers from a previous call to Int 67H Function 4EH
<br>
&nbsp; &nbsp;Subfunction 00H or 02H. The format of the information may vary.
<br>
<br>
&nbsp;■ Unlike Int 67H Function 48H, this function does not require a handle.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.2]
<br>
Function 4EH (78) Subfunction 02H
<br>
Save and restore page map
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Saves the current page-mapping state of the expanded memory hardware in a
<br>
&nbsp;buffer and then sets the mapping state using the information in another
<br>
&nbsp;buffer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4EH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer containing mapping information
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(see Notes)
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer to receive mapping information
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and buffer pointed to by ES:DI filled in with mapping information (see
<br>
&nbsp;Notes)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The buffer addressed by DS:SI contains information necessary to restore
<br>
&nbsp; &nbsp;the state of the mapping registers from a previous call to Int 67H
<br>
&nbsp; &nbsp;Function 4EH Subfunction 00H or 02H. The format of the information may
<br>
&nbsp; &nbsp;vary.
<br>
<br>
&nbsp;■ The sizes of the buffers required by this function can be determined
<br>
&nbsp; &nbsp;with Int 67H Function 4EH Subfunction 03H.
<br>
<br>
&nbsp;■ Unlike Int 67H Functions 47H and 48H, this function does not require a
<br>
&nbsp; &nbsp;handle.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 3.2]
<br>
Function 4EH (78) Subfunction 03H
<br>
Get size of page map information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the size of the buffer that is required to receive page-mapping
<br>
&nbsp;information using Int 67H Function 4EH Subfunctions 00H and 02H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4EH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= size of buffer (bytes)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 4FH (79) Subfunction 00H
<br>
Save partial page map
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Saves the state of a subset of the expanded memory page-mapping registers
<br>
&nbsp;in the specified buffer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4FH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of map list (see Notes)
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer to receive mapping state (see
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and buffer filled in with mapping information (see Notes)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The map list contains the number of mappable segments in the first word,
<br>
&nbsp; &nbsp;followed by the segment addresses of the mappable memory regions (one
<br>
&nbsp; &nbsp;segment per word).
<br>
<br>
&nbsp;■ To determine the size of the buffer required for the mapping state, use
<br>
&nbsp; &nbsp;Int 67H Function 4FH Subfunction 02H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 4FH (79) Subfunction 01H
<br>
Restore partial page map
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Restores the state of a subset of the expanded memory page-mapping
<br>
&nbsp;registers.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4FH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Note)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The buffer contains mapping information and must have been prepared by a
<br>
&nbsp; &nbsp;previous call to Int 67H Function 4FH Subfunction 00H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 4FH (79) Subfunction 02H
<br>
Get size of partial page map information
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the size of the buffer which will be required to receive partial
<br>
&nbsp;page-mapping information using Int 67H Function 4FH Subfunction 00H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 4FH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of pages
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= size of array (bytes)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 50H (80) Subfunction 00H
<br>
Map multiple pages by number
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Maps one or more of the logical expanded memory pages assigned to a handle
<br>
&nbsp;onto physical memory pages that can be accessed by the CPU. Physical pages
<br>
&nbsp;are referenced by their numbers.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 50H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of pages to map
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Note)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The buffer contains a series of DWORD (32-bit) entries that control the
<br>
&nbsp; &nbsp;pages to be mapped. The first word of each entry contains the logical
<br>
&nbsp; &nbsp;expanded memory page number, and the second word contains the physical
<br>
&nbsp; &nbsp;page number to which it should be mapped. If the logical page is -1, the
<br>
&nbsp; &nbsp;physical page is unmapped (made inaccessible for reading or writing).
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 50H (80) Subfunction 01H
<br>
Map multiple pages by address
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Maps one or more of the logical expanded memory pages assigned to a handle
<br>
&nbsp;onto physical memory pages that can be accessed by the CPU. Physical pages
<br>
&nbsp;are referenced by their segment addresses.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 50H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of pages to map
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The buffer contains a series of DWORD (32-bit) entries that control the
<br>
&nbsp; &nbsp;pages to be mapped. The first word of each entry contains the logical
<br>
&nbsp; &nbsp;page number, and the second word contains the physical page segment
<br>
&nbsp; &nbsp;address to which it should be mapped. If the logical page is -1, the
<br>
&nbsp; &nbsp;physical page is unmapped (made inaccessible for reading or writing).
<br>
<br>
&nbsp;■ The mappable segment addresses may be obtained by calling Int 67H
<br>
&nbsp; &nbsp;Function 58H Subfunction 00H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 51H (81)
<br>
Reallocate pages for handle
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Modifies the number of expanded memory pages allocated to an EMM handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 51H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= new number of pages
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= logical pages owned by EMM handle
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ If the requested number of pages is zero, the handle is still active,
<br>
&nbsp; &nbsp;and pages can be reallocated to the handle at a later time; also, the
<br>
&nbsp; &nbsp;handle must still be released with Int 67H Function 45H before the
<br>
&nbsp; &nbsp;application terminates.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 52H (82) Subfunction 00H
<br>
Get handle attribute
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the attribute (volatile or nonvolatile) associated with the
<br>
&nbsp;specified handle. A nonvolatile memory handle and the contents of the
<br>
&nbsp;expanded memory pages that are allocated to it are maintained across a
<br>
&nbsp;warm boot operation (system restart using Ctrl-Alt-Del).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 52H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; = volatile
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; = nonvolatile
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 52H (82) Subfunction 01H
<br>
Set handle attribute
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Sets the attribute (volatile or nonvolatile) associated with the specified
<br>
&nbsp;handle. A nonvolatile memory handle and the contents of the expanded
<br>
&nbsp;memory pages that are allocated to it are maintained across a warm boot
<br>
&nbsp;operation (system restart using Ctrl-Alt-Del).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 52H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; = volatile
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; = nonvolatile
<br>
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ If the expanded memory hardware cannot support nonvolatile pages, this
<br>
&nbsp; &nbsp;function returns an error.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 52H (82) Subfunction 02H
<br>
Get attribute capability
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns a code indicating whether the Expanded Memory Manager and hardware
<br>
&nbsp;can support the nonvolatile attribute for EMM handles.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 52H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= attribute capability
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; = only volatile handles supported
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; = volatile and nonvolatile handles supported
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 53H (83) Subfunction 00H
<br>
Get handle name
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the 8-character name assigned to a handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 53H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of 8-byte buffer
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and name for handle in specified buffer
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ A handle's name is initialized to 8 zero bytes when it is allocated or
<br>
&nbsp; &nbsp;deallocated. Another name may be assigned to an active handle with Int
<br>
&nbsp; &nbsp;67H Function 53H Subfunction 01H. The bytes in a handle name need not
<br>
&nbsp; &nbsp;be ASCII characters.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 53H (83) Subfunction 01H
<br>
Set handle name
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Assigns a name to an EMM handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 53H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of 8-byte name
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The bytes in a handle name need not be ASCII characters, but the
<br>
&nbsp; &nbsp;sequence of 8 zero bytes is reserved for no name (the default after a
<br>
&nbsp; &nbsp;handle is allocated or deallocated). A handle name should be padded with
<br>
&nbsp; &nbsp;zero bytes, if necessary, to a length of 8 bytes.
<br>
<br>
&nbsp;■ A handle may be renamed at any time.
<br>
<br>
&nbsp;■ All handle names are initialized to 8 zero bytes when the system is
<br>
&nbsp; &nbsp;turned on. The name of a nonvolatile handle is preserved across a warm
<br>
&nbsp; &nbsp;boot. (See Int 67H Function 52H Subfunctions 00H and 02H.)
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 54H (84) Subfunction 00H
<br>
Get all handle names
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the names for all active handles.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 54H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of active handles
<br>
<br>
&nbsp;and buffer filled in with handle-name information (see Notes)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The function fills the buffer with a series of 10-byte entries. The
<br>
&nbsp; &nbsp;first 2 bytes of each entry contain an EMM handle, and the next 8 bytes
<br>
&nbsp; &nbsp;contain the name associated with the handle. Handles that have never
<br>
&nbsp; &nbsp;been assigned a name have 8 bytes of 0 as a name.
<br>
<br>
&nbsp;■ Because there is a maximum of 255 active handles, the buffer need not be
<br>
&nbsp; &nbsp;longer than 2550 bytes.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 54H (84) Subfunction 01H
<br>
Search for handle name
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the EMM handle associated with the specified name.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 54H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of 8-byte handle name
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 54H (84) Subfunction 02H
<br>
Get total handles
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the total number of handles that are supported by the Expanded
<br>
&nbsp;Memory Manager, including the operating-system handle (0).
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 54H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of handles
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 55H (85) Subfunctions 00H and 01H
<br>
Map pages and jump
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Alters the expanded memory mapping context and transfers control to the
<br>
&nbsp;specified address.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 55H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; = map using physical page numbers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; = map using physical page segments
<br>
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The buffer contains map-and-jump entries in the following format:
<br>
<br>
&nbsp; &nbsp;Offset &nbsp; &nbsp; &nbsp; &nbsp;Length &nbsp; &nbsp; &nbsp; &nbsp; Description
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;far pointer to jump target
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number of pages to map before jump
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;far pointer to map list (see below)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;The map list in turn consists of DWORD (32-bit) entries, one per page.
<br>
&nbsp; &nbsp;The first word of each entry contains the logical page number, and the
<br>
&nbsp; &nbsp;second word contains the physical page number or segment (depending on
<br>
&nbsp; &nbsp;the value in register AL) to which it should be mapped.
<br>
<br>
&nbsp;■ A request to map zero pages and jump is not considered an error; the
<br>
&nbsp; &nbsp;effect is a simple far jump.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 56H (86) Subfunctions 00H and 01H
<br>
Map pages and call
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Alters the expanded memory mapping context and performs a far call to the
<br>
&nbsp;specified address. When the destination routine executes a far return, the
<br>
&nbsp;EMM again alters the page-mapping context as instructed and then returns
<br>
&nbsp;control to the original caller.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 56H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= subfunction
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; = map using physical page numbers
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; = map using physical page segments
<br>
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The format of the buffer containing map and call information is:
<br>
<br>
&nbsp; &nbsp;Offset &nbsp; &nbsp; &nbsp; &nbsp;Length &nbsp; &nbsp; &nbsp; &nbsp; Description
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;far pointer to call target
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number of pages to map before call
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;far pointer to list of pages to map before
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call (see below)
<br>
&nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number of pages to map before return
<br>
&nbsp; &nbsp;0AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;far pointer to list of pages to map before
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (see below)
<br>
&nbsp; &nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reserved (0)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp; &nbsp;Both map lists have the same format and consist of a series of
<br>
&nbsp; &nbsp;double-word entries, one per page. The first word of each entry contains
<br>
&nbsp; &nbsp;the logical page number, and the second word contains the physical page
<br>
&nbsp; &nbsp;number or segment (depending on the value in register AL) to which it
<br>
&nbsp; &nbsp;should be mapped.
<br>
<br>
&nbsp;■ A request to map zero pages and call is not an error; the effect is a
<br>
&nbsp; &nbsp;simple far call.
<br>
<br>
&nbsp;■ This function uses extra stack space to save information about the
<br>
&nbsp; &nbsp;mapping context; the amount of stack space required can be determined by
<br>
&nbsp; &nbsp;calling Int 67H Function 56H Subfunction 02H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 56H (86) Subfunction 02H
<br>
Get stack space for map page and call
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the number of bytes of stack space required by Int 67H Function
<br>
&nbsp;56H Subfunction 00H or 01H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 56H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= stack space required (bytes)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 57H (87) Subfunction 00H
<br>
Move memory region
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Copies a memory region from any location in conventional or expanded
<br>
&nbsp;memory to any other location without disturbing the current expanded
<br>
&nbsp;memory mapping context.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 57H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The format of the buffer controlling the move operation is:
<br>
<br>
&nbsp; &nbsp;Offset &nbsp; &nbsp; &nbsp; &nbsp;Length &nbsp; &nbsp; &nbsp; &nbsp; Description
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;region length in bytes
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;source memory type (0 = conventional, 1 =
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expanded)
<br>
&nbsp; &nbsp;05H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;source memory handle
<br>
&nbsp; &nbsp;07H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;source memory offset
<br>
&nbsp; &nbsp;09H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;source memory segment or physical page
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; number
<br>
&nbsp; &nbsp;0BH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;destination memory type (0 = conventional,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 = expanded)
<br>
&nbsp; &nbsp;0CH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;destination memory handle
<br>
&nbsp; &nbsp;0EH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;destination memory offset
<br>
&nbsp; &nbsp;10H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;destination memory segment or physical page
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; number
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;■ A length of zero bytes is not an error. The maximum length of a move is
<br>
&nbsp; &nbsp;1 MB. If the length exceeds a single expanded memory page, consecutive
<br>
&nbsp; &nbsp;expanded memory pages (as many as are required) supply or receive the
<br>
&nbsp; &nbsp;data.
<br>
<br>
&nbsp;■ If the source and destination addresses overlap, the move will be
<br>
&nbsp; &nbsp;performed in such a way that the destination receives an intact copy of
<br>
&nbsp; &nbsp;the original data, and a nonzero status is returned.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 57H (87) Subfunction 01H
<br>
Exchange memory regions
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Exchanges any two memory regions in conventional or expanded memory
<br>
&nbsp;without disturbing the current expanded memory mapping context.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 57H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;DS:SI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The format of the buffer controlling the exchange operation is the same
<br>
&nbsp; &nbsp;as for Int 67H Function 57H Subfunction 00H.
<br>
<br>
&nbsp;■ An exchange of zero bytes is not an error. The maximum length of an
<br>
&nbsp; &nbsp;exchange is 1 MB. If the length exceeds a single expanded memory page,
<br>
&nbsp; &nbsp;consecutive expanded memory pages (as many as are required) supply or
<br>
&nbsp; &nbsp;receive the data.
<br>
<br>
&nbsp;■ If the source and destination addresses overlap, the exchange is not
<br>
&nbsp; &nbsp;performed and an error is returned.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 58H (88) Subfunction 00H
<br>
Get addresses of mappable pages
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the segment base address and physical page number for each
<br>
&nbsp;mappable page in the system.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 58H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of entries in mappable physical page array
<br>
<br>
&nbsp;and page number/address information in buffer (see Notes)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Upon return from the function, the buffer contains a series of
<br>
&nbsp; &nbsp;double-word entries, one per mappable page. The first word of an entry
<br>
&nbsp; &nbsp;contains the page's segment base address, and the second contains its
<br>
&nbsp; &nbsp;physical page number. The entries are sorted in order of ascending
<br>
&nbsp; &nbsp;segment addresses.
<br>
<br>
&nbsp;■ The size of the buffer required can be calculated with the information
<br>
&nbsp; &nbsp;returned by Int 67H Function 58H Subfunction 01H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 58H (88) Subfunction 01H
<br>
Get number of mappable pages
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the number of mappable physical pages.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 58H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;CX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of mappable physical pages
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ The information returned by this function can be used to calculate the
<br>
&nbsp; &nbsp;size of the buffer that will be needed by Int 67H Function 58H
<br>
&nbsp; &nbsp;Subfunction 00H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 59H (89) Subfunction 00H
<br>
Get hardware configuration
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns information about the configuration of the expanded memory
<br>
&nbsp;hardware.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 59H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of buffer (see Notes)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;and hardware configuration information in buffer.
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Upon return from the function, the buffer has been filled in with
<br>
&nbsp; &nbsp;hardware configuration information in the following format:
<br>
<br>
&nbsp; &nbsp;Offset &nbsp; &nbsp; &nbsp; &nbsp;Length &nbsp; &nbsp; &nbsp; &nbsp; Description
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
&nbsp; &nbsp;00H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;size of raw expanded memory pages (in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paragraphs)
<br>
&nbsp; &nbsp;02H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number of alternate register sets
<br>
&nbsp; &nbsp;04H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;size of mapping-context save area (in
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes)
<br>
&nbsp; &nbsp;06H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number of register sets that can be
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assigned to DMA channels
<br>
&nbsp; &nbsp;08H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DMA operation type (0 = DMA may be used
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with alternate register sets; 1 = only one
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DMA register set available)
<br>
&nbsp; &nbsp;────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;■ The size returned for the mapping-context save area is the same as the
<br>
&nbsp; &nbsp;size returned by Int 67H Function 4EH Subfunction 03H.
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 59H (89) Subfunction 01H
<br>
Get number of raw pages
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Obtains the total number of raw expanded memory pages present in the
<br>
&nbsp;system and the number of raw pages that are not already allocated. Raw
<br>
&nbsp;memory pages may have a size other than 16 KB.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 59H
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= unallocated raw pages
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= total raw pages
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ If the Expanded Memory Manager supports only pages of standard size, the
<br>
&nbsp; &nbsp;values returned by this function are the same as those returned by Int
<br>
&nbsp; &nbsp;67H Function 42H.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5AH (90) Subfunction 00H
<br>
Allocate handle and standard pages
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Allocates an EMM handle and associates standard (16 KB) expanded memory
<br>
&nbsp;pages with that handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5AH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of standard pages to allocate
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= EMM handle
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ Unlike Int 67H Function 43H, allocating zero pages with this function
<br>
&nbsp; &nbsp;is not an error.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5AH (90) Subfunction 01H
<br>
Allocate handle and raw pages
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Allocates a raw EMM handle and associates raw expanded memory pages with
<br>
&nbsp;that handle.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5AH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= number of raw pages to allocate
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= handle for raw EMM pages
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ Raw memory pages may have a size other than 16 KB.
<br>
<br>
&nbsp;■ Allocation of zero pages is not an error.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5BH (91) Subfunction 00H
<br>
Get alternate map registers
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the number of the active alternate register set or, if no
<br>
&nbsp;alternate set is active, saves the state of the mapping registers into a
<br>
&nbsp;buffer and returns its address.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful and alternate map register set active
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= current active alternate map register set
<br>
<br>
&nbsp;If function successful and alternate map register set not active
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of alternate map register save area
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(if BL = 0)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The address of the save area must have been specified in a previous call
<br>
&nbsp; &nbsp;to Int 67H Function 5BH Subfunction 01H, and the save area must have
<br>
&nbsp; &nbsp;been initialized by a previous call to Int 67H Function 4EH Subfunction
<br>
&nbsp; &nbsp;00H. If there was no previous call to Int 67H Function 5BH Subfunction
<br>
&nbsp; &nbsp;01H, the address returned is zero, and the registers are not saved.
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5BH (91) Subfunction 01H
<br>
Set alternate map registers
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Selects an alternate map register set or (if alternate sets are not
<br>
&nbsp;supported) restores the mapping context from the specified buffer.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= alternate register set number or 00H
<br>
&nbsp;ES:DI &nbsp; &nbsp; &nbsp; &nbsp; = segment:offset of map register context restore area
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(if BL = 0)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The buffer address specified in this call is returned by subsequent
<br>
&nbsp; &nbsp;calls to Int 67H Function 5BH Subfunction 00H with BL = 00H.
<br>
<br>
&nbsp;■ The save area must have been initialized by a previous call to Int 67H
<br>
&nbsp; &nbsp;Function 4EH Subfunction 00H.
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5BH (91) Subfunction 02H
<br>
Get size of alternate map register save area
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Returns the amount of storage needed by Int 67H Function 5BH Subfunctions
<br>
&nbsp;00H and 01H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;DX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= size of buffer (bytes)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5BH (91) Subfunction 03H
<br>
Allocate alternate map register set
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Allocates an alternate map register set for use with Int 67H Function 5BH
<br>
&nbsp;Subfunctions 00H and 01H. The contents of the currently active map
<br>
&nbsp;registers are copied into the newly allocated alternate map registers in
<br>
&nbsp;order to provide an initial context when they are selected.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 03H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= alternate map register set number or zero, if no alternate
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sets are available
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5BH (91) Subfunction 04H
<br>
Deallocate alternate map register set
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Releases an alternate map register set that was previously allocated with
<br>
&nbsp;Int 67H Function 5BH Subfunction 03H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 04H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= alternate register set number
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ The current alternate map register set cannot be deallocated.
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5BH (91) Subfunction 05H
<br>
Allocate DMA register set
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Allocates a DMA register set.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 05H
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= DMA register set number (0 = none available)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5BH (91) Subfunction 06H
<br>
Enable DMA on alternate map register set
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Associates a DMA channel with an alternate map register set.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 06H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= alternate map register set
<br>
&nbsp;DL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= DMA channel number
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ If a DMA channel is not assigned to a specific register set, DMA for
<br>
&nbsp; &nbsp;that channel will be mapped through the current register set.
<br>
<br>
&nbsp;■ If zero is specified as the alternate map register set, no special
<br>
&nbsp; &nbsp;action is taken on DMA accesses for the specified DMA channel.
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5BH (91) Subfunction 07H
<br>
Disable DMA on alternate map register set
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Disables DMA accesses for all DMA channels associated with a specific
<br>
&nbsp;alternate map register set.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 07H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= alternate register set number
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5BH (91) Subfunction 08H
<br>
Deallocate DMA register set
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Deallocates a DMA register set that was previously allocated with Int 67H
<br>
&nbsp;Function 5BH Subfunction 05H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5BH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 08H
<br>
&nbsp;BL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= DMA register set number
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5CH (92)
<br>
Prepare Expanded Memory Manager for warm boot
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Prepares the expanded memory hardware for an impending warm boot. This
<br>
&nbsp;function affects the current mapping context, the alternate register set
<br>
&nbsp;in use, and any other expanded memory hardware dependencies that would
<br>
&nbsp;ordinarily be initialized at system boot time.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5CH
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Note:
<br>
<br>
&nbsp;■ If an application maps expanded memory at addresses below 640 KB, the
<br>
&nbsp; &nbsp;application must trap all possible conditions that might lead to a warm
<br>
&nbsp; &nbsp;boot, so that this function can be called first.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5DH (93) Subfunction 00H
<br>
Enable EMM operating-system functions
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Enables the operating-system─specific EMM functions (Int 67H Functions
<br>
&nbsp;59H, 5BH, and 5DH) for calls by any program or device driver. (This is
<br>
&nbsp;the default condition.)
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5DH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX:CX &nbsp; &nbsp; &nbsp; &nbsp; = access key (if not first call to function)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX:CX &nbsp; &nbsp; &nbsp; &nbsp; = access key (if first call to function)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ An access key is returned in registers BX and CX on the first call to
<br>
&nbsp; &nbsp;Int 67H Function 5DH Subfunction 00H or 01H. The access key is
<br>
&nbsp; &nbsp;required for all subsequent calls to either function.
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5DH (93) Subfunction 01H
<br>
Disable EMM operating-system functions
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Disables the operating-system─specific EMM functions (Int 67H Functions
<br>
&nbsp;59H, 5BH, and 5DH) for calls by application programs and device
<br>
&nbsp;drivers, reserving the use of these functions for the operating system.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5DH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 01H
<br>
&nbsp;BX:CX &nbsp; &nbsp; &nbsp; &nbsp; = access key (if not first call to function)
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
&nbsp;BX:CX &nbsp; &nbsp; &nbsp; &nbsp; = access key (if first call to function)
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ An access key is returned in registers BX and CX on the first call to
<br>
&nbsp; &nbsp;Int 67H Function 5DH Subfunction 00H or 01H. The access key is
<br>
&nbsp; &nbsp;required for all subsequent calls to either function.
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only.
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Int 67H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[EMS 4.0]
<br>
Function 5DH (93) Subfunction 02H
<br>
Release access key
<br>
────────────────────────────────────────────────────────────────────────────
<br>
<br>
&nbsp;Releases the access key obtained by a previous call to Int 67H Function
<br>
&nbsp;5DH Subfunction 00H or 01H.
<br>
<br>
Call with:
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 5DH
<br>
&nbsp;AL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 02H
<br>
&nbsp;BX:CX &nbsp; &nbsp; &nbsp; &nbsp; = access key
<br>
<br>
Returns:
<br>
<br>
&nbsp;If function successful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 00H
<br>
<br>
&nbsp;If function unsuccessful
<br>
<br>
&nbsp;AH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= error code
<br>
<br>
Notes:
<br>
<br>
&nbsp;■ With respect to the operating-system─specific expanded memory functions,
<br>
&nbsp; &nbsp;the EMM is returned to the state it had when the system was initialized.
<br>
&nbsp; &nbsp;A new access key is returned by the next call to Int 67H Function 5DH
<br>
&nbsp; &nbsp;Subfunction 00H or 01H.
<br>
<br>
&nbsp;■ This function is intended for use by operating systems only and can be
<br>
&nbsp; &nbsp;disabled by the operating system at any time.
<br>
<br>
<br>
<br>
────────────────────────────────────────────────────────────────────────────
<br>
Index
<br>
<br>
&nbsp;References to tables and illustrations are in italics.
<br>
<br>
<br>
Special Characters
<br>
<br>
| 298-99
<br>
187
<br>
. 187-88
<br>
; 60
<br>
&lt; 298-99
<br>
&gt; 298-99
<br>
&gt;&gt; 298-99
<br>
@ 60
<br>
<br>
A
<br>
Absolute disk read 482-84
<br>
Absolute disk write 484-85
<br>
adapters, video display 86-87
<br>
alarm
<br>
&nbsp; reset 592
<br>
&nbsp; set 591-92
<br>
align type 38
<br>
Allocate alternate map register set (EMS) 641
<br>
Allocate DMA register set (EMS) 642
<br>
Allocate handle and pages (EMS) 617-18
<br>
Allocate handle and raw pages (EMS) 639
<br>
Allocate handle and standard pages (EMS) 638-39
<br>
Allocate memory block 438-39
<br>
ANSI.SYS device driver, screen control 91
<br>
&nbsp; escape sequences used with 92-93
<br>
APPEND 490-91
<br>
application program interface (API) 320
<br>
application programs. See MS-DOS application programs, porting to OS/2;
<br>
&nbsp; &nbsp; MS-DOS application programs, structure of; MS-DOS application programs,
<br>
&nbsp; &nbsp; writing compatible
<br>
arena entries 196
<br>
arena headers 196, 201
<br>
&nbsp; diagram example 202
<br>
ASCII escape code 92-93
<br>
ASCII mode 69
<br>
&nbsp; character-device drivers in 261-62
<br>
ASCII text files 56
<br>
ASCIIZ strings 24, 139, 168
<br>
ASM files 45. See also assembly-language programs
<br>
assembly-language programs 37-42
<br>
&nbsp; to access file allocation table 191
<br>
&nbsp; BREAK.ASM 75-78
<br>
&nbsp; CLEAN.ASM 304-9
<br>
&nbsp; DRIVER.ASM 283-91
<br>
&nbsp; DUMP.ASM 152-61
<br>
&nbsp; HELLO.COM example 27-30, 33-36
<br>
&nbsp; program modules 37
<br>
&nbsp; program procedures 41-42
<br>
&nbsp; program segments 38-41
<br>
&nbsp; PROTO.ASM 301-2
<br>
&nbsp; SHELL.ASM program 229-38
<br>
&nbsp; TALK.ASM 113-26
<br>
&nbsp; ZERODIV.ASM 254, 255-58
<br>
ASSIGN 489
<br>
ASSUME statement 29, 33
<br>
attribute byte
<br>
&nbsp; color text display 98
<br>
&nbsp; monochrome text display 97
<br>
attribute word, device 264
<br>
Auxiliary device (AUX) 12, 106, 298. See also serial port
<br>
Auxiliary input 344-45
<br>
Auxiliary output 345-46
<br>
<br>
B
<br>
background, set 508-9
<br>
BACKUP command 15
<br>
BAT (batch) files 15
<br>
Batch files 15
<br>
binary mode 69
<br>
&nbsp; character-device drivers in 261-62
<br>
&nbsp; output 93-94
<br>
BIOS module 12-13, 17
<br>
&nbsp; get address of extended, 574
<br>
BIOS parameter block (BPB) 181, 189
<br>
&nbsp; build 272
<br>
&nbsp; structure 269
<br>
bit planes 101
<br>
blink/intensity bit, toggle 513
<br>
block-device drivers 260, 262
<br>
&nbsp; check for remoteness 423-24
<br>
&nbsp; check removability of 422-23
<br>
&nbsp; generic I/O control of 429-32
<br>
&nbsp; read control data from 418-19
<br>
&nbsp; write control data to 419-20
<br>
Boot disk device (block device) 12
<br>
boot drive, get 392-93
<br>
boot sector, disk 179-82
<br>
&nbsp; map of 180
<br>
&nbsp; partial disassembly of 182
<br>
&nbsp; partial hex dump 181
<br>
bootstrap routine 16, 17
<br>
border
<br>
&nbsp; get color 514
<br>
&nbsp; get palette and 514
<br>
&nbsp; set 508-9
<br>
&nbsp; set color 512
<br>
BREAK.ASM program 75-78
<br>
break flag, get or set 392-93
<br>
Buffered keyboard input 351-52
<br>
Build BIOS Parameter Block (function 02H) 272
<br>
<br>
C
<br>
CALL instructions 41
<br>
Cancel device redirection 467-68
<br>
cassette motor
<br>
&nbsp; read 561
<br>
&nbsp; turn off 560-61
<br>
&nbsp; turn on 560
<br>
&nbsp; write 562
<br>
C files 45. See also C language
<br>
Change sharing retry count 425-26
<br>
character blocks, set specifier 520
<br>
character-device drivers 260, 261-62
<br>
&nbsp; ASCII vs binary mode 261-62
<br>
&nbsp; generic I/O control 426-29
<br>
&nbsp; read control data from 415-16
<br>
&nbsp; write control data to 416-17
<br>
character input/output. See also keyboard input; mouse, input; pointing
<br>
&nbsp; &nbsp; device, input; printer output; serial port
<br>
&nbsp; Int 21H 44H IOCTL (I/O control) 411-43
<br>
&nbsp; Int 21H functions, summary 337-38 (table)
<br>
&nbsp; processing typical I/O request 281-82
<br>
Character input with echo 343
<br>
Character input without echo 349-50
<br>
Character output 344
<br>
CHDIR (CD) command 167
<br>
Check if block device is remote 423-24
<br>
Check if block device is removable 422-23
<br>
Check if handle is remote 424-25
<br>
Check input status 353, 420-21
<br>
Check output status 421-22
<br>
child programs 218
<br>
CHKDSK command 15, 174, 222
<br>
C language
<br>
&nbsp; CLEAN.C 309-11
<br>
&nbsp; compiler (see C Optimizing Compiler)
<br>
&nbsp; DUMP.C program 151, 161-63
<br>
&nbsp; linking Ctrl-C and Ctrl-Break handlers to programs in 75-80
<br>
&nbsp; MOUDEMO.C 82-83
<br>
&nbsp; polling mouse and displaying mouse coordinates 82-83
<br>
&nbsp; PROTO.C 303
<br>
&nbsp; SHELL.C 225-29
<br>
&nbsp; TRYBREAK 78-79
<br>
&nbsp; tutorials 63
<br>
class type 38
<br>
CLEAN filter 303-11
<br>
&nbsp; assembly source code 304-9
<br>
&nbsp; C source code 309-11
<br>
clock, set tick count 589-90
<br>
CLOCK driver 282
<br>
Close file 357-58, 404-5
<br>
code page, get or set 474-75
<br>
code segment 38
<br>
code segment (CS) register 30
<br>
Color/Graphics Adapter (CGA) 86, 98, 102
<br>
color page state
<br>
&nbsp; get 517
<br>
&nbsp; set 515-16
<br>
color register(s)
<br>
&nbsp; get 516
<br>
&nbsp; get block of 516-17
<br>
&nbsp; set 514-15
<br>
&nbsp; set block of 515
<br>
COM1, COM2, COM3 devices 106, 110-12, 298
<br>
combine type 38
<br>
command code routines, device-driver 267-81
<br>
&nbsp; function 00H, Driver initialization 268-69
<br>
&nbsp; function 01H, Media Check 270-71
<br>
&nbsp; function 02H, Build BIOS Parameter Block (BPB) 272
<br>
&nbsp; function 03H, I/O-Control Read 272-73
<br>
&nbsp; function 04H, Read 273
<br>
&nbsp; function 05H, Nondestructive Read 274
<br>
&nbsp; function 06H, Input Status 274
<br>
&nbsp; function 07H, Flush Input Buffers 274-75
<br>
&nbsp; function 08H, Write 275
<br>
&nbsp; function 09H, Write with Verify 276
<br>
&nbsp; function 0AH, Output Status 276
<br>
&nbsp; function 0BH, Flush Output Buffers 276
<br>
&nbsp; function 0CH, I/O-Control Write 276-77
<br>
&nbsp; function 0DH, Device Open 277
<br>
&nbsp; function 0EH, Device Close 277-78
<br>
&nbsp; function 0FH, Removable Media 278
<br>
&nbsp; function 10H, Output Until Busy 278-79
<br>
&nbsp; function 13H, Generic IOCTL 279-80
<br>
&nbsp; function 17H, Get Logical Device 280
<br>
&nbsp; function 18H, Set Logical Device 280-81
<br>
&nbsp; names of, and MS-DOS version support 267-68 (table)
<br>
COMMAND.COM file 14-16
<br>
&nbsp; load 20
<br>
&nbsp; replacing 13
<br>
&nbsp; use of EXEC function 218
<br>
COMMAND.COM PLUS 13
<br>
command processor (shell) 13. See also COMMAND.COM file
<br>
commands, types of, accepted by COMMAND.COM 14-15
<br>
command tail 24, 220-21
<br>
Commit file 476-77
<br>
compatibility and portability 313-31
<br>
&nbsp; degrees of compatibility 314-18
<br>
&nbsp; &nbsp; &nbsp;MS-DOS applications 315-17
<br>
&nbsp; &nbsp; &nbsp;ROM BIOS and hardware-compatible applications 317-18
<br>
&nbsp; OS/2 compatibility 318-31
<br>
COM program file(s) 15, 22, 25-30, 45
<br>
&nbsp; assembly-language program transformed into 27-30
<br>
&nbsp; vs .EXE files 22, 36 (table)
<br>
&nbsp; memory allocation for 197-98
<br>
&nbsp; memory image of a typical 26
<br>
CONFIG.SYS file 12
<br>
&nbsp; installing device driver 293
<br>
&nbsp; opening 18-19
<br>
configuration
<br>
&nbsp; get equipment 535-36
<br>
&nbsp; get information 525
<br>
&nbsp; get system environment 573-74
<br>
console, direct input/output 347-48. See also video display
<br>
Console display and keyboard (CON) 12, 298-99
<br>
control data
<br>
&nbsp; read, from block-device driver 418-19
<br>
&nbsp; read, from character-device driver 415-16
<br>
&nbsp; write, to block-device driver 419-20
<br>
&nbsp; write, to character-device driver 416-17
<br>
Controller drive diagnostic 551
<br>
Controller internal diagnostic 551
<br>
Controller RAM diagnostic 550
<br>
cooked mode 69
<br>
C Optimizing Compiler 44, 48-50
<br>
&nbsp; environmental variables 48
<br>
&nbsp; version 5.1 switches 49-50
<br>
COPY command 14, 58
<br>
Country information
<br>
&nbsp; get extended 470-74
<br>
&nbsp; get or set 395-98
<br>
CP/M operating system 4, 5
<br>
&nbsp; FCB compatibility with 129, 130-31
<br>
&nbsp; program segment prefix compatibility with 24, 25
<br>
Create directory 398-99
<br>
Create file 364-65, 401-2
<br>
Create new file 458-59
<br>
Create new PSP 378-79
<br>
Create temporary file 457-58
<br>
CREF utility 44, 56-58
<br>
&nbsp; cross-reference listing for HELLO.REF 57
<br>
CRF files 45, 56
<br>
Critical-error handler address 481-82
<br>
critical-error handlers 24, 145, 147-51
<br>
&nbsp; address 481-82
<br>
&nbsp; skeleton program example 150-51
<br>
&nbsp; stack at entry to 148, 149
<br>
cross-reference listing. See CREF utility
<br>
Ctrl-Break and Ctrl-C handlers 72-80
<br>
&nbsp; compatibility issues 317
<br>
&nbsp; Ctrl-C handler address 480-81
<br>
&nbsp; high-level languages and 75-80
<br>
cursor
<br>
&nbsp; addressing 97
<br>
&nbsp; enable/disable emulation 528
<br>
&nbsp; get position 502-3
<br>
&nbsp; read character and attribute at 506
<br>
&nbsp; set position 501-2
<br>
&nbsp; set type 501
<br>
&nbsp; write character and attribute at 506-7
<br>
&nbsp; write character at 507-8
<br>
<br>
D
<br>
data segment 38
<br>
data segment (DS) register 31, 35
<br>
Date and time device (CLOCK$) 12
<br>
day count
<br>
&nbsp; get 592-93
<br>
&nbsp; set 593
<br>
Deallocate alternate map register set (EMS) 642
<br>
Deallocate DMA register set (EMS) 644
<br>
DEF files 45
<br>
Delay 568-69
<br>
DEL(ETE) command 14
<br>
Delete directory 399
<br>
Delete file 361-62, 40, sug&gt;8
<br>
dependency statements 61
<br>
descriptors, memory segment 321
<br>
device
<br>
&nbsp; cancel redirection 467-68
<br>
&nbsp; close 565
<br>
&nbsp; get device information 412-13
<br>
&nbsp; open 564-65
<br>
&nbsp; post 572-73
<br>
&nbsp; read file or 405-6
<br>
&nbsp; redirect 466-67
<br>
&nbsp; set device information 414-15
<br>
&nbsp; wait 571
<br>
&nbsp; write file or 406-7
<br>
Device Close (command code function 0EH) 277-78
<br>
Device close (MS-DOS function) 565
<br>
DEVICE commands 12
<br>
device drivers, installable 12-13, 259-96
<br>
&nbsp; CLOCK driver 282
<br>
&nbsp; command-code routines 267-81
<br>
&nbsp; debugging 295-96
<br>
&nbsp; chain before/after driver installation 294
<br>
&nbsp; chain listing 295
<br>
&nbsp; device attribute word 264
<br>
&nbsp; error codes 267
<br>
&nbsp; MS-DOS type 260-63
<br>
&nbsp; processing of typical input/output requests 281-82
<br>
&nbsp; structure of MS-DOS 263-67
<br>
&nbsp; &nbsp; &nbsp;device header 263-64
<br>
&nbsp; &nbsp; &nbsp;interrupt routine 26-67
<br>
&nbsp; &nbsp; &nbsp;strategy routine 265
<br>
&nbsp; writing and installing 282-95
<br>
&nbsp; &nbsp; &nbsp;assembly 283-92
<br>
&nbsp; &nbsp; &nbsp;installation 293-95
<br>
&nbsp; &nbsp; &nbsp;linking 293
<br>
device drivers, resident 12-13
<br>
Device Open (command-code function 0DH) 277
<br>
Device open (MS-DOS function) 564-65
<br>
Device post 572-73
<br>
Device wait 571-72
<br>
Digital Research 4
<br>
DIR command 14, 167, 174
<br>
Direct console I/O 347-48
<br>
directory 166, 167-73
<br>
&nbsp; create 398-99
<br>
&nbsp; delete 399
<br>
&nbsp; format of a single entry in a disk 184, 185
<br>
&nbsp; functions controlling 167-68 get current 437-38
<br>
&nbsp; hierarchical (tree) structure 166, 167
<br>
&nbsp; moving files 173
<br>
&nbsp; root 184-86
<br>
&nbsp; searching 168-73
<br>
&nbsp; set current 400
<br>
directory operations, Int 21H functions summary 339
<br>
Disable DMA on alternate map register set (EMS) 643-44
<br>
Disable EMM operating system functions (EMS) 645-46
<br>
Disable mouse driver 608-9
<br>
disk(s) 177-94. See also drive, logical; ESDI Fixed Disk Drive Adapter
<br>
&nbsp; absolute read 482-84
<br>
&nbsp; absolute write 484-85
<br>
&nbsp; boot sector 179-82
<br>
&nbsp; controller drive diagnostic 551
<br>
&nbsp; controller internal diagnostic 551
<br>
&nbsp; controller RAM diagnostic 550
<br>
&nbsp; file allocation table 182-84
<br>
&nbsp; &nbsp; &nbsp;interpreting the 188-92
<br>
&nbsp; files area 186-88
<br>
&nbsp; fixed-disk partitions 192-94
<br>
&nbsp; format 543
<br>
&nbsp; format bad track 542
<br>
&nbsp; format track 541-42
<br>
&nbsp; get change status 552-53
<br>
&nbsp; get current 367
<br>
&nbsp; get default drive data 368-69
<br>
&nbsp; get drive allocation information 394-95
<br>
&nbsp; get drive data 370
<br>
&nbsp; get drive parameters 543-44
<br>
&nbsp; get drive status 549
<br>
&nbsp; get type 552
<br>
&nbsp; initialize fixed disk characteristics 544-45
<br>
&nbsp; map of typical logical volume 179
<br>
&nbsp; park heads 554-55
<br>
&nbsp; read sector 538-39
<br>
&nbsp; read sector buffer 548
<br>
&nbsp; read sector long 545-46
<br>
&nbsp; recalibrate 550
<br>
&nbsp; reserved area 182
<br>
&nbsp; reset 354-55
<br>
&nbsp; reset fixed disk system 548
<br>
&nbsp; root directory 184-86, 187
<br>
&nbsp; seek 547
<br>
&nbsp; select 355-56
<br>
&nbsp; set media type 554
<br>
&nbsp; set type 553
<br>
&nbsp; set verify flag 387-88
<br>
&nbsp; verify sector 540
<br>
&nbsp; write sector 539-40
<br>
&nbsp; write sector buffer 549
<br>
&nbsp; write sector long 546-47
<br>
disk bootstrap routine 16
<br>
&nbsp; memory location of 17
<br>
disk management, Int 21H functions summary 339
<br>
disk-related errors 147, 148 (table)
<br>
Disk reset 354-55
<br>
disk system
<br>
&nbsp; get status 537-38
<br>
&nbsp; reset 536-37
<br>
disk transfer area (DTA) 25, 130
<br>
&nbsp; get 388-89
<br>
&nbsp; set 368
<br>
display page, set 503-4
<br>
Display string 350-51
<br>
DOS kernel 12, 18
<br>
&nbsp; memory location of 19
<br>
double-byte character sets (DBCS), get lead byte table 469-70
<br>
drive, logical 166, 16,-73. See also disk(s)
<br>
&nbsp; get map 433
<br>
&nbsp; set map 434
<br>
&nbsp; vs volume 174
<br>
driver. See device drivers, installable; device drivers, resident
<br>
DRIVER.ASM program 283-91
<br>
Driver Initialization (function 00H) 268-69
<br>
DUMP.ASM program 151, 152-61
<br>
&nbsp; subroutines 163
<br>
DUMP.C program 151, 161-63
<br>
Duplicate handle 435
<br>
dynamic link library 331
<br>
dynamic memory allocation 199, 200, 201
<br>
<br>
E
<br>
echo
<br>
&nbsp; character input with 343
<br>
&nbsp; character input without 349-50
<br>
&nbsp; unfiltered character input without 348-49
<br>
EMS. See Expanded Memory Specification (EMS)
<br>
Enable/disable cursor emulation 528
<br>
Enable/disable default palette loading 526-27
<br>
Enable/disable gray-scale summing 527
<br>
Enable/disable pointing device 574-75
<br>
Enable/disable screen refresh 529
<br>
Enable/disable video 527
<br>
Enable DMA on alternate map register set (EMS) 643
<br>
Enable EMM operating system functions (EMS) 645
<br>
Enable mouse driver 609
<br>
encapsulation of subroutines 323, 324-25
<br>
end of interrupt (EOI) 250
<br>
ENDP command 35, 41
<br>
ENDS command 29, 38
<br>
END statement 30-31, 36, 41
<br>
Enhanced Graphics Adapter (EGA) 86, 97, 98, 102
<br>
Enter protected mode 570-71
<br>
environment block 24, 220, 224-25
<br>
&nbsp; dump of a typical 224
<br>
&nbsp; three strings contained in 225
<br>
EQU statement 33
<br>
error codes, device driver 267
<br>
error codes, MS-DOS 145-51
<br>
&nbsp; critical 145, 147-51
<br>
&nbsp; expanded memory 207-9
<br>
error information, get/set 453-56
<br>
escape sequences, ANSI 92-93
<br>
ESDI Fixed Disk Drive Adapter (EP&gt;
<br>
&nbsp; format drive 555
<br>
&nbsp; format periodic interrupt 562-63
<br>
Event wait 566-67
<br>
Exchange memory regions (EMS) 635-36
<br>
EXE2BIN utility 44, 55-56
<br>
EXEC function 15, 217-42. See also Int 21H Function 4BH
<br>
&nbsp; calling convention 222
<br>
&nbsp; compatibility in MS-DOS applications 317
<br>
&nbsp; environment block 220, 224-25
<br>
&nbsp; example programs SHELL.C and SHELL.ASM 225-40
<br>
&nbsp; &nbsp; &nbsp;basic flow of both 239-40
<br>
&nbsp; &nbsp; &nbsp;internal commands in 239
<br>
&nbsp; example use of 223-24
<br>
&nbsp; loading overlays with 240, 241-42
<br>
&nbsp; making memory availinug for 218-19
<br>
&nbsp; reference 441-42
<br>
&nbsp; requesting 219-21
<br>
&nbsp; returning from 221-24
<br>
EXE (executable) program file(s) 15, 22, 30-36, 45
<br>
&nbsp; assembly language program transformed into 33-36
<br>
&nbsp; vs .COM files 22, 36 (table)
<br>
&nbsp; converting, to .COM files (see EXE2BIN utility)
<br>
&nbsp; header 30
<br>
&nbsp; load module contents 33 load module format 32
<br>
&nbsp; memory allocation for 198
<br>
&nbsp; memory image of 31
<br>
&nbsp; use for compatible MS-DOS applications 315
<br>
Expanded Memory Manager (EMM) 203-4
<br>
&nbsp; checking for 204, 205-6
<br>
&nbsp; enable/disable system functions 645-46
<br>
&nbsp; error codes 207-9
<br>
Expanded Memory Specification (EMS) 201-11
<br>
&nbsp; checking for expanded memory 204-6
<br>
&nbsp; expanded memory defined 203-4
<br>
&nbsp; functions reference (see Section IV)
<br>
&nbsp; &nbsp; &nbsp;summary 614-15
<br>
&nbsp; use of expanded memory 20,-11
<br>
&nbsp; &nbsp; &nbsp;skeleton program illustrating 210-11
<br>
Extended communications port control 559-60
<br>
extended file control block 131
<br>
&nbsp; volume-label search using 175
<br>
Extended initialize communications port 558-59
<br>
extended memory 204, 212-15
<br>
&nbsp; moving blocks of data between conventional memory and 213-15
<br>
Extended open file 478-80
<br>
external (extrinsic) commands 15
<br>
external hardware interrupts 247
<br>
extra segment (ES) register 31
<br>
<br>
F
<br>
FAR attribute 35
<br>
&nbsp; vs NEAR 29
<br>
faults (internal hardware interrupts) 246, 321
<br>
file(s)
<br>
&nbsp; area, in disks 186-88
<br>
&nbsp; close 357-58, 404
<br>
&nbsp; commit 476-77
<br>
&nbsp; create 364-65, 401-2
<br>
&nbsp; create new 458-59
<br>
&nbsp; create temporary 457-58
<br>
&nbsp; delete 361-62, 407-8
<br>
&nbsp; extended open 478-80
<br>
&nbsp; find first 358-59, 445-46
<br>
&nbsp; find next 360-61, 446-47
<br>
&nbsp; get file size 375-76
<br>
&nbsp; get/set date and time 450-51
<br>
&nbsp; lock/unlock file region 460-61
<br>
&nbsp; logical drive 166
<br>
&nbsp; moving 123
<br>
&nbsp; name and location 166
<br>
&nbsp; open 356-57, 402-4
<br>
&nbsp; read 405-6
<br>
&nbsp; rename 366, 449-50
<br>
&nbsp; types 45
<br>
&nbsp; write 406-7
<br>
file-access skeleton program
<br>
&nbsp; using FCB functions 134, 135-37
<br>
&nbsp; using handle functions 141, 142-43
<br>
file allocation table (FAT) 16, 182-84
<br>
&nbsp; assembly program to access 191
<br>
&nbsp; contents 183
<br>
&nbsp; interpreting 188-92
<br>
&nbsp; media descriptor bytes 183
<br>
file attributes, get or set 410-11
<br>
file control blocks (FCBs) 25, 128
<br>
&nbsp; default 130, 221
<br>
&nbsp; directory searching with 169, 170-71
<br>
&nbsp; extended 131, 133-34, 175
<br>
&nbsp; file management with FCB functions 129-39
<br>
&nbsp; &nbsp; &nbsp;advantages/disadvantages 138-39
<br>
&nbsp; &nbsp; &nbsp;file-access skeleton program 134-38
<br>
&nbsp; &nbsp; &nbsp;functions listed 132
<br>
&nbsp; &nbsp; &nbsp;vs handle functions 128
<br>
&nbsp; normal 129, 133-34
<br>
&nbsp; before/after open call (Int 21H Function 0FH) 137
<br>
&nbsp; restricted use 316, 319
<br>
&nbsp; typical operation of 130
<br>
file management 127-63
<br>
&nbsp; example programs DUMP.ASM and DUMP.C 151-63
<br>
&nbsp; FCB functions 128, 129-39
<br>
&nbsp; handle functions 128, 139-44
<br>
&nbsp; MS-DOS error codes 145-51
<br>
filename
<br>
&nbsp; fully qualified 16
<br>
&nbsp; parse 382-83
<br>
&nbsp; requesting EXEC function 219
<br>
file operations, Int 21H functions summary 338
<br>
file pointer, set 408-9
<br>
file system 166
<br>
&nbsp; structure 167
<br>
filters 297-311
<br>
&nbsp; building 300-303
<br>
&nbsp; CLEAN filter 303-11
<br>
&nbsp; operation of 299-300
<br>
&nbsp; prototype 301-3
<br>
&nbsp; system support for 298-99
<br>
Find first file 358-59, 445-46
<br>
Find next file 360-61, 44-47
<br>
fixed-disk partitions 192-94
<br>
font functions 518-24
<br>
Format bad track 542
<br>
Format drive 543
<br>
Format ESDI drive 555-56
<br>
Format ESDI drive periodic interrupt 562-63
<br>
Format track 541-42
<br>
Flush input buffer and then input 353-54
<br>
Flush Input Buffers (function 07H) 274-75
<br>
Flush Output Buffers (function 0BH) 276
<br>
<br>
G
<br>
Generic I/O control for block devices 429-32
<br>
Generic I/O control for character devices 426-29
<br>
Generic IOCTL (function 13H) 279-80
<br>
Get addresses of mappable pages (EMS) 636
<br>
Get address of alternate mouse event handler 606
<br>
Get address of extended BIOS data area 574
<br>
Get all handle names (EMS) 631
<br>
Get alternate map registers (EMS) 639-40
<br>
Get attribute capability (EMS) 630
<br>
Get block of color registers 516-17
<br>
Get border color 514
<br>
Get button press information 596
<br>
Get button release information 597
<br>
Get color page state 517
<br>
Get color register 516
<br>
Get communications port status 558
<br>
Get configuration information 525
<br>
Get conventional memory size 536
<br>
Get current directory 437-38
<br>
Get current disk 367
<br>
Get cursor position 502-3
<br>
Get date 384-85, 591
<br>
Get day count 592
<br>
Get DBCS lead byte table 469-70
<br>
Get default drive data 368-69
<br>
Get device inform~on 412-13
<br>
Get disk change status 552-53
<br>
Get disk system status 537-38
<br>
Get disk type 552
<br>
Get drive allocation information 394-95
<br>
Get drive data 370-71
<br>
Get drive parameters 543-44
<br>
Get drive status 549
<br>
Get DTA address 388-89
<br>
Get enhanced keyboard flags 586-87
<br>
Get equipment configuration 535-36
<br>
Get extended country information 470-74
<br>
Get extended error information 453-56
<br>
Get extended memory size 570
<br>
Get file size 375-76
<br>
Get font information 524
<br>
Get functionality/state information 531-34
<br>
Get handle attribute (EMS) 629
<br>
Get handle count (EMS) 621-22
<br>
Get handle name (EMS) 630
<br>
Get handle pages (EMS) 622
<br>
Get hardware configuration (EMS) 637-38
<br>
Get interrupt vector 393-94
<br>
Get keyboard flags 582
<br>
Get keyboard status 582
<br>
Get language number 610
<br>
Get light pen position 503
<br>
Get Logical Device (command-code function) 280
<br>
Get logical drive map 433
<br>
Get machine name 461-62
<br>
Get mouse information 611
<br>
Get mouse position and button status 595
<br>
Get mouse save state buffer size 603
<br>
Get mouse sensitivity 607
<br>
Get MS-DOS version number 389-90
<br>
Get number of mappable pages (EMS) 637
<br>
Get number of pages (EMS) 617
<br>
Get number of raw pages (EMS) 638
<br>
Get or set allocation strategy 452-53
<br>
Get or set break flag, get boot drive 392-93
<br>
Get or set code page 474-75
<br>
Get or set country information 395-98
<br>
Get or set display combination code 530-31
<br>
Get or set file Attributes 410-11
<br>
Get or set file date and time 450-51
<br>
Get page frame address (EMS) 616
<br>
Get pages for all handles (EMS) 623
<br>
Get palette and border 514
<br>
Get palette register 513
<br>
Get pointer page 608
<br>
Get pointing device type 577
<br>
Get printer setup string 463-64
<br>
Get printer status 588
<br>
Get PSP address 468-69
<br>
Get redirection list entry 464-65
<br>
Get return code 444-45
<br>
Get size of alternate map register save area (EMS) 641
<br>
Get size of page map information (EMS) 625
<br>
Get size of partial page map information (EMS) 626-27
<br>
Get stack space for map page and call (EMS) 634
<br>
Get status (EMS) 616
<br>
Get system environment 573-74
<br>
Get tick count 589
<br>
Get time 386, 590
<br>
Get total handles (EMS) 632
<br>
Get verify flag 448
<br>
Get version (EMS) 619
<br>
Get video mode 511
<br>
Graphics CardPlus 87
<br>
graphics mode memory-mapped programming 101-3
<br>
gray-scale
<br>
&nbsp; enable/disable summing 527
<br>
&nbsp; get values 517
<br>
GROUP directive 39
<br>
<br>
H
<br>
handle functions
<br>
&nbsp; check if handle is remote 424-25
<br>
&nbsp; directory searching 169-70, 172-73
<br>
&nbsp; DUMP.ASM program 151, 152-62
<br>
&nbsp; DUMP.C program 151, 161-63
<br>
&nbsp; duplicate handle 435
<br>
&nbsp; file/record management with 139-44
<br>
&nbsp; &nbsp; &nbsp;advantages/disadvantages 144
<br>
&nbsp; &nbsp; &nbsp;vs FCB functions 128
<br>
&nbsp; &nbsp; &nbsp;file access skeleton program 141-43
<br>
&nbsp; &nbsp; &nbsp;functions listed 140-41
<br>
&nbsp; &nbsp; &nbsp;typical operation 139
<br>
&nbsp; keyboard input 62, 67-69
<br>
&nbsp; redirect handle 436-37
<br>
&nbsp; set handle count 475-76
<br>
&nbsp; use for compatible MS-DOS applications 316
<br>
&nbsp; volume-label search using176
<br>
hardware-compatible applications 314-15, 317-18
<br>
header(EP&gt;
<br>
&nbsp; device 263, 264, 269
<br>
&nbsp; .EXE program files 30
<br>
Hercules Graphics Card 87, 97, 98
<br>
HELLO.COM program 27, 28-29, 30
<br>
&nbsp; hex dump of 33
<br>
&nbsp; map produced by Object Linker during generation of 51
<br>
HELLO.EXE program 33, 34-35, 36
<br>
HELLO.REF program, cross-reference listing 57
<br>
H files 45
<br>
Hide mouse pointer 595
<br>
<br>
I
<br>
IBMBIO.COM file 16
<br>
&nbsp; disk location 189-92
<br>
IBM Corporation, role in MS-DOS development 4-5
<br>
IBMDOS.COM file 13, 16
<br>
IBM PC 64
<br>
&nbsp; PC/AT 64
<br>
&nbsp; PS/2 64
<br>
&nbsp; regen buffers in memory for various adapters 87
<br>
&quot;ill-behaved&quot; applications 315
<br>
INC files 45
<br>
In-Color Card 87
<br>
Initialize communications port 556-57
<br>
Initialize fixed disk characteristics 544-45
<br>
Initialize or scroll window down 505-6
<br>
Initialize or scroll window up 505
<br>
Initialize pointing device interface 577-78
<br>
Initialize printer port 587-88
<br>
input. See character input/output; keyboard input; mouse, input; pointing
<br>
&nbsp; &nbsp; device, input; serial port
<br>
input buffer, flush 353-54
<br>
Input/Output (I/O)-Control Read (function 03H) 272-73
<br>
Input/Output (I/O)-Control Write (function 0CH) 276-77
<br>
input/output (I/O) redirection 67, 298-99
<br>
input status, check 353, 420
<br>
Input Status (command-code function 06H) 274
<br>
INS8250 Asynchronous Communications Controller 112
<br>
installable device drivers 12-13
<br>
Int 10H, ROM BIOS video driver
<br>
&nbsp; Function 00H, Set video mode 94, 500
<br>
&nbsp; Function 01H, Set cursor type 94, 501
<br>
&nbsp; Function 02H, Set cursor position 94, 501
<br>
&nbsp; Function 03H, Get cursor position 94, 502
<br>
&nbsp; Function 04H, Get light pen position 95, 503
<br>
&nbsp; Function 05H, Set display page 95, 503
<br>
&nbsp; Function 06H, Initialize or scroll window up 95, 505
<br>
&nbsp; Function 07H, Initialize or scroll window down 95, 505
<br>
&nbsp; Function 08H, Read character and attribute at cursor 95, 506
<br>
&nbsp; Function 09H, Write character and attribute at cursor 94, 506
<br>
&nbsp; Function 0AH, Write character at cursor 94, 507
<br>
&nbsp; Function 0BH, Set palette, background, or border 95, 508
<br>
&nbsp; Function 0CH, Write graphics pixel 95, 509
<br>
&nbsp; Function 0DH, Read graphics pixel 95, 510
<br>
&nbsp; Function 0EH, Write character in teletype mode 94, 510
<br>
&nbsp; Function 0FH, Get video mode 94, 511
<br>
&nbsp; Function 10H palette functions
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Set palette register 511
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Set border color 512
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Set palette and border 512-13
<br>
&nbsp; &nbsp; &nbsp;Subfunction 03H, Toggle blink/intensity bit 513
<br>
&nbsp; &nbsp; &nbsp;Subfunction 07H, Get palette register 513
<br>
&nbsp; &nbsp; &nbsp;Subfunction 08H, Get border color 514
<br>
&nbsp; &nbsp; &nbsp;Subfunction 09H, Get palette and border 514
<br>
&nbsp; &nbsp; &nbsp;Subfunction 10H, Set color register 514
<br>
&nbsp; &nbsp; &nbsp;Subfunction 12H, Set block of color registers 515
<br>
&nbsp; &nbsp; &nbsp;Subfunction 13H, Set color page state 515-16
<br>
&nbsp; &nbsp; &nbsp;Subfunction 15H, Get color register 516
<br>
&nbsp; &nbsp; &nbsp;Subfunction 17H, Get block of color registers 516
<br>
&nbsp; &nbsp; &nbsp;Subfunction 1AH, Get color page state 517
<br>
&nbsp; &nbsp; &nbsp;Subfunction 1BH, Set gray-scale values 517
<br>
&nbsp; Function 11H, font functions
<br>
&nbsp; &nbsp; &nbsp;Subfunctions 00H and 10H, Load user font 518
<br>
&nbsp; &nbsp; &nbsp;Subfunctions 01H and 11H, Load ROM 8-by-14 font 518
<br>
&nbsp; &nbsp; &nbsp;Subfunctions 02H and 12H, Load ROM 8-by-8 font 519
<br>
&nbsp; &nbsp; &nbsp;Subfunction 03H, Set block specifier 520
<br>
&nbsp; &nbsp; &nbsp;Subfunctions 04H and 14H, Load ROM 8-by-16 font 520
<br>
&nbsp; &nbsp; &nbsp;Subfunction 20H, Set Int 1FH font pointer 521
<br>
&nbsp; &nbsp; &nbsp;Subfunction 21H, Set Int 43H for user's font 522
<br>
&nbsp; &nbsp; &nbsp;Subfunction 22H, Set Int 43H for ROM 8-by-14 font 522
<br>
&nbsp; &nbsp; &nbsp;Subfunction 23H, Set Int 43H for ROM 8-by-8 font 523
<br>
&nbsp; &nbsp; &nbsp;Subfunction 24H, Set Int 43H for ROM 8-by-16 font 523
<br>
&nbsp; &nbsp; &nbsp;Subfunction 30H, Get font information 524
<br>
&nbsp; Function 12H
<br>
&nbsp; &nbsp; &nbsp;Subfunction 10H, Get configuration information 525
<br>
&nbsp; &nbsp; &nbsp;Subfunction 20H, Select alternate printscreen 526
<br>
&nbsp; &nbsp; &nbsp;Subfunction 30H, Set scan lines 526
<br>
&nbsp; &nbsp; &nbsp;Subfunction 31H, Enable/disable default palette loading 526-27
<br>
&nbsp; &nbsp; &nbsp;Subfunction 32H, Enable/disable video 527
<br>
&nbsp; &nbsp; &nbsp;Subfunction 33H, Enable/disable gray-scale summing 527
<br>
&nbsp; &nbsp; &nbsp;Subfunction 34H, Enable/disable cursor emulation 528
<br>
&nbsp; &nbsp; &nbsp;Subfunction 35H, Switch active display 528
<br>
&nbsp; &nbsp; &nbsp;Subfunction 36H, Enable/disable screen refresh 529
<br>
&nbsp; Function 13H, Write string in teletype mode 529
<br>
&nbsp; Function 1AH, Get or set display combination code 530
<br>
&nbsp; Function 1BH, Get functionality/state information 531
<br>
&nbsp; Function 1CH, Save or restore video state 534
<br>
Int 11H, Get equipment configuration 535
<br>
Int 12H, Get conventional memory size 536
<br>
Int 13H, ROM BIOS disk driver 319
<br>
&nbsp; Function 00H, Reset disk system 536
<br>
&nbsp; Function 01H, Get disk system status 537
<br>
&nbsp; Function 02H, Read sector 538
<br>
&nbsp; Function 03H, Write sector 539
<br>
&nbsp; Function 04H, Verify sector 540
<br>
&nbsp; Function 05H, Format track 541
<br>
&nbsp; Function 06H, Format bad track 542
<br>
&nbsp; Function 07H, Format drive 543
<br>
&nbsp; Function 08H, Get drive parameters 543
<br>
&nbsp; Function 09H, Initialize fixed disk characteristics 544
<br>
&nbsp; Function 0AH, Read sector long 545
<br>
&nbsp; Function 0BH, Write sector long 546
<br>
&nbsp; Function 0CH, Seek 547
<br>
&nbsp; Function 0DH, Reset fixed disk system 548
<br>
&nbsp; Function 0EH, Read sector buffer 548
<br>
&nbsp; Function 0FH, Write sector buffer 549
<br>
&nbsp; Function 10H, Get drive status 549
<br>
&nbsp; Function 11H, Recalibrate drive 550
<br>
&nbsp; Function 12H, Controller RAM diagnostic 550
<br>
&nbsp; Function 13H, Controller drive diagnostic 551
<br>
&nbsp; Function 14H, Controller internal diagnostic 551
<br>
&nbsp; Function 15H, Get disk type 552
<br>
&nbsp; Function 16H, Get disk change status 552
<br>
&nbsp; Function 17H, Set disk type 553
<br>
&nbsp; Function 18H, Set media type for format 554
<br>
&nbsp; Function 19H, Park heads 554
<br>
&nbsp; Function 1AH, Format ESDI drive 555
<br>
Int 14H, ROM BIOS Serial communications port driver 111
<br>
&nbsp; Function 00H, Initialize communications port 556
<br>
&nbsp; Function 01H, Write character to communications port 557
<br>
&nbsp; Function 02H, Read character from communications port 558
<br>
&nbsp; Function 03H, Get communications port status 558
<br>
&nbsp; Function 04H, Extended initialize communications port 558
<br>
&nbsp; Function 05H, Extended communications port control 559
<br>
Int 15H, ROM BIOS I/O Subsystem Extensions
<br>
&nbsp; Function 00H, Turn on cassette motor 560
<br>
&nbsp; Function 01H, Turn off cassette motor 560
<br>
&nbsp; Function 02H, Read cassette 561
<br>
&nbsp; Function 03H, Write cassette 562
<br>
&nbsp; Function 0FH, Format ESDI drive periodic interrupt 562
<br>
&nbsp; Function 21H
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Read POST error log 563
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Write POST error log 563
<br>
&nbsp; Function 4FH, Keyboard intercept 564
<br>
&nbsp; Function 80H, Device open 564
<br>
&nbsp; Function 81H, Device close 565
<br>
&nbsp; Function 82H, Process termination 566
<br>
&nbsp; Function 83H, Event wait 566
<br>
&nbsp; Function 84H, Read joystick 567
<br>
&nbsp; Function 85H, SysReq key 568
<br>
&nbsp; Function 86H, Delay 568
<br>
&nbsp; Function 87H, Move extended memory block 569
<br>
&nbsp; Function 88H, Get extended memory size 570
<br>
&nbsp; Function 89H, Enter protected mode 570
<br>
&nbsp; Function 90H, Device wait 571
<br>
&nbsp; Function 91H, Device post 572
<br>
&nbsp; Function C0H, Get system environment 317, 573
<br>
&nbsp; Function C1H, Get address of extended BIOS data area 574
<br>
&nbsp; Function C2H
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Enable/disable pointing device 574
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Reset pointing device 575
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Set sample rate 576
<br>
&nbsp; &nbsp; &nbsp;Subfunction 03H, Set resolution 576
<br>
&nbsp; &nbsp; &nbsp;Subfunction 04H, Get pointing device type 577
<br>
&nbsp; &nbsp; &nbsp;Subfunction 05H, Initialize pointing device interface 577
<br>
&nbsp; &nbsp; &nbsp;Subfunction 06H, Set scaling or get status 578
<br>
&nbsp; &nbsp; &nbsp;Subfunction 07H, Set pointing device handler address 579
<br>
&nbsp; Function C3H, Set watchdog time-out 580
<br>
&nbsp; Function C4H, Programmable option select 580
<br>
Int 16H, ROM BIOS keyboard driver 322
<br>
&nbsp; Function 00H, Read character from keyboard 581
<br>
&nbsp; Function 01H, Get keyboard status 582
<br>
&nbsp; Function 02H, Get keyboard flags 582
<br>
&nbsp; Function 03H, Set repeat rate 583
<br>
&nbsp; Function 04H, Set keyclick 584
<br>
&nbsp; Function 05H, Push character and scan code 585
<br>
&nbsp; Function 10H, Read character from enhanced keyboard 585
<br>
&nbsp; Function 11H, Get enhanced keyboard status 586
<br>
&nbsp; Function 12H, Get enhanced keyboard flags 586
<br>
Int 17H, ROM BIOS Parallel port printer driver 108-19
<br>
&nbsp; Function 00H, Write character to printer 587
<br>
&nbsp; Function 01H, Initialize printer port 587
<br>
&nbsp; Function 02H, Get printer status 588
<br>
Int 18H, ROM BASIC 588
<br>
Int 19H, ROM BIOS Reboot system 588
<br>
Int 1AH, Real-time (CMOS) Clock Driver
<br>
&nbsp; Function 00H, Get tick count 589
<br>
&nbsp; Function 01H, Set tick count 589
<br>
&nbsp; Function 02H, Get time 590
<br>
&nbsp; Function 03H, Set time 590
<br>
&nbsp; Function 04H, Get date 591
<br>
&nbsp; Function 05H, Set date 591
<br>
&nbsp; Function 06H, Set alarm 591
<br>
&nbsp; Function 07H, Reset alarm 592
<br>
&nbsp; Function 0AH, Get day count 592
<br>
&nbsp; Function 0BH, Set day count 593
<br>
&nbsp; Function 80H, Set sound source 593
<br>
Int 20H, Terminate process 341
<br>
Int 21H, MS-DOS system functions
<br>
&nbsp; function execution in a typical I/O request 281-82
<br>
&nbsp; function summary by category 337-40 (table)
<br>
&nbsp; function summary by number 335-37 (table)
<br>
&nbsp; Function 00H, Terminate process 342
<br>
&nbsp; Function 01H, Character input with echo 70, 148, 343
<br>
&nbsp; Function 02H, Character output 90, 344
<br>
&nbsp; Function 03H, Auxiliary input 110, 344-45
<br>
&nbsp; Function 04H, Auxiliary output 110, 345-46
<br>
&nbsp; Function 05H, Printer output 107, 346-47
<br>
&nbsp; Function 06H, Direct console I/O 70, 73, 90, 347-48
<br>
&nbsp; Function 07H, Unfiltered character input without echo 70, 73, 348-49
<br>
&nbsp; Function 08H, Character input without echo 70, 349-50
<br>
&nbsp; Function 09H, Display string 90, 350-51
<br>
&nbsp; Function 0AH, Buffered keyboard input 70-71, 351-52
<br>
&nbsp; Function 0BH, Check input status 70, 353
<br>
&nbsp; Function 0CH, Flush input buffer and then input 70, 353-54
<br>
&nbsp; Function 0DH, Disk reset 354-55
<br>
&nbsp; Function 0EH, Select disk 167, 355-56
<br>
&nbsp; Function 0FH, Open file 132, 137, 356-57
<br>
&nbsp; Function 10H, Close file 132, 357-58
<br>
&nbsp; Function 11H, Find first file 358-59
<br>
&nbsp; Function 12H, Find next file 360-61
<br>
&nbsp; Function 13H, Delete file 132, 361-62
<br>
&nbsp; Function 14H, Sequential read 132, 362-63
<br>
&nbsp; Function 15H, Sequential write 132, 363-64
<br>
&nbsp; Function 16H, Create file 132, 364-65
<br>
&nbsp; Function 17H, Rename file 132, 173, 366-67
<br>
&nbsp; Function 18H, Reserved 367
<br>
&nbsp; Function 19H, Get current disk 167, 168, 367
<br>
&nbsp; Function 1AH, Set DTA address 130, 132, 368
<br>
&nbsp; Function 1BH, Get default drive data 368-69
<br>
&nbsp; Function 1CH, Get drive data 370
<br>
&nbsp; Function 1DH, Reserved 371
<br>
&nbsp; Function 1EH, Reserved 371
<br>
&nbsp; Function 1FH, Reserved 371
<br>
&nbsp; Function 20H, Reserved 371
<br>
&nbsp; Function 21H, Random read 132, 372-73
<br>
&nbsp; Function 22H, Random write 132, 373-75
<br>
&nbsp; Function 23H, Get file size 132, 375-76
<br>
&nbsp; Function 24H, Set relative record number 132, 376
<br>
&nbsp; Function 25H, Set interrupt vector 147, 252, 253, 316, 377-78
<br>
&nbsp; Function 26H, Create new PSP 378-79
<br>
&nbsp; Function 27H, Random block read 132, 379-80
<br>
&nbsp; Function 28H, Random block write 132, 381-82
<br>
&nbsp; Function 29H, Parse filename 129, 132, 382
<br>
&nbsp; Function 2AH, Get date 384-85
<br>
&nbsp; Function 2BH, Set date 385
<br>
&nbsp; Function 2CH, Get time 386
<br>
&nbsp; Function 2DH, Set time 386-87
<br>
&nbsp; Function 2EH, Set verify flag 387-88
<br>
&nbsp; Function 2FH, Get DTA address 388-89
<br>
&nbsp; Function 30H, Get MS-DOS version number 148, 319, 389
<br>
&nbsp; Function 31H, Terminate and stay resident 252, 253, 390-91
<br>
&nbsp; Function 32H, Reserved 392
<br>
&nbsp; Function 33H, Get or set break flag, get boot drive 392-93
<br>
&nbsp; Function 34H, Reserved 393
<br>
&nbsp; Function 35H, Get interrupt vector 252, 316, 393-94
<br>
&nbsp; Function 36H, Get drive allocation information 394-95
<br>
&nbsp; Function 37H, Reserved 395
<br>
&nbsp; Function 38H, Get or set country information 395-98
<br>
&nbsp; Function 39H, Create directory 167, 398-99
<br>
&nbsp; Function 3AH, Delete directory 167, 399
<br>
&nbsp; Function 3BH, Set current directory 167, 400
<br>
&nbsp; Function 3CH, Create file 140, 401-2
<br>
&nbsp; Function 3DH, Open file 107, 110, 140, 204, 402-4
<br>
&nbsp; Function 3EH, Close file 140, 204, 404
<br>
&nbsp; Function 3FH, Read file or device 67, 69, 71, 109, 110, 141, 298,
<br>
&nbsp; &nbsp; &nbsp; &nbsp;300, 322, 405-6
<br>
&nbsp; Function 40H, Write file or device 35, 88, 107, 109, 110, 141,
<br>
&nbsp; &nbsp; &nbsp; &nbsp;298, 300, 322, 406-7
<br>
&nbsp; Function 41H, Delete file 141, 407-8
<br>
&nbsp; Function 42H, Set file pointer 141, 408-9
<br>
&nbsp; Function 43H, Get or set file attributes 141, 410-11
<br>
&nbsp; Function 44H, IOCTL (I/O control) 69, 93-94, 111, 204, 205, 411-34
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, IOCTL: get device information 412-13
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, IOCTL: set device information 414-15
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, IOCTL: read control data from character device driver
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 415-16
<br>
&nbsp; &nbsp; &nbsp;Subfunction 03H, IOCTL: write control data to character device driver
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 416-17
<br>
&nbsp; &nbsp; &nbsp;Subfunction 04H, IOCTL: read control data from block device driver
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 418-19
<br>
&nbsp; &nbsp; &nbsp;Subfunction 05H, IOCTL: write control data to block device driver
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 419-20
<br>
&nbsp; &nbsp; &nbsp;Subfunction 06H, IOCTL: check input status 420-21
<br>
&nbsp; &nbsp; &nbsp;Subfunction 07H, IOCTL: check output status 421-22
<br>
&nbsp; &nbsp; &nbsp;Subfunction 08H, IOCTL: check if block device is removable 422-23
<br>
&nbsp; &nbsp; &nbsp;Subfunction 09H, IOCTL: check if block device is remote 423-24
<br>
&nbsp; &nbsp; &nbsp;Subfunction 0AH, IOCTL: check if handle is remote 424-25
<br>
&nbsp; &nbsp; &nbsp;Subfunction 0BH, IOCTL: change sharing retry count 425-26
<br>
&nbsp; &nbsp; &nbsp;Subfunction 0CH, IOCTL: generic I/O control for character devices
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 426-29
<br>
&nbsp; &nbsp; &nbsp;Subfunction 0DH, IOCTL: generic I/O control for block devices 429-32
<br>
&nbsp; &nbsp; &nbsp;Subfunction 0EH, IOCTL: get logical drive map 433
<br>
&nbsp; &nbsp; &nbsp;Subfunction 0FH, IOCTL: set logical drive map 434
<br>
&nbsp; Function 45H, Duplicate handle 141, 435
<br>
&nbsp; Function 46H, Redirect handle 141, 299, 436-37
<br>
&nbsp; Function 47H, Get current directory 167, 168, 437-38
<br>
&nbsp; Function 48H, Allocate memory block 196, 202, 323, 438-39
<br>
&nbsp; Function 49H, Release memory block 196, 323, 439-40
<br>
&nbsp; Function 4AH, Resize memory block 196, 198, 202, 219, 239, 322,
<br>
&nbsp; &nbsp; &nbsp; &nbsp;440-41
<br>
&nbsp; Function 4BH, Execute program (EXEC) 202, 299, 441-42 (see also EXEC
<br>
&nbsp; &nbsp; &nbsp; &nbsp;function)
<br>
&nbsp; Function 4CH, Terminate process with return code 26, 31, 35, 317,
<br>
&nbsp; &nbsp; &nbsp; &nbsp;443-44
<br>
&nbsp; Function 4DH, Get return code 221, 444-45
<br>
&nbsp; Function 4EH, Find first file 445-46
<br>
&nbsp; Function 4FH, Find next file 446-47
<br>
&nbsp; Function 50H, Reserved 447
<br>
&nbsp; Function 51H, Reserved 447
<br>
&nbsp; Function 52H, Reserved 447
<br>
&nbsp; Function 53H, Reserved 448
<br>
&nbsp; Function 54H, Get verify flag 448
<br>
&nbsp; Function 55H, Reserved 448
<br>
&nbsp; Function 56H, Rename file 141, 173, 449-50
<br>
&nbsp; Function 57H, Get or set file date and time 141, 450-51
<br>
&nbsp; Function 58H, Get or set allocation strategy 452-53
<br>
&nbsp; Function 59H, Get extended error information 130, 145, 148, 453-56
<br>
&nbsp; Function 5AH, Create temporary file 141, 457-58
<br>
&nbsp; Function 5BH, Create new file 141, 458-59
<br>
&nbsp; Function 5CH, Lock or unlock file region 141, 460-61
<br>
&nbsp; Function 5DH, Reserved 461
<br>
&nbsp; Function 5EH, Machine name and printer setup
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Get machine name 461-62
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Set printer setup string 462-63
<br>
&nbsp; &nbsp; &nbsp;Subfunction 03H, Get printer setup string 463-64
<br>
&nbsp; Function 5FH, Device redirection
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Get redirection list entry 464-65
<br>
&nbsp; &nbsp; &nbsp;Subfunction 03H, Redirect device 466-67
<br>
&nbsp; &nbsp; &nbsp;Subfunction 04H, Cancel device redirection 467-68
<br>
&nbsp; Function 60H, Reserved 468
<br>
&nbsp; Function 61H, Reserved 468
<br>
&nbsp; Function 62H, Get PSP address 468-69
<br>
&nbsp; Function 63H, Get DBCS lead byte table 469-70
<br>
&nbsp; Function 64H, Reserved 470
<br>
&nbsp; Function 65H, Get extended country information 470-74
<br>
&nbsp; Function 66H, Get or set code page 474-75
<br>
&nbsp; Function 67H, Set handle count 141, 475-76
<br>
&nbsp; Function 68H, Commit file 141, 476-77
<br>
&nbsp; Function 69H, Reserved 477
<br>
&nbsp; Function 6AH, Reserved 477
<br>
&nbsp; Function 6BH, Reserved 477
<br>
&nbsp; Function 6CH, Extended open file 141, 478-80
<br>
Int 22H, Terminate handler address 480
<br>
Int 23H, Ctrl-C handler address 317, 480-81
<br>
Int 24H, Critical-error handler address 147, 317, 481-82
<br>
Int 25H, Absolute disk read 482-84
<br>
Int 26H, Absolute disk write 319, 484-85
<br>
Int 27H, Terminate and stay resident 486-87
<br>
Int 28H, Reserved 487
<br>
Int 29H, Reserved 487
<br>
Int 2AH, Reserved 487
<br>
Int 2BH, Reserved 487
<br>
Int 2CH, Reserved 487
<br>
Int 2DH, Reserved 488
<br>
Int 2EH, Reserved 488
<br>
Int 2FH, Multiplex interrupt 488
<br>
&nbsp; Function 01H, Print spooler 488-89
<br>
&nbsp; Function 02H, ASSIGN 489
<br>
&nbsp; Function 10H, SHARE 490
<br>
&nbsp; Function B7H, APPEND 490-91
<br>
Int 33H, Microsoft Mouse driver 593
<br>
&nbsp; Function 00H, Reset mouse and get status 80, 594
<br>
&nbsp; Function 01H, Show mouse pointer 80, 594
<br>
&nbsp; Function 02H, Hide mouse pointer 80, 595
<br>
&nbsp; Function 03H, Get mouse position and button status 80, 595
<br>
&nbsp; Function 04H, Set mouse pointer position 80, 596
<br>
&nbsp; Function 05H, Get button press information 80, 596
<br>
&nbsp; Function 06H, Get button release information 80, 597
<br>
&nbsp; Function 07H, Set horizontal limits for pointer 80, 597
<br>
&nbsp; Function 08H, Set vertical limits for pointer 80, 598
<br>
&nbsp; Function 09H, Set graphics pointer shape 80, 598
<br>
&nbsp; Function 0AH, Set text pointer type 80, 599
<br>
&nbsp; Function 0BH, Read mouse motion counters 80, 599
<br>
&nbsp; Function 0CH, Set user-defined mouse event handler 80, 600
<br>
&nbsp; Function 0DH, Turn on light pen emulation 80, 601
<br>
&nbsp; Function 0EH, Turn off light pen emulation 80, 601
<br>
&nbsp; Function 0FH, Set mickeys to pixels ratio 80, 601
<br>
&nbsp; Function 10H, Set mouse pointer exclusion area 80, 602
<br>
&nbsp; Function 13H, Set double speed threshold 81, 602
<br>
&nbsp; Function 14H, Swap user-defined mouse event handlers 81, 603
<br>
&nbsp; Function 15H, Get mouse save state buffer size 81, 603
<br>
&nbsp; Function 16H, Save mouse driver state 81, 604
<br>
&nbsp; Function 17H, Restore mouse driver state 81, 604
<br>
&nbsp; Function 18H, Set alternate mouse event handler 81, 604
<br>
&nbsp; Function 19H, Get address of alternate mouse event handler 81, 606
<br>
&nbsp; Function 1AH, Set mouse sensitivity 81, 606
<br>
&nbsp; Function 1BH, Get mouse sensitivity 81, 607
<br>
&nbsp; Function 1CH, Set mouse interrupt rate 81, 607
<br>
&nbsp; Function 1DH, Select pointer page 81, 608
<br>
&nbsp; Function 1EH, Get pointer page 81, 608
<br>
&nbsp; Function 1FH, Disable mouse driver 81, 608
<br>
&nbsp; Function 20H, Enable mouse driver 81, 609
<br>
&nbsp; Function 21H, Reset mouse driver 81, 609
<br>
&nbsp; Function 22H, Set language for mouse driver messages 81, 610
<br>
&nbsp; Function 23H, Get language number 81, 610
<br>
&nbsp; Function 24H, Get mouse information 81, 611
<br>
Int 67H, Expanded Memory Manager functions 204, 205, 207
<br>
&nbsp; Function 40H, Get status 616
<br>
&nbsp; Function 41H, Get page frame address 616
<br>
&nbsp; Function 42H, Get number of pages 617
<br>
&nbsp; Function 43H, Allocate handle and pages 617
<br>
&nbsp; Function 44H, Map expanded memory page 618
<br>
&nbsp; Function 45H, Release handle and expanded memory 619
<br>
&nbsp; Function 46H, Get version 619
<br>
&nbsp; Function 47H, Save page map 620
<br>
&nbsp; Function 48H, Restore page map 620
<br>
&nbsp; Function 49H, Reserved 621
<br>
&nbsp; Function 4AH, Reserved 621
<br>
&nbsp; Function 4BH, Get handle count 621
<br>
&nbsp; Function 4CH, Get handle pages 622
<br>
&nbsp; Function 4DH, Get pages for all handles 623
<br>
&nbsp; Function 4EH
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Save page map 623
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Restore page map 624
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Save and restore page map 624
<br>
&nbsp; &nbsp; &nbsp;Subfunction 03H, Get size of page map information 625
<br>
&nbsp; Function 4FH
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Save partial page map 625
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Restore partial page map 626
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Get size of partial page map information 626
<br>
&nbsp; Function 50H
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Map multiple pages by number 627
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Map multiple pages by address 627
<br>
&nbsp; Function 51H, Reallocate pages for handle 628
<br>
&nbsp; Function 52H
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Get handle attribute 629
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Set handle attribute 629
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Get attribute capability 630
<br>
&nbsp; Function 53H
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Get handle name 630
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Set handle name 631
<br>
&nbsp; Function 54H
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Get all handle names 631
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Search for handle name 632
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Get total handles 632
<br>
&nbsp; Function 55H
<br>
&nbsp; &nbsp; &nbsp;Subfunctions 00H and 01H, Map pages and jump 633
<br>
&nbsp; Function 56H
<br>
&nbsp; &nbsp; &nbsp;Subfunctions 00H and 01H, Map pages and call 633
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Get stack space for map page and call 634
<br>
&nbsp; Function 57H
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Move memory region 635
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Exchange memory regions 635
<br>
&nbsp; Function 58H
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Get addresses of mappable pages 636
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Get number of mappable pages 637
<br>
&nbsp; Function 59H
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Get hardware configuration 637
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Get number of raw pages 638
<br>
&nbsp; Function 5AH
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Allocate handle and standard pages 638
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Allocate handle and raw pages 639
<br>
&nbsp; Function 5BH
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Get alternate map registers 639
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Set alternate map registers 640
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Get size of alternate map register save area 641
<br>
&nbsp; &nbsp; &nbsp;Subfunction 03H, Allocate alternate map register set 641
<br>
&nbsp; &nbsp; &nbsp;Subfunction 04H, Deallocate alternate map register set 642
<br>
&nbsp; &nbsp; &nbsp;Subfunction 05H, Allocate DMA register set
<br>
&nbsp; &nbsp; &nbsp;Subfunction 06H, Enable DMA on alternate map register set 643
<br>
&nbsp; &nbsp; &nbsp;Subfunction 07H, Disable DMA on alternate map register set 643
<br>
&nbsp; &nbsp; &nbsp;Subfunction 08H, Deallocate DMA register set 644
<br>
&nbsp; Function 5CH, Prepare expanded memory manager for warm boot 644
<br>
&nbsp; Function 5DH
<br>
&nbsp; &nbsp; &nbsp;Subfunction 00H, Enable EMM operating system functions 645
<br>
&nbsp; &nbsp; &nbsp;Subfunction 01H, Disable EMM operating system functions 645
<br>
&nbsp; &nbsp; &nbsp;Subfunction 02H, Release access key 646
<br>
Intel 80x86 microprocessor family 4, 8, 38, 64, 203
<br>
&nbsp; interrupts and 246-51
<br>
Intel 8259A Programmable Interrupt Controller 112, 320
<br>
internal hardware interrupts 246
<br>
internal (intrinsic) commands 14
<br>
interrupt(s) 13, 244-45. See also Int 10H through Int 67H
<br>
&nbsp; external hardware 247
<br>
&nbsp; internal hardware 246
<br>
&nbsp; servicing 250-51
<br>
&nbsp; software 247-49
<br>
&nbsp; types 244
<br>
interrupt handlers 16
<br>
&nbsp; example (ZERODIV.ASM) 254-58
<br>
&nbsp; MS-DOS and 252-53
<br>
&nbsp; servicing 250, 251
<br>
&nbsp; tasks 245
<br>
&nbsp; typical 251
<br>
interrupt (intr) routine, device-driver 266-67, 293. See also command code
<br>
&nbsp; &nbsp; routines
<br>
interrupt vector 17, 244
<br>
&nbsp; get 393-94
<br>
&nbsp; set 377-78
<br>
interrupt vector table 250
<br>
IOCTL (I/O control). See Int 21H, Function 44H
<br>
IO.SYS file 16, 17
<br>
&nbsp; memory location of 18
<br>
<br>
J
<br>
Japanese character set 6
<br>
joystick, read 567
<br>
<br>
K
<br>
kernel. See DOS kernel
<br>
keyboard
<br>
&nbsp; get enhanced flags 586-87
<br>
&nbsp; get enhanced status 586
<br>
&nbsp; get flags 582
<br>
&nbsp; get status 582
<br>
&nbsp; input with/without echo 70
<br>
&nbsp; intercept 564
<br>
&nbsp; key repeat rate and delay 583-84
<br>
&nbsp; push character and scan code in buffer 585
<br>
&nbsp; read character from 581
<br>
&nbsp; read character from enhanced 585
<br>
&nbsp; set keyclick 584
<br>
keyboard input 65-72
<br>
&nbsp; buffered 351-52
<br>
&nbsp; Ctrl-C and Ctrl-Break handlers 72-80, 317
<br>
&nbsp; with handles 66, 67-69
<br>
&nbsp; read character from keyboard 581
<br>
&nbsp; with ROM BIOS functions 71-72
<br>
&nbsp; with traditional calls 69-71
<br>
Keyboard input with echo 70
<br>
Keyboard input without echo 70
<br>
Keyboard intercept 564
<br>
Korean character set 6
<br>
<br>
L
<br>
LIB files 44, 45, 58. See also Library Manager (LIB)
<br>
Library Manager (LIB) 44, 58-60
<br>
&nbsp; operations prefix characters 58
<br>
&nbsp; table-of-contents listing for SLIBC.LIB 59
<br>
light pen
<br>
&nbsp; get position 503
<br>
&nbsp; turn off emulation 601
<br>
&nbsp; turn on emulation 601
<br>
line printer (PRN) 12, 106, 298
<br>
LINK. See Object Linker (LINK)
<br>
Load ROM 8-by-8 font 519
<br>
Load ROM 8-by-14 font 518-19
<br>
Load ROM 8-by-16 font 520-21
<br>
Load user font 518
<br>
Lock or unlock file region 460-61
<br>
Lotus/Intel/Microsoft Expanded Memory (LIM EMS). See Expanded Memory
<br>
&nbsp; &nbsp; Specification (EMS)
<br>
LPT1, LPT2, LPT3 devices 106, 298
<br>
LST files 45
<br>
<br>
M
<br>
machine name, get 461-62
<br>
Macro Assembler (MASM) 44, 45-47
<br>
&nbsp; command line mode 46
<br>
&nbsp; interactive mode 46
<br>
&nbsp; levels
<br>
&nbsp; &nbsp; &nbsp;modules 37
<br>
&nbsp; &nbsp; &nbsp;procedures 41-42
<br>
&nbsp; &nbsp; &nbsp;segments 38-41
<br>
&nbsp; tutorials 63
<br>
&nbsp; version 5.1 switches 47
<br>
make files 61
<br>
MAKE utility 60-61
<br>
&nbsp; switches for 61
<br>
Map expanded memory page (EMS) 618
<br>
MAP files 45
<br>
Map multiple pages by address (EMS) 627-28
<br>
Map multiple pages by number (EMS) 627
<br>
Map pages and call (EMS) 633-34
<br>
MASM. See Macro Assembler (MASM)
<br>
master boot record 192
<br>
Media Check (function 01H) 270-71
<br>
memory
<br>
&nbsp; allocation
<br>
&nbsp; &nbsp; &nbsp;dynamic, of additional 199-201
<br>
&nbsp; &nbsp; &nbsp;shrinking 197-99
<br>
&nbsp; conventional 196
<br>
&nbsp; &nbsp; &nbsp;moving blocks of data between extended memory and 213-15
<br>
&nbsp; expanded (see Expanded Memory Specification (EMS))
<br>
&nbsp; image of .COM file 26
<br>
&nbsp; image of .EXE file 31
<br>
&nbsp; location of disk bootstrap program in 17
<br>
&nbsp; location of IO.SYS in 18
<br>
&nbsp; location of ROM bootstrap routine in 16
<br>
&nbsp; location of SYSINIT, DOS kernel, MSDOS.SYS in 19
<br>
&nbsp; making available, for EXEC function 218-19
<br>
&nbsp; map after startup 20
<br>
&nbsp; RAM 196
<br>
memory areas, 196. See also arena entries; arena headers; transient program
<br>
&nbsp; &nbsp; area (TPA)
<br>
memory block
<br>
&nbsp; allocate 438-39
<br>
&nbsp; get/set allocation strategy 452-53
<br>
&nbsp; move extended 569-60
<br>
&nbsp; release 439-40
<br>
&nbsp; resize 440-41
<br>
memory interlace 203
<br>
memory management 195-215
<br>
&nbsp; arena headers 201-2
<br>
&nbsp; expanded memory 203-11
<br>
&nbsp; &nbsp; &nbsp;using 207-11
<br>
&nbsp; extended memory 212-15
<br>
&nbsp; Int 21H functions summary 339
<br>
&nbsp; MS-DOS applications compatibility and 316
<br>
&nbsp; using memory-allocation functions 197-202
<br>
memory-mapped input/output 86, 96-103
<br>
&nbsp; graphics mode 101-3
<br>
&nbsp; text mode 96-101
<br>
memory models 39
<br>
&nbsp; segments, groups, classes for 40
<br>
memory segment 321-22
<br>
memory size
<br>
&nbsp; get conventional 536
<br>
&nbsp; get extended 570
<br>
mickeys, set to pixel ratio 601
<br>
Microsoft Mouse driver 593-611
<br>
miscellaneous system functions, Int 21H functions summary 340
<br>
MKDIR (MD) command 167
<br>
Monochrome/Printer Display Adapter (MDA) 86, 97, 98
<br>
&nbsp; example dump, regen buffer 98
<br>
MOUDEMO.C program 82-83
<br>
mouse. See also pointing device
<br>
&nbsp; disable driver 608-9
<br>
&nbsp; driver 593
<br>
&nbsp; enable driver 609
<br>
&nbsp; get address of alternate event handler 606
<br>
&nbsp; get button press information 596
<br>
&nbsp; get button release information 597
<br>
&nbsp; get information 611
<br>
&nbsp; get language number 610
<br>
&nbsp; get mouse save state buffer size 603-4
<br>
&nbsp; get position and button status 595
<br>
&nbsp; get sensitivity 607
<br>
&nbsp; hide pointer 595
<br>
&nbsp; input 80-83
<br>
&nbsp; read motion counters 599-600
<br>
&nbsp; reset and get status 594
<br>
&nbsp; reset driver 609
<br>
&nbsp; save driver state 604
<br>
&nbsp; set alternate event handler 604-5
<br>
&nbsp; set double speed threshold 602
<br>
&nbsp; set graphics pointer shape 598
<br>
&nbsp; set interrupt rate 607
<br>
&nbsp; set language for driver messages 610
<br>
&nbsp; set pointer exclusion area 602
<br>
&nbsp; set pointer horizontal limits 597-98
<br>
&nbsp; set pointer page 608
<br>
&nbsp; set pointer position 596
<br>
&nbsp; set pointer vertical limits 598
<br>
&nbsp; set sensitivity 606
<br>
&nbsp; set text pointer type 599
<br>
&nbsp; set user-defined event handler 600-601
<br>
&nbsp; show pointer 594-95
<br>
&nbsp; summary of function calls 494-99
<br>
&nbsp; swap user-defined event handlers 603
<br>
Move extended memory block 569-70
<br>
Move memory region (EMS) 635
<br>
MS-DOS. See also Operating System/2 (OS/2)
<br>
&nbsp; genealogy 3-9
<br>
&nbsp; interrupt handlers and 252-53
<br>
&nbsp; loading 16-20
<br>
&nbsp; programming tools (see programming tools)
<br>
&nbsp; structure 12-16
<br>
MS-DOS application programs, porting to OS/2 318-31
<br>
&nbsp; conversion 326-30
<br>
&nbsp; encapsulation 323, 324-25
<br>
&nbsp; MS-DOS function calls and OS/2 counterparts 328-29
<br>
&nbsp; optimization 330-31
<br>
&nbsp; rationalization 322-23
<br>
&nbsp; ROM BIOS functions and OS/2 equivalents used in MS-DOS applications 330
<br>
&nbsp; segmentation 321-22
<br>
MS-DOS application programs, structure of 21-42
<br>
&nbsp; assembly-language programs 27-30, 37-42
<br>
&nbsp; .COM programs introduced 25-30
<br>
&nbsp; creation of 62-63
<br>
&nbsp; .EXE programs introduced 30-36
<br>
&nbsp; program procedures 41-42
<br>
&nbsp; program segment prefix 23-25
<br>
MS-DOS application programs, writing compatible 314, 315-17
<br>
&nbsp; check host capabilities 316
<br>
&nbsp; exception handling 317
<br>
&nbsp; input and output 316
<br>
&nbsp; memory management 316
<br>
&nbsp; process management 317
<br>
&nbsp; program structure 315
<br>
MS-DOS error codes 145-51
<br>
MS-DOS functions 334
<br>
&nbsp; conversion of, to OS/2 function calls 326-27
<br>
&nbsp; display functions 88-94
<br>
&nbsp; &nbsp; &nbsp;binary output mode 93-94
<br>
&nbsp; &nbsp; &nbsp;screen control 91-93
<br>
&nbsp; EXEC (see EXEC function)
<br>
&nbsp; file control block (FCB) 129-39
<br>
&nbsp; handle 139-44
<br>
&nbsp; memory management/allocation 196, 197-202
<br>
&nbsp; OS/2 equivalents to 328-29
<br>
&nbsp; printer output 107-9
<br>
&nbsp; reference (see Section II)
<br>
&nbsp; serial port 109-12
<br>
&nbsp; typical in-line code for call to 324
<br>
MSDOS.SYS file 13, 16
<br>
&nbsp; memory location of 19
<br>
MS-DOS versions
<br>
&nbsp; 1.0 4-5, 138
<br>
&nbsp; 1.25 5
<br>
&nbsp; 2.00 5-6, 174
<br>
&nbsp; &nbsp; &nbsp;error codes 145
<br>
&nbsp; &nbsp; &nbsp;volume-label search under 175
<br>
&nbsp; 2.11, 2.25 6
<br>
&nbsp; 3.0 6-7, 138, 174
<br>
&nbsp; &nbsp; &nbsp;error codes 145-46
<br>
&nbsp; &nbsp; &nbsp;volume-label search under 176
<br>
&nbsp; 3.1, 3.2, 3.3, 4.0 7
<br>
&nbsp; get number 389-90
<br>
&nbsp; support for select command code routines by 267-68 (table)
<br>
Multi-Color Graphics Array (MCGA) 86, 102
<br>
Multiplex interrupt 488
<br>
<br>
N
<br>
NAME statement 27, 33
<br>
NEAR attribute 27
<br>
&nbsp; vs FAR 29
<br>
NEAR RETURN 27
<br>
network functions, Int 21H functions summary 339
<br>
Nondestructive Read (function 05H) 274
<br>
non-disk-related errors 147, 148 (table)
<br>
<br>
O
<br>
Object Linker (LINK) 37, 44, 50-55
<br>
&nbsp; map produced by, of HELLO.EXE program 51
<br>
&nbsp; switches accepted by 53-55
<br>
object modules 37
<br>
&nbsp; libraries (see Library Manager (LIB))
<br>
&nbsp; linking .COM files from 27, 37. See also Object Linker (LINK)
<br>
OBJ files 45
<br>
Open file 356-57, 402-4
<br>
Operating System/2 (OS/2) 7
<br>
&nbsp; code optimization 330-31
<br>
&nbsp; compatibility issues 318-20
<br>
&nbsp; function calls equivalent to MS-DOS function calls 328-29
<br>
&nbsp; function calls equivalent to ROM BIOS function calls 330
<br>
&nbsp; porting MS-DOS applications to OS/2 320-31
<br>
ORG instruction 29
<br>
output. See character input/output; printer output; serial port
<br>
output status, check 421-22
<br>
Output Status (command-code function 0AH) 276
<br>
Output Until Busy (function 10H) 278-79
<br>
overlays, loading with EXEC 240, 241-42
<br>
<br>
P
<br>
PAGE command 27, 33
<br>
page frame 203
<br>
palette
<br>
&nbsp; enable/disable default 526-27
<br>
&nbsp; get border and 514
<br>
&nbsp; get register 513
<br>
&nbsp; set 508-9
<br>
&nbsp; set border and 512-13
<br>
&nbsp; set register 511-12
<br>
parallel ports 106
<br>
parameter block, requesting EXEC function 220-21
<br>
parent programs 218
<br>
Park heads 554-55
<br>
Parse filename 382-84
<br>
partitions, fixed-disk 192-94
<br>
Paterson, Tim 4
<br>
path 166
<br>
PC-DOS
<br>
&nbsp; version 1.0 4
<br>
&nbsp; version 1.1 5
<br>
&nbsp; version 2.0 5-6
<br>
&nbsp; version 3.0 193-94
<br>
piping parameters 24
<br>
pixel 101
<br>
&nbsp; formula to calculate bit position for 102-3
<br>
&nbsp; read graphics 510
<br>
&nbsp; set mickeys to pixel ratio 601-2
<br>
&nbsp; write graphics 509
<br>
pointing device
<br>
&nbsp; enable/disable 574-75
<br>
&nbsp; get device type 577
<br>
&nbsp; get scaling or get status 578-79
<br>
&nbsp; initialize interface 577-78
<br>
&nbsp; input 80-83
<br>
&nbsp; reset 575
<br>
&nbsp; set handler address 579-80
<br>
&nbsp; set resolution 576-77
<br>
&nbsp; set sample rate 576
<br>
POP instruction 35
<br>
portability. See compatibility and portability
<br>
POST (power-on self-test)
<br>
&nbsp; read error log 563
<br>
&nbsp; write error log 563-64
<br>
Prepare expanded memory manager for warm boot (EMS) 644-45
<br>
Presentation Manager, OS/2 318
<br>
printer 106, 107-9. See also line printer (PRN); standard printer (stdprn)
<br>
&nbsp; get setup strings 463-64
<br>
&nbsp; get status 588
<br>
&nbsp; initialize port 587
<br>
&nbsp; write character to 587
<br>
printer output 106, 107-9, 346-47. See also TALK.ASM program
<br>
printer setup string
<br>
&nbsp; get 463-64
<br>
&nbsp; set 462-63
<br>
printscreen, select alternate 526
<br>
Print spooler 488-89
<br>
PRN device 12, 106, 298-99
<br>
PROC command 29, 35, 41
<br>
procedure, declaring beginning/end of 29
<br>
process management
<br>
&nbsp; for compatibility in MS-DOS applications 317
<br>
&nbsp; Int 21H functions summary 339
<br>
&nbsp; terminate process 566
<br>
Process termination 566
<br>
Programmable Interrupt Controller (PIC) 247
<br>
Programmable option select 580-81
<br>
programming tools 43-64
<br>
&nbsp; C Optimizing compiler 48-50
<br>
&nbsp; CREF utility 56-58
<br>
&nbsp; example using 62-63
<br>
&nbsp; EXE2BIN utility 55-56
<br>
&nbsp; file types 45
<br>
&nbsp; Library Manager 58-60
<br>
&nbsp; MAKE utility 60-61
<br>
&nbsp; MASM 45-47 (see also Macro Assembler (MASM))
<br>
&nbsp; Object Linker 50-55 (see also Object Linker (LINK))
<br>
&nbsp; resources and references 63-64
<br>
program modules, assembly-language 37
<br>
program procedures 41-42
<br>
program segment prefix (PSP) 15, 23-25
<br>
&nbsp; create new 378-79
<br>
&nbsp; get address 468-69
<br>
&nbsp; structure of 23
<br>
program segments, assembly-language 38-41
<br>
protected mode, enter 570-71
<br>
PROTO.ASM program 301-2
<br>
PROTO.C program 303
<br>
P-system operating system 5
<br>
Push character and scan code 585
<br>
PUSH instruction 35
<br>
<br>
R
<br>
Random block read 379-80
<br>
Random block write 381-82
<br>
Random read 372-73
<br>
Random write 373-75
<br>
rationalizing code 322-23
<br>
raw mode 69
<br>
Read (function 04H) 273
<br>
Read cassette 561
<br>
Read character and attribute at cursor 506
<br>
Read character from communications port 558
<br>
Read character from enhanced keyboard 585
<br>
Read character from keyboard 581
<br>
Read control data from block-device driver 418-19
<br>
Read control data from character device driver 415-16
<br>
Read file or device 405-6
<br>
Read graphics pixel 510
<br>
Read joystick 567
<br>
Read mouse motion counters 599-600
<br>
Read POST error log 563
<br>
Read sector 538-39
<br>
Read sector buffer 548
<br>
Read sector long 545-46
<br>
Reallocate pages for handle (EMS) 628
<br>
Reboot system 588-89
<br>
Recalibrate drive 550
<br>
record(s)
<br>
&nbsp; set relative number 376-77
<br>
&nbsp; using FCB functions 129-39
<br>
&nbsp; using handle functions 139-44
<br>
record operations, Int 21H functions summary 338-39
<br>
Redirect device 466-67
<br>
Redirect handle 436-37
<br>
redirection, input/output 24, 67, 298-99
<br>
&nbsp; cancel 467-68
<br>
redirection list entry, get 464-65
<br>
REF files 45, 56
<br>
refresh buffer 86
<br>
regen buffer 86
<br>
&nbsp; example dump of MDA adapter 98
<br>
&nbsp; formula to determine offset 102
<br>
&nbsp; memory diagram showing location of 87
<br>
Release access key (EMS) 646
<br>
Release handle and expanded memory (EMS) 619
<br>
Release memory block 439-40
<br>
Removable Media (function 0FH) 278
<br>
REN(AME) command 14
<br>
Rename file 366-67, 449-50
<br>
request header format 265
<br>
&nbsp; command codes for (see command code routines, device-driver)
<br>
reserved area, disk 182
<br>
reserved functions
<br>
&nbsp; EMS 621
<br>
&nbsp; Int 21H functions summary 340
<br>
Reset alarm 592
<br>
Reset disk system 536-37
<br>
Reset fixed disk system 548
<br>
Reset mouse and get status 594
<br>
Reset mouse driver 609
<br>
Reset pointing device 575
<br>
resident device drivers 12
<br>
Resize memory block 440-41
<br>
RESTORE command 15
<br>
Restore mouse driver state 604
<br>
Restore page map (EMS) 620-21, 624
<br>
Restore partial page map (EMS) 626
<br>
RET instruction 41
<br>
retrace interval 100
<br>
return code
<br>
&nbsp; get 444
<br>
&nbsp; terminate process with 443-44
<br>
RMDIR (RD) command 167
<br>
ROM 8-by-8 font
<br>
&nbsp; load 519
<br>
&nbsp; set Int 43H for 523
<br>
ROM 8-by-14 font
<br>
&nbsp; load 518-19
<br>
&nbsp; set Int 43H for 522-23
<br>
ROM 8-by-16 font
<br>
&nbsp; load 520-21
<br>
&nbsp; set Int 43H for 523-24
<br>
ROM BASIC 588
<br>
ROM BIOS
<br>
&nbsp; display functions 94-96, 330
<br>
&nbsp; interrupts of special importance to 247, 248-49
<br>
&nbsp; keyboard functions 67
<br>
&nbsp; &nbsp; &nbsp;input with 71-72
<br>
ROM BIOS compatibility 314-16, 317-18
<br>
&nbsp; avoid unstable hardware 318
<br>
&nbsp; check host capabilities 317-18
<br>
&nbsp; functions of, and OS/2 equivalents 330
<br>
ROM BIOS function calls. See also Section III
<br>
&nbsp; summary 494-99
<br>
ROM bootstrap routine 16
<br>
root directory 166, 184-86, 187
<br>
&nbsp; partial hex dump 186
<br>
RS-232 serial-interface standard 106
<br>
RS-422 serial-interface standard 106
<br>
<br>
S
<br>
Save and restore page map (EMS) 624-25
<br>
Save mouse driver state 604
<br>
Save or restore video state 534-35
<br>
Save page map (EMS) 620, 623
<br>
Save partial page map (EMS) 625-26
<br>
scan lines, set 526
<br>
screen control with MS-DOS functions 91-93
<br>
screen refresh, enable/disable 529
<br>
Search for handle name (EMS) 632
<br>
Seattle Computer Products 4
<br>
Seek 547
<br>
SEGMENT command 29, 33, 38
<br>
segment register 321
<br>
Select alternate printscreen 526
<br>
Select disk 355-56
<br>
selector 321
<br>
Select pointer page 608
<br>
Sequential read 362-63
<br>
Sequential write 363-64
<br>
serial port 106, 109-12. See also TALK.ASM program
<br>
&nbsp; extended initialize port 558-59
<br>
&nbsp; extended port control 559-60
<br>
&nbsp; get status 558
<br>
&nbsp; initialize 556-57
<br>
&nbsp; read character from 558
<br>
&nbsp; write character to 557
<br>
Set alarm 591-92
<br>
Set alternate map registers (EMS) 640
<br>
Set alternate mouse event handler 604-5
<br>
Set block of color registers 515
<br>
Set block specifier 520
<br>
Set border color 512
<br>
Set color page state 515-16
<br>
Set color register 514-15
<br>
Set current directory 400
<br>
Set cursor position 501-2
<br>
Set cursor type 501
<br>
Set date 385, 591
<br>
Set day count 593
<br>
Set device information 414-15
<br>
Set disk type 553
<br>
Set display page 503-4
<br>
Set double speed threshold 602
<br>
Set DTA address 368
<br>
Set file pointer 408-9
<br>
Set graphics pointer shape 598
<br>
Set gray-scale values 517
<br>
Set handle attribute (EMS) 629
<br>
Set handle count 475-76
<br>
Set handle name (EMS) 631
<br>
Set horizontal limits for pointer 597-98
<br>
Set Int 1FH font pointer 521
<br>
Set Int 43H for ROM 8-by-8 font 523
<br>
Set Int 43H for ROM 8-by-14 font 522-23
<br>
Set Int 43H for ROM 8-by-16 font 523-24
<br>
Set Int 43H for user's font 522
<br>
Set interrupt vector 377-78
<br>
Set keyclick 584
<br>
Set language for mouse driver messages 610
<br>
Set Logical Device (function 18H) 280-81
<br>
Set logical drive map 434
<br>
Set media type for format 554
<br>
Set mickeys to pixels ratio 601
<br>
Set mouse interrupt rate 607
<br>
Set mouse pointer exclusion area 602
<br>
Set mouse pointer position 596
<br>
Set mouse sensitivity 606
<br>
Set palette and border 512-13
<br>
Set palette, background, or border 508-9
<br>
Set palette register 511-12
<br>
Set pointing device handler address 579-80
<br>
Set printer setup string 462-63
<br>
Set relative record number 376-77
<br>
Set repeat rate 583-84
<br>
Set resolution 576-77
<br>
Set sample rate 576
<br>
Set scaling or get status 578-79
<br>
Set scan lines 526
<br>
Set sound source 593
<br>
Set text pointer type 599
<br>
Set tick count 589-90
<br>
Set time 386-87, 590
<br>
Set user-defined mouse event handler 600-601
<br>
Set verify flag 387-88
<br>
Set vertical limits for pointer 598
<br>
Set video mode 500-501
<br>
Set watchdog time-out 580
<br>
SHARE 490
<br>
shell. See COMMAND.COM file; command processor (shell)
<br>
SHELL.ASM program 229-38
<br>
SHELL.C program 225-29
<br>
Show mouse pointer 594-95
<br>
SLIBC.LIB, table-of-contents listing for 59
<br>
Softech company 5
<br>
software interrupts, 247-49
<br>
sound source, set 593
<br>
STACK attribute 31
<br>
stack pointer (SP) register 25-26, 31, 35
<br>
stack segment 38
<br>
stack segment (SS) register 31, 35
<br>
standard auxiliary device (stdaux) 20, 323
<br>
&nbsp; default device 298
<br>
&nbsp; handle 66
<br>
standard error device (stderr) 20
<br>
&nbsp; default device 298
<br>
&nbsp; handle 66
<br>
standard input device (stdin) 20
<br>
&nbsp; default device 298
<br>
&nbsp; handle 66, 67
<br>
standard list device 20, 323
<br>
standard output device (stdout) 20
<br>
&nbsp; default device 298
<br>
&nbsp; handle 66
<br>
standard printer (stdprn)
<br>
&nbsp; default device 298
<br>
&nbsp; handle 66
<br>
strategy (strat) routine, device-driver 265, 293
<br>
string(s)
<br>
&nbsp; display 350-51
<br>
Swap user-defined mouse event handlers 603
<br>
Switch active display 528-29
<br>
switches
<br>
&nbsp; C Optimizing compiler 49-50
<br>
&nbsp; Library Manager 60
<br>
&nbsp; Macro Assembler 47
<br>
&nbsp; Make utility 61
<br>
&nbsp; Object Linker 53-55
<br>
SYSINIT module 17, 18, 20
<br>
&nbsp; installing device drivers 293
<br>
&nbsp; memory location of 19
<br>
SysReq key 568
<br>
system file table 140-41
<br>
<br>
T
<br>
TALK.ASM program 113-26
<br>
teletype mode
<br>
&nbsp; write character in 510-11
<br>
&nbsp; write string in 529-30
<br>
terminal-emulator program. See TALK.ASM program
<br>
Terminate and stay resident 390-91, 486-87
<br>
Terminate handler address 480
<br>
Terminate process 341, 342
<br>
Terminate process with return code 443-44
<br>
text-mode memory-mapped programming 96-101
<br>
threads 331
<br>
time and date
<br>
&nbsp; day count 592, 593
<br>
&nbsp; get date 384-85, 591
<br>
&nbsp; get time 386, 590
<br>
&nbsp; set date 385, 591
<br>
&nbsp; set time 386-87, 590
<br>
TITLE command 27, 33
<br>
Toggle blink/intensity bit 513
<br>
transient program 15, 22. See also .COM program file(s);
<br>
&nbsp; &nbsp; .EXE (executable) program file(s)
<br>
transient program area (TPA) 15, 196. See also arena entries; arena
<br>
&nbsp; &nbsp; headers
<br>
TREE command 174
<br>
TRYBREAK.C program 78-79
<br>
Turn off cassette motor 560-61
<br>
Turn on cassette motor 560
<br>
Turn off light pen emulation 601
<br>
Turn on light pen emulation 601
<br>
<br>
U
<br>
Unfiltered character input without echo 348-49
<br>
UNIX/XENIX operating system 66, 128, 139
<br>
user font
<br>
&nbsp; load 518
<br>
&nbsp; set Int 1FH pointer 521
<br>
&nbsp; set Int 43H for 522
<br>
<br>
V
<br>
verify flag, get 448
<br>
Verify sector 540
<br>
video display 85-103
<br>
&nbsp; adapters 86-87
<br>
&nbsp; enable/disable 527
<br>
&nbsp; get functionality/state information 531-34
<br>
&nbsp; get or set combination code 530-31
<br>
&nbsp; memory-mapped techniques 96-103
<br>
&nbsp; &nbsp; &nbsp;graphics mode 101-3
<br>
&nbsp; &nbsp; &nbsp;text mode 96-101
<br>
&nbsp; MS-DOS display functions 88-94
<br>
&nbsp; &nbsp; &nbsp;binary output mode 93-94
<br>
&nbsp; &nbsp; &nbsp;screen control with 91-93
<br>
&nbsp; ROM BIOS display functions 94-96
<br>
&nbsp; save or restore video state 534-35
<br>
&nbsp; support considerations 88
<br>
&nbsp; switch active display 528-29
<br>
Video Graphics Array (VGA) 86, 97, 98, 102
<br>
video mode
<br>
&nbsp; get 511
<br>
&nbsp; set 500-501
<br>
VOL command 174
<br>
volume labels 174-76
<br>
&nbsp; search, using extended file control block 175
<br>
<br>
W
<br>
watchdog time-out, set 580
<br>
window
<br>
&nbsp; initialize or scroll down 505-6
<br>
&nbsp; initialize or scroll up 505
<br>
Windows 7, 318
<br>
Write (function 08H) 275
<br>
Write cassette 562
<br>
Write character and attribute at cursor 506-7
<br>
Write character at cursor 507-8
<br>
Write character in teletype mode 510-11
<br>
Write character to communications port 557
<br>
Write character to printer 587
<br>
Write control data to block-device driver 419-20
<br>
Write control data to character-device driver 416-17
<br>
Write File or Device 406-7
<br>
Write graphics pixel 509
<br>
Write POST error log 563-64
<br>
Write screen in teletype mode 529-30
<br>
Write sector 539
<br>
Write sector buffer 549
<br>
Write sector long 546-47
<br>
Write with Verify (function 09H) 276
<br>
<br>
Z
<br>
ZERODIV.ASM program 254, 255-58
<br>
Zilog Z-80 microprocessor 4
<br>
</div>
<div id="footer">
You are viewing proxied material from <a href="/gopher.viste.fr/">gopher.viste.fr</a>.
The copyright of proxied material belongs to its original authors.
Any comments or complaints in relation to proxied material should be directed to the original authors of the content concerned.
Please see the <a href="/disclaimer/">disclaimer</a> for more details.
</div>
<div style="margin:0 0 16px;">
<div class="alignleft">
<script style="display: none !important;">!function(e,t,r,n,c,a,l){function i(t,r){return r=e.createElement('div'),r.innerHTML='<a href="'+t.replace(/"/g,'&quot;')+'"></a>',r.childNodes[0].getAttribute('href')}function o(e,t,r,n){for(r='',n='0x'+e.substr(t,2)|0,t+=2;t<e.length;t+=2)r+=String.fromCharCode('0x'+e.substr(t,2)^n);return i(r)}try{for(c=e.getElementsByTagName('a'),l='/cdn-cgi/l/email-protection#',n=0;n<c.length;n++)try{(t=(a=c[n]).href.indexOf(l))>-1&&(a.href='mailto:'+o(a.href,t+l.length))}catch(e){}for(c=e.querySelectorAll('.__cf_email__'),n=0;n<c.length;n++)try{(a=c[n]).parentNode.replaceChild(e.createTextNode(o(a.getAttribute('data-cfemail'),0)),a)}catch(e){}}catch(e){}}(document);</script><script type='text/javascript'>
 amzn_assoc_ad_type = 'banner';
  amzn_assoc_tracking_id = 'gopherproxy-20';
   amzn_assoc_marketplace = 'amazon';
    amzn_assoc_region = 'US';
     amzn_assoc_placement = 'assoc_banner_placement_default';
      amzn_assoc_linkid = 'MQGWWS7WKMK5X5PR';
       amzn_assoc_campaigns = 'electronics';
        amzn_assoc_p = '48';
         amzn_assoc_banner_type = 'rotating';
          amzn_assoc_width = '728';
           amzn_assoc_height = '90';
           </script>
<script src='https://z-na.amazon-adsystem.com/widgets/q?ServiceVersion=20070822&Operation=GetScript&ID=OneJS&WS=1'></script>
</div>
</div>

<div class="g-plusone" data-annotation="inline" data-href="http://gopherproxy.meulie.net/"></div>
<div class="fb-like" data-href="http://gopherproxy.meulie.net/" data-send="false" data-width="450" data-show-faces="true" data-action="recommend"></div>

<script type="text/javascript">
  window.___gcfg = {lang: 'en-GB'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</body>
</html>
